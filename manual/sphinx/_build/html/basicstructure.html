

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Basic structure and functionality &mdash; radmc3d 2.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Dust continuum radiative transfer" href="dustradtrans.html" />
    <link rel="prev" title="Installation of RADMC-3D" href="installation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> radmc3d
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstarting with RADMC-3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview of the RADMC-3D package</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation of RADMC-3D</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Basic structure and functionality</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basic-dataflow">Basic dataflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="#radiative-processes">Radiative processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coordinate-systems">Coordinate systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-spatial-grid">The spatial grid</a></li>
<li class="toctree-l2"><a class="reference internal" href="#computations-that-radmc-3d-can-perform">Computations that RADMC-3D can perform</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-a-model-is-set-up-and-computed-a-rough-overview">How a model is set up and computed: a rough overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#organization-of-model-directories">Organization of model directories</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-the-example-models">Running the example models</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dustradtrans.html">Dust continuum radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="lineradtrans.html">Line radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="imagesspectra.html">Making images and spectra</a></li>
<li class="toctree-l1"><a class="reference internal" href="gridding.html">More information about the gridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="stars.html">More information about the treatment of stars</a></li>
<li class="toctree-l1"><a class="reference internal" href="internalsetup.html">Modifying RADMC-3D: Internal setup and user-specified radiative processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythontools.html">Python analysis tool set</a></li>
<li class="toctree-l1"><a class="reference internal" href="toolsinside.html">Analysis tools inside of radmc3d</a></li>
<li class="toctree-l1"><a class="reference internal" href="vtkoutput.html">Visualization with VTK tools (e.g. Paraview or VisIt)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tipsandtricks.html">Tips, tricks and problem hunting</a></li>
<li class="toctree-l1"><a class="reference internal" href="inputoutputfiles.html">Main input and output files of RADMC-3D</a></li>
<li class="toctree-l1"><a class="reference internal" href="binaryio.html">Binary I/O files</a></li>
<li class="toctree-l1"><a class="reference internal" href="clioptions.html">Command-line options</a></li>
<li class="toctree-l1"><a class="reference internal" href="optionscompat.html">Which options are mutually incompatible?</a></li>
<li class="toctree-l1"><a class="reference internal" href="opacitieswww.html">Acquiring opacities from the WWW</a></li>
<li class="toctree-l1"><a class="reference internal" href="versiontracker.html">Version tracker: Development history</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">radmc3d</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Basic structure and functionality</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/basicstructure.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="basic-structure-and-functionality">
<span id="chap-basic-struct-and-func"></span><h1>Basic structure and functionality<a class="headerlink" href="#basic-structure-and-functionality" title="Permalink to this headline">¶</a></h1>
<p>RADMC-3D is a very versatile radiative transfer package with many
possibilities. As a consequence it is a rather complex package. However, we
have tried to keep it still as easy as possible to use as a first-time
user. We tried to do so by keeping many of the sophisticated options
‘hidden’ and having many default settings already well-chosen. The idea is
that one can already use the code at an entry level, and then gradually work
oneself into the more fancy options.</p>
<p>RADMC-3D is a general-purpose package, so there are no ‘built-in’ models
inside the <code class="docutils literal notranslate"><span class="pre">radmc3d</span></code> executable (Except if you insert one yourself
using the userdef module, see Chapter <a class="reference internal" href="internalsetup.html#chap-internal-setup"><span class="std std-ref">Modifying RADMC-3D: Internal setup and user-specified radiative processes</span></a>).  For
instance, if you want to model a protoplanetary disk, then you would have to
design the grid and density structure of the disk on this grid yourself. To
make it easier for the user, we have provided several Python-scripts as
examples. Among these examples is indeed a protoplanetary disk model. So
this is as close as we go to ‘built-in’ models: we provide, for some cases,
already well-developed example models that you, the user, can use
out-of-the-box, or that you can adapt to your needs.</p>
<p>In this chapter we give an overview of the rough functionality of the code
in its simplest form: ignoring all the hidden fancy options and
possibilities. For the details we then refer to the chapters ahead.</p>
<div class="section" id="basic-dataflow">
<span id="sec-dataflow"></span><h2>Basic dataflow<a class="headerlink" href="#basic-dataflow" title="Permalink to this headline">¶</a></h2>
<p>Let us first clarify the basic philosophy of the code package (details will
be done later). When we talk about RADMC-3D we talk about the
fortran-90 program. The source codes are in the directory <code class="docutils literal notranslate"><span class="pre">src/</span></code>
and the executable is called <code class="docutils literal notranslate"><span class="pre">radmc3d</span></code>. This is the code that does
all the main calculations. You can call the code from the bash shell
(in Unix/Linux/MacOSX systems) and you can specify command-line options to
tell RADMC-3D what you want it to do.</p>
<p>The code RADMC-3D is in a way just a dumb computational engine. It has no
physical data (such as opacities or material properties) implemented, nor does
it have any model implemented. It is totally dependent on input files of various
kinds. These input files have filenames that end in <code class="docutils literal notranslate"><span class="pre">.inp</span></code>, or <code class="docutils literal notranslate"><span class="pre">.binp</span></code>,
dependent on whether the data in ASCII, or binary form. You, the user, will have
to create these input files. RADMC-3D will simply look if an <code class="docutils literal notranslate"><span class="pre">.inp</span></code>, or a
<code class="docutils literal notranslate"><span class="pre">.binp</span></code> file is present, and will switch to ASCII, dependent on which
file-extension it finds.</p>
<p>After you run RADMC-3D (by calling <code class="docutils literal notranslate"><span class="pre">radmc3d</span></code> with the appropriate command-line
options) you will see that the code will have produced one or more output files,
with filenames ending in <code class="docutils literal notranslate"><span class="pre">.out</span></code> or <code class="docutils literal notranslate"><span class="pre">.bout</span></code>. Whether RADMC-3D produces ASCII
or binary files, depends on a flag called <code class="docutils literal notranslate"><span class="pre">rto_style</span></code> that you can set (see
Chapter <a class="reference internal" href="binaryio.html#chap-binary-io"><span class="std std-ref">Binary I/O files</span></a>).</p>
<p><em>IMPORTANT NOTE: In this manual we will mostly refer to the ASCII form
of input and output files for convenience. But each time we refer to an
*.inp, *.dat or *.out file, we implicitly assume that this could also
be a *.binp, *.bdat or *.bout file.</em></p>
<p>This basic dataflow is shown in Fig. <a class="reference internal" href="#fig-dataflow-basic"><span class="std std-ref">Pictographic representation of the basic dataflow of RADMC-3D. The user
produces the input files; RADMC-3D reads them, performs the calculation,
and produces output files. The user can then analyze the output files.</span></a>.</p>
<div class="figure align-default" id="id1">
<span id="fig-dataflow-basic"></span><a class="reference internal image-reference" href="_images/dataflow-basic.svg"><img alt="_images/dataflow-basic.svg" src="_images/dataflow-basic.svg" width="50%" /></a>
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Pictographic representation of the basic dataflow of RADMC-3D. The user
produces the input files; RADMC-3D reads them, performs the calculation,
and produces output files. The user can then analyze the output files.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>Not always can RADMC-3D produce its output files in one go. Sometimes it has to
use a two-stage procedure: For dust continuum radiative transfer the dust
temperatures are computed first (stage 1), and the images and/or spectra are
rendered after that (stage 2). Between stage 1 and stage 2 an intermediate file
is then produced (with filename ending in <code class="docutils literal notranslate"><span class="pre">.dat</span></code> or <code class="docutils literal notranslate"><span class="pre">.bdat</span></code>),
which in the case of dust continuum radiative transfer is <code class="docutils literal notranslate"><span class="pre">dust_temperature.dat</span></code>
(or <code class="docutils literal notranslate"><span class="pre">*.bdat</span></code>).</p>
<p>This basic dataflow is shown in Fig. <a class="reference internal" href="#fig-dataflow-twostage"><span class="std std-ref">Pictographic representation of the dataflow of RADMC-3D for the case
of a 2-stage procedure, such as for dust continuum transfer. An intermediate
file is produced that will be used by stage 2, but of course the user can
also analyze the intermediate file itself.</span></a>.</p>
<div class="figure align-default" id="id2">
<span id="fig-dataflow-twostage"></span><a class="reference internal image-reference" href="_images/dataflow-twostage.svg"><img alt="_images/dataflow-twostage.svg" src="_images/dataflow-twostage.svg" width="85%" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Pictographic representation of the dataflow of RADMC-3D for the case
of a 2-stage procedure, such as for dust continuum transfer. An intermediate
file is produced that will be used by stage 2, but of course the user can
also analyze the intermediate file itself.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>Several of these input files contain large tables, for instance of the density
at each grid point, or the stellar flux at each wavelength bin. It is, of
course, impossible to create these datafiles by hand. The idea is that you
design a program (in any language you like) that creates these datafiles. In
that program you essentially ‘program the model’. We have provided a number of
example model setups in the <code class="docutils literal notranslate"><span class="pre">examples/</span></code> directory. For these examples models
the setup programs were written in Python (their filenames all start with
<code class="docutils literal notranslate"><span class="pre">problem_</span></code> and end with <code class="docutils literal notranslate"><span class="pre">.py</span></code>). For you as the user it is therefore the
easiest to start from one of these examples and modify the Python code to your
needs. However, if you prefer to use another language, you can use the examples
to see how the input files were generated and then program this in another
programming language.</p>
<p><em>Note: The Python files called</em> <code class="docutils literal notranslate"><span class="pre">problem_*.py</span></code> <em>are meant to be edited and
changed by you! They are templates from which you can create your own models.</em></p>
<p>For the analysis of the output files created by RADMC-3D you can use your own
favorite plotting or data-analysis software. But also here we provide some tools
in Python. These Python routines are in the <code class="docutils literal notranslate"><span class="pre">python/</span></code> directory. Typically you
will create your own program, e.g. <code class="docutils literal notranslate"><span class="pre">plot_model.py</span></code> or so, that will use
these subroutines, e.g. by putting in the first line: <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">radmc3dPy</span> <span class="pre">import</span>
<span class="pre">*</span></code>. In this way Python is used also as a post-processing tool. But again: this
can also be done in another language.</p>
<p>This procedure is shown in Fig. <a class="reference internal" href="#fig-dataflow-basic-python"><span class="std std-ref">Pictographic representation of how the Python programs in the example directories
are used to create the input files of RADMC-3D.</span></a> for the
single-stage dataflow and in Fig. <a class="reference internal" href="#fig-dataflow-twostage-python"><span class="std std-ref">Pictographic representation of the dataflow of RADMC-3D for the case
of a 2-stage procedure, such as for dust continuum transfer. An intermediate
file is produced that will be used by stage 2, but of course the user can
also analyze the intermediate file itself.</span></a> for the
two-stage dataflow.</p>
<div class="figure align-default" id="id3">
<span id="fig-dataflow-basic-python"></span><a class="reference internal image-reference" href="_images/dataflow-basic-python.svg"><img alt="_images/dataflow-basic-python.svg" src="_images/dataflow-basic-python.svg" width="50%" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Pictographic representation of how the Python programs in the example directories
are used to create the input files of RADMC-3D.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-default" id="id4">
<span id="fig-dataflow-twostage-python"></span><a class="reference internal image-reference" href="_images/dataflow-twostage-python.svg"><img alt="_images/dataflow-twostage-python.svg" src="_images/dataflow-twostage-python.svg" width="85%" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Pictographic representation of the dataflow of RADMC-3D for the case
of a 2-stage procedure, such as for dust continuum transfer. An intermediate
file is produced that will be used by stage 2, but of course the user can
also analyze the intermediate file itself.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="radiative-processes">
<span id="sec-rad-processes"></span><h2>Radiative processes<a class="headerlink" href="#radiative-processes" title="Permalink to this headline">¶</a></h2>
<p>Currently RADMC-3D handles the following radiative processes:</p>
<ul>
<li><p>Dust thermal emission and absorption</p>
<p>RADMC-3D can compute spectra and images in dust continuum. The dust
temperature must be known in addition to the dust density. In typical
applications you will know the dust density distribution, but not the dust
temperature, because the latter is the results of a balance between
radiative absorption and re-emission. So in order to make spectra and
images of a dusty object we must first calculate the dust temperature
consistently. This can be done with RADMC-3D by making it perform a
‘thermal Monte Carlo’ simulation (see Chapter <a class="reference internal" href="dustradtrans.html#chap-dust-transfer"><span class="std std-ref">Dust continuum radiative transfer</span></a>).
This can be a time-consuming computation. But once this is done, RADMC-3D
writes the resulting dust temperatures out to the file
<code class="docutils literal notranslate"><span class="pre">dust_temperature.dat</span></code>, which it can then later use for images and
spectra. We can then call RADMC-3D again with the command to make an image
or a spectrum (see Chapter <a class="reference internal" href="dustradtrans.html#chap-dust-transfer"><span class="std std-ref">Dust continuum radiative transfer</span></a>). To summarize: a
typical dust continuum radiative transfer calculation goes in two stages:</p>
<ol class="arabic simple">
<li><p>A thermal Monte Carlo simulation with RADMC-3D to compute the dust
temperatures.</p></li>
<li><p>A spectrum or image computation using ray-tracing with RADMC-3D.</p></li>
</ol>
</li>
<li><p>Dust scattering</p>
<p>Dust scattering is automatically included in the thermal Monte Carlo
simulations described above, as well as in the production of images and
spectra. For more details, consult Chapter <a class="reference internal" href="dustradtrans.html#chap-dust-transfer"><span class="std std-ref">Dust continuum radiative transfer</span></a>.</p>
</li>
<li><p>Gas atomic/molecular lines</p>
<p>RADMC-3D can compute spectra and images in gas lines (see Chapter
<a class="reference internal" href="lineradtrans.html#chap-line-transfer"><span class="std std-ref">Line radiative transfer</span></a>). The images are also known as <em>channel maps</em>. To
compute these, RADMC-3D must know the population densities of the various
atomic/molecular levels. For now there are the following options how to let
RADMC-3D know these values:</p>
<ul class="simple">
<li><p>Tell RADMC-3D to assume that the molecules or atoms are in <em>Local
Thermodynamic Equilibrium</em> (LTE), and specify the gas temperature at
each location to allow RADMC-3D to compute these LTE level populations.
<em>Note that in principle one is now faced with the same problem as
with the dust continuum: we need to know the gas temperature, which we
typically do not know in advance.</em> However, computing the gas
temperature self-consistently is very difficult, because it involves
many heating and cooling processes, some of which are very complex.
That is why most line radiative transfer codes assume that the user gives
the gas temperature as input. We do so as well. If you like, you can
tell RADMC-3D to use the (previously calculated) dust temperature as the
gas temperature, for convenience.</p></li>
<li><p>Deliver RADMC-3D an input file with all the level populations
that you have calculated youself using some method.</p></li>
<li><p>Tell RADMC-3D to compute the level populations according to some
simple local non-LTE prescription such as the Sobolev approximation
(<em>Large Velocity Gradient method</em>) or the Escape Probability Method.</p></li>
</ul>
<p>Currently RADMC-3D does not have a full non-local non-LTE computation
method implemented. The reason is that it is very costly, and for many
applications presumably not worth the computational effort.</p>
</li>
</ul>
</div>
<div class="section" id="coordinate-systems">
<span id="sec-coord-systems"></span><h2>Coordinate systems<a class="headerlink" href="#coordinate-systems" title="Permalink to this headline">¶</a></h2>
<p>With RADMC-3D you can specify your density distribution in two coordinate
systems:</p>
<ul>
<li><p>Cartesian coordinates: 3-D</p>
<p>The simplest coordinate system is the Cartesian coordinate system
<span class="math notranslate nohighlight">\((x,y,z)\)</span>. For now each model must be 3-D (i.e. you must specify the
densities and other quantities as a function of <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span>).</p>
</li>
<li><p>Cartesian coordinates: 1-D plane-parallel</p>
<p>This is like the normal cartesian coordinates, but now the <span class="math notranslate nohighlight">\(x\)</span>- and <span class="math notranslate nohighlight">\(y\)</span>-
directions are infinitely extended. Only the <span class="math notranslate nohighlight">\(z\)</span>-direction has
finite-size cells, and hence the grid is only in <span class="math notranslate nohighlight">\(z\)</span>-direction.  This mode
is the usual plane-parallel mode of radiative transfer. See Section
<a class="reference internal" href="gridding.html#sec-1d-plane-parallel"><span class="std std-ref">1-D Plane-parallel models</span></a> for more details on this mode.</p>
</li>
<li><p>Cartesian coordinates: 2-D pencil-parallel</p>
<p>This is the intermediate between full 3-D cartesian and 1-D
plane-parallel.  In this mode only the <span class="math notranslate nohighlight">\(x\)</span>-direction is infinitely
extended and a finite grid is in both <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> directions. This mode is
only useful in very special cases, and is much less familiar to most - so
use only when you are confident.</p>
</li>
<li><p>Spherical coordinates</p>
<p>You can also specify your model in spherical coordinates
<span class="math notranslate nohighlight">\((r,\theta,\phi)\)</span>. These coordinates are related to the cartesian
ones by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
x &amp;= r \sin\theta \cos\phi \\
y &amp;= r \sin\theta \sin\phi \\
z &amp;= r \cos\theta
\end{split}\end{split}\]</div>
<p>This means that the spatial variables (density, temperature etc) are all
specified as a function of <span class="math notranslate nohighlight">\((r,\theta,\phi)\)</span>. However, the location of the
stars, the motion and direction of photon packages etc. are still given in
cartesian coordinates <span class="math notranslate nohighlight">\((x,y,z)\)</span>. In other words: any function of space
<span class="math notranslate nohighlight">\(f(\vec x)\)</span> will be in spherical coordinates <span class="math notranslate nohighlight">\(f(r,\theta,\phi)\)</span>, but any
point-like specification of position <span class="math notranslate nohighlight">\(\vec x\)</span> will be given as Cartesian
coordinates <span class="math notranslate nohighlight">\(\vec x=(x,y,z)\)</span>. This hybrid method allows us to do all
physics in cartesian coordinates: photon packages or rays are treated
always in cartesian coordinates, and so is the physics of scattering, line
emission etc.  Only if RADMC-3D needs to know what the local conditions
are (dust temperature, gas microturbulence, etc) RADMC-3D looks up which
coordinates <span class="math notranslate nohighlight">\((r,\theta,\phi)\)</span> belong to the current <span class="math notranslate nohighlight">\((x,y,z)\)</span> and looks up
the value of the density, microturbulence etc.at that location in the
<span class="math notranslate nohighlight">\((r,\theta,\phi)\)</span> grid. And the same is true if RADMC-3D updates or
calculates for instance the dust temperature: it will compute the
<span class="math notranslate nohighlight">\((r,\theta,\phi)\)</span> belong to the current <span class="math notranslate nohighlight">\((x,y,z)\)</span> and update the
temperature in the cell belonging to <span class="math notranslate nohighlight">\((r,\theta,\phi)\)</span>. For the rest, all
the physics is done in the Cartesian coordinate system. This has the major
advantage that we do not need different physics modules for cartesian and
spherical coordinates. Most parts of the code don’t care which coordinate
system is used: they will do their own work in Cartesian coordinates.
When using spherical coordinates, please read Section
<a class="reference internal" href="gridding.html#sec-separable-refinement"><span class="std std-ref">Separable grid refinement in spherical coordinates (important!)</span></a>.</p>
</li>
</ul>
</div>
<div class="section" id="the-spatial-grid">
<span id="sec-spatial-grid"></span><h2>The spatial grid<a class="headerlink" href="#the-spatial-grid" title="Permalink to this headline">¶</a></h2>
<p>To specify the density or temperature structure (or any other spatial
variable) as a function of spatial location we must have a grid. There
are two basic types of grids:</p>
<p>The standard gridding is a simple rectangular grid.</p>
<ul>
<li><p>Cartesian coordinates</p>
<p>When cartesian coordinates are used, this simply means that each cell is
defined as <span class="math notranslate nohighlight">\(x_l&lt;x&lt;x_r\)</span>, <span class="math notranslate nohighlight">\(y_l&lt;y&lt;y_r\)</span> and <span class="math notranslate nohighlight">\(z_l&lt;z&lt;z_r\)</span>, where
<span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(r\)</span> stand for the left and right cell walls respectively.</p>
</li>
<li><p>Spherical coordinates</p>
<p>When spherical coordinates are used, this simply means that each cell is
defined as <span class="math notranslate nohighlight">\(r_l&lt;r&lt;r_r\)</span>, <span class="math notranslate nohighlight">\(\theta_l&lt;\theta&lt;\theta_r\)</span> and
<span class="math notranslate nohighlight">\(\phi_l&lt;\phi&lt;\phi_r\)</span>.  Note therefore that the shape of the cells in
spherical coordinates is (in real space) curved. For spherical coordinates the
following four modes are available:</p>
<ul>
<li><p>1-D Spherical symmetry:</p>
<p>All spatial functions depend only on <span class="math notranslate nohighlight">\(r\)</span>.</p>
</li>
<li><p>2-D Axial symmetry:</p>
<p>All spatial functions depend only on <span class="math notranslate nohighlight">\(r\)</span> and <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
</li>
<li><p>2-D Axial symmetry with mirror symmetry:</p>
<p>All spatial functions depend only on <span class="math notranslate nohighlight">\(r\)</span> and <span class="math notranslate nohighlight">\(\theta\)</span>, where the
<span class="math notranslate nohighlight">\(\theta\)</span> grid only covers the part above the <span class="math notranslate nohighlight">\(z=0\)</span>
plane. Internally it is in this mode assumed that all quantities below the
<span class="math notranslate nohighlight">\(z=0\)</span> plane are equal to those above the plane by mirror symmetry in
the <span class="math notranslate nohighlight">\(z=0\)</span> plane.  This saves a factor of two in computational effort
for Monte Carlo calculations, as well as in memory useage. Note that also
the resulting output files such as <code class="docutils literal notranslate"><span class="pre">dust_temperature.dat</span></code> will only be
specified for <span class="math notranslate nohighlight">\(z&gt;0\)</span>.</p>
</li>
<li><p>3-D:</p>
<p>All spatial functions depend on all three variables
<span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span>.</p>
</li>
<li><p>3-D with mirror symmetry:</p>
<p>All spatial functions depend on all three variables <span class="math notranslate nohighlight">\(r\)</span>,
<span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span>, but like in the 2-D case only the upper
part of the model needs to be specified: the lower part is assumed to be a
mirror copy.</p>
</li>
</ul>
<p>When using spherical coordinates, please read Section
<a class="reference internal" href="gridding.html#sec-separable-refinement"><span class="std std-ref">Separable grid refinement in spherical coordinates (important!)</span></a>.</p>
</li>
</ul>
<p>In all cases these structured grids allow for oct-tree-style grid refinement, or
its simplified version: the layer-style grid refinement. See Section
<a class="reference internal" href="inputoutputfiles.html#sec-grid-input"><span class="std std-ref">INPUT (required): amr_grid.inp</span></a> and Chapter <a class="reference internal" href="gridding.html#chap-gridding"><span class="std std-ref">More information about the gridding</span></a> for more information
about the gridding and the (adaptive) mesh refinement (AMR).</p>
</div>
<div class="section" id="computations-that-radmc-3d-can-perform">
<span id="sec-actions"></span><h2>Computations that RADMC-3D can perform<a class="headerlink" href="#computations-that-radmc-3d-can-perform" title="Permalink to this headline">¶</a></h2>
<p>The code RADMC-3D (i.e. the executable <code class="docutils literal notranslate"><span class="pre">radmc3d</span></code>) is <em>one</em> code for <em>many</em>
actions. Depending on which command-line arguments you give, RADMC-3D can do
various actions. Here is a list:</p>
<ol class="arabic">
<li><p>Compute the dust temperature:</p>
<p>With <code class="docutils literal notranslate"><span class="pre">radmc3d</span> <span class="pre">mctherm</span></code> you call RADMC-3D with the command of performing a
thermal Monte Carlo simulation to compute the dust temperature under the
assumption that the dust is in radiative equilibrium with its radiation
field. This is normally a prerequisite for computing SEDs and images from
dusty objects (see <em>computing spectra and images</em> below).  The output file of
this computation is <code class="docutils literal notranslate"><span class="pre">dust_temperature.dat</span></code> which contains the dust
temperature everywhere in the model.</p>
</li>
<li><p>Compute a spectrum or SED:</p>
<p>With <code class="docutils literal notranslate"><span class="pre">radmc3d</span> <span class="pre">sed</span></code> you call RADMC-3D with the command of performing a
ray-tracing computation to compute the spectral energy distribution (SED) for
the model at hand. Typically you first need to have called <code class="docutils literal notranslate"><span class="pre">radmc3d</span>
<span class="pre">mctherm</span></code> (see above) beforehand to compute dust temperatures (unless you
have created the file <code class="docutils literal notranslate"><span class="pre">dust_temperature.dat</span></code> yourself because you have a
special way of computing the dust temperature). With <code class="docutils literal notranslate"><span class="pre">radmc3d</span> <span class="pre">sed</span></code> the
spectrum is computed for the wavelengths points given in the file
<code class="docutils literal notranslate"><span class="pre">wavelength_micron.inp</span></code>, which is the same wavelength grid that is used for
<code class="docutils literal notranslate"><span class="pre">radmc3d</span> <span class="pre">mctherm</span></code>. If you want to compute the spectrum at wavelength other
than those used for the thermal Monte Carlo simulation, you should instead
call <code class="docutils literal notranslate"><span class="pre">radmc3d</span> <span class="pre">spectrum</span></code>, and you have the full freedom to choose the
spectral wavelengths points at will, and you can specify these in various
ways described in Section <a class="reference internal" href="imagesspectra.html#sec-set-camera-frequencies"><span class="std std-ref">Specifying custom-made sets of wavelength points for the camera</span></a>.  Most easily you
can create a file called <code class="docutils literal notranslate"><span class="pre">camera_wavelength_micron.inp</span></code> (see Section
<a class="reference internal" href="inputoutputfiles.html#sec-camera-wavelengths"><span class="std std-ref">INPUT (optional): camera_wavelength_micron.inp</span></a>) and call RADMC-3D using <code class="docutils literal notranslate"><span class="pre">radmc3d</span> <span class="pre">spectrum</span>
<span class="pre">loadlambda</span></code>. In all these cases the vantage point (where is the observer)
can of course be set as well, see Section <a class="reference internal" href="dustradtrans.html#sec-dust-ray-tracing"><span class="std std-ref">Making SEDs, spectra, images for dust continuum</span></a> and
Chapter <a class="reference internal" href="imagesspectra.html#chap-images-spectra"><span class="std std-ref">Making images and spectra</span></a>.</p>
</li>
<li><p>Compute an image:</p>
<p>With <code class="docutils literal notranslate"><span class="pre">radmc3d</span> <span class="pre">image</span></code> you call RADMC-3D with the command of performing a
ray-tracing computation to compute an image. You must specify the
wavelength(s) at which you want the image by, for instance, calling RADMC-3D
as <code class="docutils literal notranslate"><span class="pre">radmc3d</span> <span class="pre">image</span> <span class="pre">lambda</span> <span class="pre">10</span></code>, which makes the image at
<span class="math notranslate nohighlight">\(\lambda=10\mu\mathrm{m}\)</span>. But there are other ways by which the wavelength(s) can be set, see
Section <a class="reference internal" href="imagesspectra.html#sec-set-camera-frequencies"><span class="std std-ref">Specifying custom-made sets of wavelength points for the camera</span></a>.  In all these cases the vantage
point (where is the observer) can of course be set as well, see Section
<a class="reference internal" href="dustradtrans.html#sec-dust-ray-tracing"><span class="std std-ref">Making SEDs, spectra, images for dust continuum</span></a> and Chapter <a class="reference internal" href="imagesspectra.html#chap-images-spectra"><span class="std std-ref">Making images and spectra</span></a>.</p>
</li>
<li><p>Compute the local radiation field inside the model:</p>
<p>With <code class="docutils literal notranslate"><span class="pre">radmc3d</span> <span class="pre">mcmono</span></code> you call RADMC-3D with the command of performing a
wavelength-by-wavlength monochromatic Monte Carlo simulation (at the
wavelengths that you specify in the file
<code class="docutils literal notranslate"><span class="pre">mcmono_wavelength_micron.inp</span></code>). The output file of this computation is
<code class="docutils literal notranslate"><span class="pre">mean_intensity.out</span></code> which contains the mean intensity <span class="math notranslate nohighlight">\(J_\nu\)</span> as a
function of the <span class="math notranslate nohighlight">\((x,y,z)\)</span> (cartesian) or <span class="math notranslate nohighlight">\((r,\theta,\phi)\)</span>
(spherical) coordinates at the frequencies <span class="math notranslate nohighlight">\(\nu_i\equiv
10^4c/\lambda_i\)</span> where <span class="math notranslate nohighlight">\(\lambda_i\)</span> are the wavelengths (in
<span class="math notranslate nohighlight">\(\mu\)</span>m) specified in the file <code class="docutils literal notranslate"><span class="pre">mcmono_wavelength_micron.inp</span></code>. The
results of this computation can be interesting for, for instance, models of
photochemistry. But if you use RADMC-3D only for computing spectra and
images, then you will not use this.</p>
</li>
</ol>
<p>In addition to the above main methods, you can ask RADMC-3D to do various minor
things as well, which will be described throughout this manual.</p>
</div>
<div class="section" id="how-a-model-is-set-up-and-computed-a-rough-overview">
<h2>How a model is set up and computed: a rough overview<a class="headerlink" href="#how-a-model-is-set-up-and-computed-a-rough-overview" title="Permalink to this headline">¶</a></h2>
<p>A radiative transfer code such as RADMC-3D has the task of computing synthetic
images and spectra of a model that you specify. You tell the code what the dust
and/or gas density distribution in 3-D space is and where the star(s) are, and
the code will then tell you what your cloud looks like in images and/or
spectra. That’s basically it. That’s the main task of RADMC-3D.</p>
<p>First you have to tell RADMC-3D what 3-D distribution of dust and/or gas you
want it to model. For that you must specify a coordinate system (cartesian or
spherical) and a spatial grid. For cartesian coordinates this grid should be 3-D
(although there are exceptions to this), while for spherical coordinates it can
be 1-D (spherical symmetry), 2-D (axial symmetry) or 3-D (no symmetry). RADMC-3D
is (for most part) a cell-based code, i.e. your grid devides space in cells and
you have to tell RADMC-3D what the average densities of dust and/or gas are in
these cells.</p>
<p>The structure of the grid is specified in a file <code class="docutils literal notranslate"><span class="pre">amr_grid.inp</span></code> (see Section
<a class="reference internal" href="inputoutputfiles.html#sec-grid-input"><span class="std std-ref">INPUT (required): amr_grid.inp</span></a>). All the other data, such as dust density and/or gas
density are specified in other files, but all assume that the grid is given by
<code class="docutils literal notranslate"><span class="pre">amr_grid.inp</span></code>.</p>
<p>We can also specify the locations and properties of one or more stars in the
model. This is done in the <code class="docutils literal notranslate"><span class="pre">stars.inp</span></code> (see Section <a class="reference internal" href="inputoutputfiles.html#sec-stars"><span class="std std-ref">INPUT (mostly required): stars.inp</span></a>) file.</p>
<p>Now suppose we want to compute the appearance of our model in dust continuum. We
will describe this in detail in Chapter <a class="reference internal" href="dustradtrans.html#chap-dust-transfer"><span class="std std-ref">Dust continuum radiative transfer</span></a>, but let us
give a very rough idea here. We write, in addition to the <code class="docutils literal notranslate"><span class="pre">amr_grid.inp</span></code> and
<code class="docutils literal notranslate"><span class="pre">stars.inp</span></code> files, a file <code class="docutils literal notranslate"><span class="pre">dust_density.inp</span></code> which specifies the density of
dust in each cell (see Section <a class="reference internal" href="inputoutputfiles.html#sec-dustdens"><span class="std std-ref">INPUT (required for dust transfer): dust_density.inp</span></a>).  We also must write the
main input file <code class="docutils literal notranslate"><span class="pre">radmc3d.inp</span></code> (see Section <a class="reference internal" href="inputoutputfiles.html#sec-radmc-inp"><span class="std std-ref">INPUT: radmc3d.inp</span></a>), but we can
leave it empty for now. We must give RADMC-3D a dust opacity table in the files
<code class="docutils literal notranslate"><span class="pre">dustopac.inp</span></code> and for instance <code class="docutils literal notranslate"><span class="pre">dustkappa_silicate.inp</span></code> (see Section
<a class="reference internal" href="inputoutputfiles.html#sec-opacities"><span class="std std-ref">INPUT (required for dust transfer): dustopac.inp and dustkappa_*.inp or dustkapscatmat_*.inp or dust_optnk_*.inp</span></a>). And finally, we have to give RADMC-3D a table of discrete
wavelengths in the file <code class="docutils literal notranslate"><span class="pre">wavelength_micron.inp</span></code> that it will use to perform
its calculations on. We then call the <code class="docutils literal notranslate"><span class="pre">radmc3d</span></code> code with the keyword
<code class="docutils literal notranslate"><span class="pre">mctherm</span></code> (see Chapter <a class="reference internal" href="dustradtrans.html#chap-dust-transfer"><span class="std std-ref">Dust continuum radiative transfer</span></a>) to tell it to perform a
Monte Carlo simulation to compute dust temperatures everywhere. RADMC-3D will
write this to the file <code class="docutils literal notranslate"><span class="pre">dust_temperature.dat</span></code>. If we now want to make a
spectral energy distribution, for instance, we call <code class="docutils literal notranslate"><span class="pre">radmc3d</span> <span class="pre">sed</span></code> (see Section
<a class="reference internal" href="imagesspectra.html#sec-making-spectra"><span class="std std-ref">Making spectra</span></a>) and it will write a file called <code class="docutils literal notranslate"><span class="pre">spectrum.out</span></code>
which is a list of fluxes at the discrete wavelengths we specified in
<code class="docutils literal notranslate"><span class="pre">wavelength_micron.inp</span></code>.  Then we are done: we have computed the spectral
energy distribution of our model. We could also make an image at wavelength 10
<span class="math notranslate nohighlight">\(\mu\)</span>m for instance with <code class="docutils literal notranslate"><span class="pre">radmc3d</span> <span class="pre">image</span> <span class="pre">lambda</span> <span class="pre">10</span></code> (see Section
<a class="reference internal" href="imagesspectra.html#sec-images"><span class="std std-ref">Basics of image making with RADMC-3D</span></a>). This will write out a file <code class="docutils literal notranslate"><span class="pre">image.out</span></code> containing the
image data (see Section <a class="reference internal" href="inputoutputfiles.html#sec-image-out"><span class="std std-ref">OUTPUT: image.out or image_****.out</span></a>).</p>
<p>As you see, RADMC-3D reads all its information from tables in various
files. Since you don’t want to make large tables by hand, you will have to write
a little computer program that generates these tables automatically.  You can do
this in any programming language you want. But in the example models (see
Section <a class="reference internal" href="#sec-example-models"><span class="std std-ref">Running the example models</span></a>) we use the programming language Python (see
Section <a class="reference internal" href="overview.html#sec-requirements"><span class="std std-ref">Requirements</span></a>) for this. It is easiest to indeed have a look
at the example models to see how this is (or better: can be) done.</p>
<p>We will explain all these things in much more detail below, and we will discuss
also many other radiative transfer problem types. The above example is really
just meant to give an impression of how RADMC-3D works.</p>
</div>
<div class="section" id="organization-of-model-directories">
<span id="sec-rough-overview-models"></span><h2>Organization of model directories<a class="headerlink" href="#organization-of-model-directories" title="Permalink to this headline">¶</a></h2>
<p>The general philosophy of the RADMC-3D code package is the following. The core
of everything is the fortran code <code class="docutils literal notranslate"><span class="pre">radmc3d</span></code>. This is the main code which does
the hard work for you: it makes the radiative transfer calculations, makes
images, makes spectra etc. Normally you compile this code just once-and-for-all
(see Chapter <a class="reference internal" href="installation.html#chap-compilation"><span class="std std-ref">Installation of RADMC-3D</span></a>), and then simply use the executable
<code class="docutils literal notranslate"><span class="pre">radmc3d</span></code> for all models. There is an exception to this ‘once-and-for-all’
rule described in Section <a class="reference internal" href="installation.html#sec-special-purpose-compile"><span class="std std-ref">Making special-purpose modified versions of RADMC-3D (optional)</span></a>, but in the present
chapter we will not use this (see Chapter <a class="reference internal" href="internalsetup.html#chap-internal-setup"><span class="std std-ref">Modifying RADMC-3D: Internal setup and user-specified radiative processes</span></a> for this
instead). So we will stick here to the philosophy of compiling this code once
and using it for all models.</p>
<p>So how to set up a model? The trick is to present <code class="docutils literal notranslate"><span class="pre">radmc3d</span></code> with a set of
input files in which the model is described in all its details. The procedure to
follow is this:</p>
<ol class="arabic simple">
<li><p>The best thing to do (to avoid a mess) is to make a directory for
<em>each model</em>: one model, one directory. Since <code class="docutils literal notranslate"><span class="pre">radmc3d</span></code> reads
multiple input files, and also outputs a number of files, this is a good
way to keep organized and we recommend it strongly.  So if we wish to make
a new model, we make a new directory, or copy an old directory to a new
name (if we merely want to make small changes to a prior model).</p></li>
<li><p>In this directory we generate the input files according to their required
format (see Chapter <a class="reference internal" href="inputoutputfiles.html#chap-input-files"><span class="std std-ref">Main input and output files of RADMC-3D</span></a>). You can create these input files
in any way you want. But since many of these input files will/must contain
huge lists of numbers (for instance, giving the density at each location in
your model), you will typically want to write some script or program in some
language (be it either C, C++, Fortran, IDL, GDL, perl, python, you name it)
that automatically creates these input files. <em>We recommend using Python,
because we provide examples and standard subroutines in the programming
language Python; see below for more details.</em>  Section
<a class="reference internal" href="#sec-example-models"><span class="std std-ref">Running the example models</span></a> describes how to use the example Python scripts to
make these input files with Python.</p></li>
<li><p>When all the input files are created, and we make sure that we are inside the
model directory, we call <code class="docutils literal notranslate"><span class="pre">radmc3d</span></code> with the desired command-line options
(see Chapter <a class="reference internal" href="clioptions.html#chap-command-line-options"><span class="std std-ref">Command-line options</span></a>). This will do the work for us.</p></li>
<li><p>Once this is done, we can analyze the results by reading the output files
(see Chapter <a class="reference internal" href="inputoutputfiles.html#chap-input-files"><span class="std std-ref">Main input and output files of RADMC-3D</span></a>). To help you reading and analyzing
these output files you can use a set of Python routines that we created for
the user (see Chapter <a class="reference internal" href="pythontools.html#chap-python-analysis-tools"><span class="std std-ref">Python analysis tool set</span></a> and Section
<a class="reference internal" href="installation.html#sec-install-pythonscripts"><span class="std std-ref">Installing the simple Python analysis tools</span></a>). But here again, you are free to use any
other plotting software and/or data postprocessing packages.</p></li>
</ol>
</div>
<div class="section" id="running-the-example-models">
<span id="sec-example-models"></span><h2>Running the example models<a class="headerlink" href="#running-the-example-models" title="Permalink to this headline">¶</a></h2>
<p>Often the fastest and easiest way to learn a code is simply to analyze and run a
set of example models. They are listed in the <code class="docutils literal notranslate"><span class="pre">examples</span></code> directory. Each model
occupies a separate directory. This is also the style we normally recommend:
each model should have its own directory. Of course there are also exceptions to
this rule, and the user is free to organize her/his data in any way he/she
pleases. But in all the examples and throughout this manual each model has its
own directory.</p>
<p>To run an example model, go into the directory of this model, and follow the
directions that are written in the <code class="docutils literal notranslate"><span class="pre">README</span></code> file in each of these
directories. <em>This is under the assumption that you have a full Python
distribution installed on your system, including Numpy and Matplotlib.</em></p>
<p>Let us do for instance <code class="docutils literal notranslate"><span class="pre">run_simple_1/</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">examples</span><span class="o">/</span><span class="n">run_simple_1</span>
</pre></div>
</div>
<p>Now we must create all the input files for this model. These input files are
all described in chapter <a class="reference internal" href="inputoutputfiles.html#chap-input-files"><span class="std std-ref">Main input and output files of RADMC-3D</span></a>, but let us here just
‘blindly’ follow the example. In this example most (all except one) of the
input files are created using a Python script called <code class="docutils literal notranslate"><span class="pre">problem_setup.py</span></code>.
To execute this script, this is what you do on the shell:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">problem_setup</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>This Python script has now created a whole series
of input files, all ending with the extension <code class="docutils literal notranslate"><span class="pre">.inp</span></code>. To see which
files are created, type the following in the shell:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ls</span> <span class="o">-</span><span class="n">l</span> <span class="o">*.</span><span class="n">inp</span>
</pre></div>
</div>
<p>There is one file that this example does not create, and that is the file
<code class="docutils literal notranslate"><span class="pre">dustkappa_silicate.inp</span></code>. This is a file that contains the dust opacity in
tabulated form. This is a file that you as the user should provide to the
RADMC-3D code package. The file <code class="docutils literal notranslate"><span class="pre">dustkappa_silicate.inp</span></code> is merely an example,
which is an amorphous spherical silicate grain with radius 0.1 micron. But see
Section <a class="reference internal" href="inputoutputfiles.html#sec-opacities"><span class="std std-ref">INPUT (required for dust transfer): dustopac.inp and dustkappa_*.inp or dustkapscatmat_*.inp or dust_optnk_*.inp</span></a> for more information about the opacities.</p>
<p>Now that the input files are created, we must run <code class="docutils literal notranslate"><span class="pre">radmc3d</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">radmc3d</span> <span class="n">mctherm</span>
</pre></div>
</div>
<p>This tells RADMC-3D to do the thermal Monte Carlo simulation. This may
take some time. When the model is ready, the prompt of the shell returns.
To see what files have been created by this run of the code, type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ls</span> <span class="o">-</span><span class="n">l</span> <span class="o">*.</span><span class="n">dat</span>
</pre></div>
</div>
<p>You will find the <code class="docutils literal notranslate"><span class="pre">dust_temperature.dat</span></code> containing the dust temperature
everywhere in the model. See again chapter <a class="reference internal" href="inputoutputfiles.html#chap-input-files"><span class="std std-ref">Main input and output files of RADMC-3D</span></a> for
details of these files. To create a spectral energy distribution (SED):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">radmc3d</span> <span class="n">sed</span> <span class="n">incl</span> <span class="mf">45.</span>
</pre></div>
</div>
<p>This will create a file <code class="docutils literal notranslate"><span class="pre">spectrum.out</span></code>.  To analyze these data you can use the
Python routines delivered with the code (see Chapter
<a class="reference internal" href="pythontools.html#chap-python-analysis-tools"><span class="std std-ref">Python analysis tool set</span></a> and Section <a class="reference internal" href="installation.html#sec-install-pythonscripts"><span class="std std-ref">Installing the simple Python analysis tools</span></a>).</p>
<p>There is a file <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> in the directory. This is here only meant to make
it easy to clean the directory. Type <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">cleanmodel</span></code> to clean all the output
from the radmc3d code. Type <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">cleanall</span></code> to clean the directory back to
basics.</p>
<p>Let us now do for instance model <code class="docutils literal notranslate"><span class="pre">run_simple_1_userdef/</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">examples</span><span class="o">/</span><span class="n">run_simple_1_userdef</span>
</pre></div>
</div>
<p>This is the same model as above, but now the grid and the dust density are set
up <em>inside</em> <code class="docutils literal notranslate"><span class="pre">radmc3d</span></code>, using the file <code class="docutils literal notranslate"><span class="pre">userdef_module.f90</span></code> which is
present in this directory.  See Chapter <a class="reference internal" href="internalsetup.html#chap-internal-setup"><span class="std std-ref">Modifying RADMC-3D: Internal setup and user-specified radiative processes</span></a> for details
and follow the directions in the <code class="docutils literal notranslate"><span class="pre">README</span></code> file. In short: first edit the
variable <code class="docutils literal notranslate"><span class="pre">SRC</span></code> in the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> to point to the <code class="docutils literal notranslate"><span class="pre">src/</span></code> directory. Then
type <code class="docutils literal notranslate"><span class="pre">make</span></code>. Then type <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">problem_setup.py</span></code> on the shell command line
(which now only sets up the frequency grid, the star and the <code class="docutils literal notranslate"><span class="pre">radmc3d.inp</span></code>
file and some small stuff). Now you can run the model.</p>
<p><em>Please read the README file in each of the example model directories.
Everything is explained there, including how to make the relevant plots.</em></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dustradtrans.html" class="btn btn-neutral float-right" title="Dust continuum radiative transfer" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation of RADMC-3D" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Cornelis Dullemond

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>