%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}
\sphinxsetup{VerbatimColor={rgb}{0.95,0.95,0.95}}
\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{radmc3d}
\date{Nov 23, 2023}
\release{2.0}
\author{Cornelis Dullemond}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction::doc}}

\section{What is RADMC\sphinxhyphen{}3D?}
\label{\detokenize{introduction:what-is-radmc-3d}}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D is a software package for astrophysical radiative transfer calculations
in arbitrary 1\sphinxhyphen{}D, 2\sphinxhyphen{}D or 3\sphinxhyphen{}D geometries. It is mainly written for continuum
radiative transfer in dusty media, but also includes modules for gas line
transfer. Typical applications would be protoplanetary disks, pre\sphinxhyphen{} and
proto\sphinxhyphen{}stellar molecular cloud cores, and similar objects. It does not treat
photoionization of gas, nor does it treat chemistry. It can self\sphinxhyphen{}consistently
compute dust temperatures for the radiative transfer, but it is not equipped for
self\sphinxhyphen{}consistent gas temperature computations (as this requires detailed coupling
to photochemistry). The main strength of RADMC\sphinxhyphen{}3D lies in the flexibility of the
spatial setup of the models: One can create or use parameterized dust and/or gas
density distributions, or one can import these from snapshots of hydrodynamic
simulations.


\section{Capabilities}
\label{\detokenize{introduction:capabilities}}
\sphinxAtStartPar
Here is a list of current and planned features. Those features that are now
already working are marked with {[}+{]}, while those which are not yet (!!) built in
are marked with {[}\sphinxhyphen{}{]}. Those that are currently being developed are marked with
{[}.{]} and those that are ready, but are still in the testing phase are marked with
{[}t{]}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Coordinate systems:

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
{[}+{]} Cartesian coordinates (3\sphinxhyphen{}D)

\item {} 
\sphinxAtStartPar
{[}+{]} Spherical coordinates (1\sphinxhyphen{}D, 2\sphinxhyphen{}D and 3\sphinxhyphen{}D)

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Gridding systems (regular and adaptive mesh refinement grids are
available for cartesian \sphinxstyleemphasis{and} spherical coordinates):

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
{[}+{]} Regular

\item {} 
\sphinxAtStartPar
{[}+{]} Adaptive Mesh Refinement: oct\sphinxhyphen{}tree style

\item {} 
\sphinxAtStartPar
{[}+{]} Adaptive Mesh Refinement: layered (‘patch’) style

\item {} 
\sphinxAtStartPar
{[}\sphinxhyphen{}{]} Voronoi gridding \sphinxstyleemphasis{{[}To be implemented on request{]}}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Radiation mechanisms:
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
{[}+{]} Dust continuum, thermal emission

\item {} 
\sphinxAtStartPar
{[}+{]} Dust continuum scattering:

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
{[}+{]} …in isotropic approximation

\item {} 
\sphinxAtStartPar
{[}+{]} …with full anisotropy

\item {} 
\sphinxAtStartPar
{[}+{]} …with full Stokes and Polarization

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
{[}\sphinxhyphen{}{]} Dust quantum heated grains \sphinxstyleemphasis{{[}To be implemented on request{]}}

\item {} 
\sphinxAtStartPar
{[}t{]} Polarized dust emission by aligned grains \sphinxstyleemphasis{{[}first test version{]}}

\item {} 
\sphinxAtStartPar
{[}+{]} Gas line transfer (LTE)

\item {} 
\sphinxAtStartPar
{[}+{]} Gas line transfer (non\sphinxhyphen{}LTE: LVG)

\item {} 
\sphinxAtStartPar
{[}+{]} Gas line transfer (non\sphinxhyphen{}LTE: LVG + Escape Probability)

\item {} 
\sphinxAtStartPar
{[}\sphinxhyphen{}{]} Gas line transfer (non\sphinxhyphen{}LTE: full transfer)

\item {} 
\sphinxAtStartPar
{[}+{]} Gas line transfer with user\sphinxhyphen{}defined populations

\item {} 
\sphinxAtStartPar
{[}+{]} Gas continuum opacity and emissivity sources

\end{enumerate}
\end{quote}

\item {} 
\sphinxAtStartPar
Radiation netto sources for continuum:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
{[}+{]} Discrete stars positioned at will

\item {} 
\sphinxAtStartPar
{[}t{]} Continuous ‘starlike’ source

\item {} 
\sphinxAtStartPar
{[}t{]} Continuous ‘dissipation’ source

\item {} 
\sphinxAtStartPar
{[}t{]} External ‘interstellar radiation field’

\end{enumerate}

\item {} 
\sphinxAtStartPar
Imaging options:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
{[}+{]} Observer from ‘infinite’ distance

\item {} 
\sphinxAtStartPar
{[}+{]} Zoom\sphinxhyphen{}in at will

\item {} 
\sphinxAtStartPar
{[}+{]} Flux\sphinxhyphen{}conserving imaging, i.e. pixels are recursively refined

\item {} 
\sphinxAtStartPar
{[}+{]} A movie\sphinxhyphen{}making tool

\item {} 
\sphinxAtStartPar
{[}+{]} Multiple wavelengths in a single image

\item {} 
\sphinxAtStartPar
{[}+{]} Local observer with perspective view (for PR movies!)

\end{enumerate}

\item {} 
\sphinxAtStartPar
Spectrum options:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
{[}+{]} SED spectrum (spectrum on ‘standard’ wavelength grid)

\item {} 
\sphinxAtStartPar
{[}+{]} Spectrum on any user\sphinxhyphen{}specified wavelength grid

\item {} 
\sphinxAtStartPar
{[}+{]} Spectrum of user\sphinxhyphen{}specified sub\sphinxhyphen{}region (pointing)

\item {} 
\sphinxAtStartPar
{[}t{]} Specification of size and shape of a primary ‘beam’ for spectra

\end{enumerate}

\item {} 
\sphinxAtStartPar
User flexibility:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
{[}+{]} Free model specification via tabulated input files

\item {} 
\sphinxAtStartPar
{[}+{]} Easy special\sphinxhyphen{}purpose compilations of the code (optional)

\end{enumerate}

\item {} 
\sphinxAtStartPar
Front\sphinxhyphen{}end Python packages:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
{[}+{]} Python simple tools for RADMC\sphinxhyphen{}3D

\item {} 
\sphinxAtStartPar
{[}+{]} Python RADMC\sphinxhyphen{}3D library \{smalltt radmc3dPy\} (author: A. Juhasz)

\end{enumerate}

\item {} \begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
{[}+{]} Stars can be treated as point\sphinxhyphen{}sources or as spheres

\item {} 
\sphinxAtStartPar
{[}+{]} Option to calculate the mean intensity \(J_\nu(\vec x)\) in the model

\item {} 
\sphinxAtStartPar
{[}+{]} OpenMP parallellization of the Monte Carlo

\end{enumerate}

\end{enumerate}


\section{Version tracker}
\label{\detokenize{introduction:version-tracker}}
\sphinxAtStartPar
The RADMC\sphinxhyphen{}3D software package in under continuous development. A very
detailed development log\sphinxhyphen{}book is found in the git repository.
A more user\sphinxhyphen{}friendly overview of the development history can be
found in this manual, in appendix ref\{chap\sphinxhyphen{}development\sphinxhyphen{}history\}.


\section{Copyright}
\label{\detokenize{introduction:copyright}}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D was developed from 2007 to 2010/2011 at the Max Planck Institute
for Astronomy in Heidelberg, funded by a Max Planck Research Group grant
from the Max Planck Society. As of 2011 the development continues at the
Institute for Theoretical Astrophysics (ITA) of the Zentrum für Astronomy
(ZAH) at the University of Heidelberg.

\sphinxAtStartPar
\sphinxstylestrong{The use of this software is free of charge. However, it is not allowed
to distribute this package without prior consent of the lead author
(C.P. Dullemond). Please refer any interested user to the web site of this
software where the package is available, which is currently:}

\sphinxAtStartPar
\sphinxurl{http://www.ita.uni-heidelberg.de/~dullemond/software/radmc-3d}

\sphinxAtStartPar
or the github repository:

\sphinxAtStartPar
\sphinxurl{https://github.com/dullemond/radmc3d-2.0}

\sphinxAtStartPar
The github repository will always have the latest version, but it may
not be always the most stable version (though usually it is).


\section{Contributing authors}
\label{\detokenize{introduction:contributing-authors}}
\sphinxAtStartPar
The main author of RADMC\sphinxhyphen{}3D is Cornelis P. Dullemond. However, the main
author of the \sphinxcode{\sphinxupquote{radmc3dPy}} Python package is Attila Juhasz.

\sphinxAtStartPar
Numerous people have made contributions to RADMC\sphinxhyphen{}3D. Major contributions
are from:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Michiel Min

\item {} 
\sphinxAtStartPar
Attila Juhasz

\item {} 
\sphinxAtStartPar
Adriana Pohl

\item {} 
\sphinxAtStartPar
Rahul Shetty

\item {} 
\sphinxAtStartPar
Farzin Sereshti

\item {} 
\sphinxAtStartPar
Thomas Peters

\item {} 
\sphinxAtStartPar
Benoit Commercon

\item {} 
\sphinxAtStartPar
Alexandros Ziampras

\end{itemize}

\sphinxAtStartPar
The code profited from testing, feedback and bug reports from (incomplete list):
\begin{itemize}
\item {} 
\sphinxAtStartPar
Daniel Harsono

\item {} 
\sphinxAtStartPar
Rainer Rolffs

\item {} 
\sphinxAtStartPar
Laszlo Szucs

\item {} 
\sphinxAtStartPar
Sean Andrews

\item {} 
\sphinxAtStartPar
Stella Offner

\item {} 
\sphinxAtStartPar
Chris Beaumont

\item {} 
\sphinxAtStartPar
Katrin Rosenfeld

\item {} 
\sphinxAtStartPar
Soren Frimann

\item {} 
\sphinxAtStartPar
Jon Ramsey

\item {} 
\sphinxAtStartPar
Seokho Lee

\item {} 
\sphinxAtStartPar
Blake Hord

\item {} 
\sphinxAtStartPar
Tilman Birnstiel

\item {} 
\sphinxAtStartPar
Uma Gorti

\end{itemize}

\sphinxAtStartPar
and others.


\section{Disclaimer}
\label{\detokenize{introduction:disclaimer}}
\sphinxAtStartPar
\sphinxstylestrong{IMPORTANT NOTICE 1: I/We reject all responsibility for the use of this
package. The package is provided as\sphinxhyphen{}is, and we are not responsible for any
damage to hardware or software, nor for incorrect results that may result
from the software. The user is fully responsible for any results from this
code, and we strongly recommend thorough testing of the code before using
its results in any scientific papers.}

\sphinxAtStartPar
\sphinxstylestrong{IMPORTANT NOTICE 2: Any publications which involve the use of this
software must mention the name of this software package and cite the
accompanying paper once it is published (Dullemond et al.in prep), or
before that the above mentioned web site.}

\sphinxstepscope


\chapter{Quickstarting with RADMC\sphinxhyphen{}3D}
\label{\detokenize{quickstart:quickstarting-with-radmc-3d}}\label{\detokenize{quickstart:chap-quick-start}}\label{\detokenize{quickstart::doc}}
\sphinxAtStartPar
In general I recommend reading the manual fully, but it is often useful
to get a quick impression of the package with a quick\sphinxhyphen{}start. To make your
first example model, this is what you do:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
When you read this you have probably already unzipped this package, or
cloned the git repository.
You should find, among others, a \sphinxcode{\sphinxupquote{src/}} directory and a
\sphinxcode{\sphinxupquote{examples/}} directory. Go into the \sphinxcode{\sphinxupquote{src/}} directory.

\item {} 
\sphinxAtStartPar
Edit the \sphinxcode{\sphinxupquote{src/Makefile}} file, and make sure to set the
\sphinxcode{\sphinxupquote{FF}} variable to the Fortran\sphinxhyphen{}90 compiler you have installed on
your system.

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{make}}. If all goes well, this should compile the
entire code and create an executable called \sphinxcode{\sphinxupquote{radmc3d}}.

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{make install}}. If all goes well this should try to
create a link to \sphinxcode{\sphinxupquote{radmc3d}} in your \sphinxcode{\sphinxupquote{\$HOME/bin/}}
directory, where \sphinxcode{\sphinxupquote{\$HOME}} is your home directory.
If this \sphinxcode{\sphinxupquote{\$HOME/bin/}} directory does not exist, it will ask to make one.

\item {} 
\sphinxAtStartPar
Make sure to have the \sphinxcode{\sphinxupquote{\$HOME/bin/}} directory in your path.  If
you use, for instance, the \sphinxcode{\sphinxupquote{bash}} shell, you do this by setting the
\sphinxcode{\sphinxupquote{PATH}} variable by adding a line like \sphinxcode{\sphinxupquote{export
PATH=\$HOME/bin:\textbackslash{}\$PATH}} to your \sphinxcode{\sphinxupquote{\$HOME/.bashrc}} file. If you
change these things you may have to open a new shell to make sure that the
shell now recognizes the new path.

\item {} 
\sphinxAtStartPar
Check if the executable is OK by typing \sphinxcode{\sphinxupquote{radmc3d}} in the
shell. You should get a small welcoming message by the code.

\item {} 
\sphinxAtStartPar
Now enter the directory \sphinxcode{\sphinxupquote{examples/run\_simple\_1/}}. This is
the simplest example model.

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{python problem\_setup.py}} (Note: you must have a
working Python distribution on your computer, which is reasonably
up to date, with \sphinxcode{\sphinxupquote{numpy}} and \sphinxcode{\sphinxupquote{matplotlib}} libraries
included). This will create a series of input files for RADMC\sphinxhyphen{}3D.

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{radmc3d mctherm}}. This should let the code do a Monte
Carlo run. You should see \sphinxcode{\sphinxupquote{Photon nr 1000}}, followed by
\sphinxcode{\sphinxupquote{Photon nr 2000}}, etc until you reach \sphinxcode{\sphinxupquote{Photon nr
1000000}}. The Monte Carlo modeling for the dust temperatures has now
been done. A file \sphinxcode{\sphinxupquote{dust\_temperature.dat}} should have
been created.

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{radmc3d image lambda 1000 incl 60 phi 30}}. This should
create an image with the camera at inclination 60 degrees (from pole\sphinxhyphen{}on), and
rotated 30 degrees (along the polar axis, clockwise, i.e.the object rotating
counter\sphinxhyphen{}clockwise), at wavelength \(\lambda=1000\,\mu\mathrm{m}\) (i.e. at 1
millimeter wavelength). The file that contains the image is \sphinxcode{\sphinxupquote{image.out}}.
It is a text file that can be read with the \sphinxcode{\sphinxupquote{simpleread.py}} tool in the
directory \sphinxcode{\sphinxupquote{python/radmc3d\_tools/}}.

\end{enumerate}

\sphinxAtStartPar
If you experience troubles with the above steps, and you cannot fix it,
please read the next chapters for more details.

\sphinxstepscope


\chapter{Overview of the RADMC\sphinxhyphen{}3D package}
\label{\detokenize{overview:overview-of-the-radmc-3d-package}}\label{\detokenize{overview::doc}}

\section{Introduction}
\label{\detokenize{overview:introduction}}
\sphinxAtStartPar
The RADMC\sphinxhyphen{}3D code is written in fortran\sphinxhyphen{}90 and should compile with most f90
compilers without problems. It needs to be compiled only once for each
platform.

\sphinxAtStartPar
The executable is called \sphinxcode{\sphinxupquote{radmc3d}} and it performs all the model
calculations of the RADMC\sphinxhyphen{}3D package, for instance the Monte Carlo simulations,
ray\sphinxhyphen{}tracing runs (images, spectra), etc. There is also a set of useful
subroutines written in the Python language to use the \sphinxcode{\sphinxupquote{radmc3d}} code,
but \sphinxcode{\sphinxupquote{radmc3d}} can also run without it. In that case the user will
have to write his/her own pre\sphinxhyphen{} and post\sphinxhyphen{}processing subroutines.


\section{Requirements}
\label{\detokenize{overview:requirements}}\label{\detokenize{overview:sec-requirements}}
\sphinxAtStartPar
The following pre\sphinxhyphen{}installed software is required:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Operating system: Unix\sphinxhyphen{}like (e.g. Linux or MacOSX)}

\sphinxAtStartPar
This package runs under Unix\sphinxhyphen{}like environment (e.g. Linux or MacOSX), but has
not been tested under Windows. There is no particular reason why it should not
also run under Windows, but it would require different ways of file
handling. \sphinxstyleemphasis{In this manual we always assume a Unix\sphinxhyphen{}like environment,
in which we will make use of a bash command\sphinxhyphen{}line interface (CLI).} We will
call this the \sphinxstyleemphasis{shell}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{make}} or \sphinxcode{\sphinxupquote{gmake}}

\sphinxAtStartPar
This is the standard tool for compiling packages on all Unix/Linux/MacOS\sphinxhyphen{}based
systems.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{perl}}

\sphinxAtStartPar
This is a standard scripting language available on most or all
Unix/Linux\sphinxhyphen{}based systems. If you are in doubt: type \sphinxcode{\sphinxupquote{which perl}}
to find the location of the \sphinxcode{\sphinxupquote{perl}} executable. See \sphinxurl{http://www.perl.org/}
for details on perl, should you have any
problems. But on current\sphinxhyphen{}day Unix\sphinxhyphen{}type operating systems perl is nearly
always installed in the \sphinxcode{\sphinxupquote{/usr/bin/}} directory. If you do not
have Perl installed, you can also do without. Its sole use is to copy
the executables into your home \sphinxcode{\sphinxupquote{\$HOME/bin/}} directory for quick
access from the Unix/Linux/MacOS command line. You can work around that,
if necessary.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{A fortran\sphinxhyphen{}90 compiler}

\sphinxAtStartPar
Preferably the \sphinxcode{\sphinxupquote{gfortran}} compiler (which the current
installation assumes is present on the system). Website:
\sphinxurl{http://gcc.gnu.org/fortran/}. Other compilers may work, but have not
been tested yet.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{An OpenMP\sphinxhyphen{}fortran\sphinxhyphen{}90 compiler (optional)}

\sphinxAtStartPar
Only needed if you want to use the parallelized OpenMP version for the thermal
Monte Carlo (for faster execution). Preferably the \sphinxcode{\sphinxupquote{GNUOpenMP/GOMP}}
compiler which is an implementation of OpenMP for the Fortran compiler in the
GNU Compiler Collection. Websites: \sphinxurl{http://openmp.org/wp} and
\sphinxurl{http://gcc.gnu.org}. Other compilers may work, but we give no
guarantee.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Python version 3 with standard libraries}

\sphinxAtStartPar
The core RADMC\sphinxhyphen{}3D code \sphinxcode{\sphinxupquote{radmc3d}} (written in Fortran\sphinxhyphen{}90) is the
raw workhorse code that reads some input files and produces some output
files. Typically you will not need to worry about the internal workings of the
RADMC\sphinxhyphen{}3D code. All you need to do is produce the proper input files, run
\sphinxcode{\sphinxupquote{radmc3d}}, and read the output files for post\sphinxhyphen{}processing (such as
displaying and analyzing the results). This pre\sphinxhyphen{} and post\sphinxhyphen{}processing is
done in Python. This RADMC\sphinxhyphen{}3D distribution provides you with the Python tools
you need, though you will likely want to program your own additional Python code
to adjust the models to your own needs. To use the Python tools provided in
this RADMC\sphinxhyphen{}3D distribution, you need Python version 3
(though most things should also work with the depricated Python 2), with a
set of standard libraries such as \sphinxcode{\sphinxupquote{numpy}} and \sphinxcode{\sphinxupquote{matplotlib}}.
Typically we will assume that Python is used as a Python or iPython command\sphinxhyphen{}line
interface, which we shall call the \sphinxstyleemphasis{Python command line} (as opposed to the
\sphinxstyleemphasis{shell}). The user can, of course, also use Jupyter Notebooks instead.
But for the sake of clarity, in this manual we assume the use of Python the
Python command line.

\end{enumerate}

\sphinxAtStartPar
Note that the Monte Carlo code RADMC\sphinxhyphen{}3D itself (\sphinxcode{\sphinxupquote{radmc3d}}) is in Fortran\sphinxhyphen{}90. Only the
creation of the input files (and hence the problem definition) and the analysis
of the output files is done in Python. The user is of course welcome to use
other ways to create the input files for RADMC\sphinxhyphen{}3D if he/she is not able or
willing to use Python for whatever reason. Therefore Python is not strictly
required for the use of this code. However, all examples and support
infrastructure is provided in Python.


\section{Contents of the RADMC\sphinxhyphen{}3D package}
\label{\detokenize{overview:contents-of-the-radmc-3d-package}}

\subsection{RADMC\sphinxhyphen{}3D package as a .zip archive}
\label{\detokenize{overview:radmc-3d-package-as-a-zip-archive}}
\sphinxAtStartPar
If you obtain RADMC\sphinxhyphen{}3D from its website, it will be
packed in a zip archive called
\sphinxcode{\sphinxupquote{radmc\sphinxhyphen{}3d\_v*.*\_dd.mm.yy.zip}} where the \sphinxcode{\sphinxupquote{*.*}} is the version
number and \sphinxcode{\sphinxupquote{dd.mm.yy}} is the date of this version.
To unpack on a linux, unix or Mac OS X machine you type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{unzip} \PYG{o}{\PYGZlt{}}\PYG{n}{this} \PYG{n}{archive} \PYG{n}{file}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
i.e. for example for \sphinxcode{\sphinxupquote{radmc\sphinxhyphen{}3d\_v2.0\_25.08.20.zip}} you type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{unzip} \PYG{n}{radmc}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{n}{d\PYGZus{}v2}\PYG{l+m+mf}{.0\PYGZus{}25}\PYG{l+m+mf}{.08}\PYG{l+m+mf}{.20}\PYG{o}{.}\PYG{n}{zip}
\end{sphinxVerbatim}


\subsection{RADMC\sphinxhyphen{}3D package from the github repository}
\label{\detokenize{overview:radmc-3d-package-from-the-github-repository}}
\sphinxAtStartPar
If you obtain RADMC\sphinxhyphen{}3D by cloning its github repository, you will get
a copy of the full git repository of RADMC\sphinxhyphen{}3D. In principle this is
not much different from unzipping the .zip archive. But it is more
powerful: You can more easily stay up to date with the latest bugfixes,
and you can see the entire development history of this version of the
code. See \sphinxurl{https://git-scm.com/book/en/v2} for an extensive documentation
of how to use git.

\sphinxAtStartPar
The way to produce a clone of RADMC\sphinxhyphen{}3D in the directory where your
shell is currently is, is like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{dullemond}\PYG{o}{/}\PYG{n}{radmc3d}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{o}{.}\PYG{n}{git}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will create the directory \sphinxcode{\sphinxupquote{radmc3d\sphinxhyphen{}2.0/}}. At any time you can
pull the latest version from the repository like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{radmc3d}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{o}{/}
\PYG{n}{git} \PYG{n}{pull}
\end{sphinxVerbatim}

\sphinxAtStartPar
Keep in mind, however, that while the repository is always the very
latest version, this comes with a (small) risk that some new features
may not have been tested well, or (new) bugs may have been introduced.
Overall, however, we advise to use the github repository instead of
the .zip archive from the website.


\subsection{Contents of the package}
\label{\detokenize{overview:contents-of-the-package}}
\sphinxAtStartPar
The RADMC\sphinxhyphen{}3D package has the following subdirectory
structure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{src}\PYG{o}{/}
\PYG{n}{python}\PYG{o}{/}
\PYG{n}{examples}\PYG{o}{/}
   \PYG{n}{run\PYGZus{}simple\PYGZus{}1}\PYG{o}{/}
   \PYG{n}{run\PYGZus{}simple\PYGZus{}1\PYGZus{}userdef}\PYG{o}{/}
   \PYG{n}{run\PYGZus{}simple\PYGZus{}1\PYGZus{}userdef\PYGZus{}refined}\PYG{o}{/}
   \PYG{o}{.}
   \PYG{o}{.}
   \PYG{o}{.}
\PYG{n}{opac}\PYG{o}{/}
\PYG{n}{manual}\PYG{o}{/}
\end{sphinxVerbatim}

\sphinxAtStartPar
plus some further directories.

\sphinxAtStartPar
The first directory, \sphinxcode{\sphinxupquote{src/}}, contains the fortran\sphinxhyphen{}90 source code for
RADMC\sphinxhyphen{}3D. The second directory, \sphinxcode{\sphinxupquote{python/}}, contains two sets of Python modules
that are useful for model preparation and post\sphinxhyphen{}processing. One is a directory
called \sphinxcode{\sphinxupquote{radmc3d\_tools/}}, which contains some simple Python tools that might be
useful. The other is a directory called \sphinxcode{\sphinxupquote{radmc3dPy/}}, which is a high\sphinxhyphen{}level
stand\sphinxhyphen{}alone Python library developed by Attila Juhasz for RADMC\sphinxhyphen{}3D. The third
directory contains a series of example models. The fourth directory,
\sphinxcode{\sphinxupquote{opac/}} contains a series of tools and data for creating the opacity
files needed by RADMC\sphinxhyphen{}3D (though the example models all have their own
opacity data already included), The fifth directory contains
this manual.


\section{Units: RADMC\sphinxhyphen{}3D uses CGS units}
\label{\detokenize{overview:units-radmc-3d-uses-cgs-units}}
\sphinxAtStartPar
The RADMC\sphinxhyphen{}3D package is written such that all units are in CGS (length in
cm, time in sec, frequency in Hz, energy in erg, angle in steradian). There
are exceptions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Wavelength is usually written in micron

\item {} 
\sphinxAtStartPar
Sometimes angles are in degrees (internally in radian, but input as degrees)

\end{itemize}

\sphinxstepscope


\chapter{Installation of RADMC\sphinxhyphen{}3D}
\label{\detokenize{installation:installation-of-radmc-3d}}\label{\detokenize{installation:chap-compilation}}\label{\detokenize{installation::doc}}
\sphinxAtStartPar
Although the RADMC\sphinxhyphen{}3D package contains a lot of different software,
the main code is located in the \sphinxcode{\sphinxupquote{src/}} directory, and is
written in Fortran\sphinxhyphen{}90. The executable is \sphinxcode{\sphinxupquote{radmc3d}}. Here
we explain how to compile the fortran\sphinxhyphen{}90 source codes and create
the executable \sphinxcode{\sphinxupquote{radmc3d}}.


\section{Compiling the code with ‘make’}
\label{\detokenize{installation:compiling-the-code-with-make}}\label{\detokenize{installation:sec-makeing}}
\sphinxAtStartPar
To compile the code, enter the \sphinxcode{\sphinxupquote{src/}} directory in your shell. You now
\sphinxstyleemphasis{may} need to edit the \sphinxcode{\sphinxupquote{Makefile}} in this directory using your favorite
text editor and replace the line

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FF} \PYG{o}{=} \PYG{n}{gfortran} \PYG{o}{\PYGZhy{}}\PYG{n}{fopenmp}
\end{sphinxVerbatim}

\sphinxAtStartPar
with a line specifying your own compiler (and possibly OpenMP directive,
if available). If, of course, you use gfortran,
you can keep this line. But if you use, e.g., ifort, then replace the above
line by

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FF} \PYG{o}{=} \PYG{n}{ifort} \PYG{o}{\PYGZhy{}}\PYG{n}{openmp}
\end{sphinxVerbatim}

\sphinxAtStartPar
(note the slightly different OpenMP directive here, too).
If you save this file, and you are back in the shell, you can compile the
radmc3d code by typing

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{make}
\end{sphinxVerbatim}

\sphinxAtStartPar
in the shell. If all goes well, you have now created a file called \sphinxcode{\sphinxupquote{radmc3d}}
in the \sphinxcode{\sphinxupquote{src/}} directory.

\sphinxAtStartPar
If, for whatever reason, the OpenMP compilation does not work, you can also
compile the code in serial mode. Simply remove the \sphinxcode{\sphinxupquote{\sphinxhyphen{}fopenmp}} directive.


\section{The install.perl script}
\label{\detokenize{installation:the-install-perl-script}}
\sphinxAtStartPar
If instead of typing just \sphinxcode{\sphinxupquote{make}} you type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{make} \PYG{n}{install}
\end{sphinxVerbatim}

\sphinxAtStartPar
(or you first type \sphinxcode{\sphinxupquote{make}} and then \sphinxcode{\sphinxupquote{make install}}, it is the same), then in
addition to creating the executable, it also automatically executes a perl
script called \sphinxcode{\sphinxupquote{install.perl}} (located also in the \sphinxcode{\sphinxupquote{src/}} directory).  This
PERL script installs the code in such a way that it can be conveniently used in
any directory. What it does is:
\begin{itemize}
\item {} 
\sphinxAtStartPar
It checks if a \sphinxcode{\sphinxupquote{bin/}} directory is present in your home
directory (i.e. a \sphinxcode{\sphinxupquote{\$HOME/bin/}} directory). If not, it asks if
you want it to automatically make one.

\item {} 
\sphinxAtStartPar
It checks if the \sphinxcode{\sphinxupquote{\$HOME/bin/}} directory is in the \sphinxstyleemphasis{path} of
the currently used shell. This is important to allow the computer to look
for the program \sphinxcode{\sphinxupquote{radmc3d}} in the \sphinxcode{\sphinxupquote{\$HOME/bin/}} directory. If you
use a bash shell, then you can add the following line to your
\sphinxcode{\sphinxupquote{\$HOME/.bashrc}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export PATH=/myhomedirectory/bin:\PYGZdl{}PATH
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
It creates a file \sphinxcode{\sphinxupquote{radmc3d}} in this \sphinxcode{\sphinxupquote{\$HOME/bin/}}
directory with the correct executable permissions. This file is merely a
dummy executable, that simply redirects everything to the true \sphinxcode{\sphinxupquote{radmc3d}}
executable located in your current \sphinxcode{\sphinxupquote{src/}}
directory. When you now open a new shell, the path contains the
\sphinxcode{\sphinxupquote{\$HOME/bin/}} directory, and the command \sphinxcode{\sphinxupquote{radmc3d}} is
recognized. You can also type \sphinxcode{\sphinxupquote{source \$HOME/.bashrc}} followed
by \sphinxcode{\sphinxupquote{rehash}}. This also makes sure that your shell recognizes the
\sphinxcode{\sphinxupquote{radmc3d}} command.

\item {} 
\sphinxAtStartPar
It checks if a \sphinxcode{\sphinxupquote{python/}} subdirectory exists in the above
mentioned \sphinxcode{\sphinxupquote{bin/}} directory, i.e.a \sphinxcode{\sphinxupquote{\$HOME/bin/python/}}
directory. If not, it asks if you want it to automatically create one.

\item {} 
\sphinxAtStartPar
If yes, then it will copy all the files ending with \sphinxcode{\sphinxupquote{.py}} in
the \sphinxcode{\sphinxupquote{python/radmc3d\_tools/}} directory of the distribution to that
\sphinxcode{\sphinxupquote{\$HOME/bin/python/radmc3d\_tools/}} directory. This is useful to
allow you to make an \sphinxcode{\sphinxupquote{PYTHONPATH}} entry to allow python to find
these python scripts automatically.

\end{itemize}

\sphinxAtStartPar
Note that this perl script installs the code only for the user that installs
it. A system\sphinxhyphen{}wide installation is not useful, because the code package is not
very big and it should remain in the control of the user which version of the
code he/she uses for each particular problem.

\sphinxAtStartPar
If all went well, then the \sphinxcode{\sphinxupquote{perl.install}} script described here is
called automatically once you type \sphinxcode{\sphinxupquote{make install}} following the
procedure in Section {\hyperref[\detokenize{installation:sec-makeing}]{\sphinxcrossref{\DUrole{std,std-ref}{Compiling the code with ‘make’}}}}.

\sphinxAtStartPar
Before the installation is recognized by your shell, you must now either
type \sphinxcode{\sphinxupquote{rehash}} in the shell or simply open a new shell.

\sphinxAtStartPar
How do you know that all went OK? If you type \sphinxcode{\sphinxupquote{radmc3d}} in the
shell the RADMC\sphinxhyphen{}3D code should now be executed and give some comments. It
should write:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
================================================================
     WELCOME TO RADMC\PYGZhy{}3D: A 3\PYGZhy{}D CONTINUUM AND LINE RT SOLVER

                         VERSION 2.0

               (c) 2008\PYGZhy{}2020 Cornelis Dullemond

      Please feel free to ask questions. Also please report
       bugs and/or suspicious behavior without hestitation.
     The reliability of this code depends on your vigilance!
                   dullemond@uni\PYGZhy{}heidelberg.de

  To keep up\PYGZhy{}to\PYGZhy{}date with bug\PYGZhy{}alarms and bugfixes, register to
                    the RADMC\PYGZhy{}3D forum:
           http://radmc3d.ita.uni\PYGZhy{}heidelberg.de/phpbb/

             Please visit the RADMC\PYGZhy{}3D home page at
 http://www.ita.uni\PYGZhy{}heidelberg.de/\PYGZti{}dullemond/software/radmc\PYGZhy{}3d/
================================================================

Nothing to do... Use command line options to generate action:
  mctherm        : Do Monte Carlo simul of thermal radiation
  mcmono         : Do Monte Carlo simul only for computing mean intensity
  spectrum       : Make continuum spectrum
  image          : Make continuum image
\end{sphinxVerbatim}

\sphinxAtStartPar
on the screen (or for newer versions of RADMC\sphinxhyphen{}3D perhaps some more
or different text). This should also work from any other directory.


\section{What to do if this all does not work?}
\label{\detokenize{installation:what-to-do-if-this-all-does-not-work}}
\sphinxAtStartPar
In case the above compilation and installation does not work, here is a
proposed procedure to do problem hunting:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
First, answer the following questions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Did you type \sphinxcode{\sphinxupquote{make install}} in the \sphinxcode{\sphinxupquote{src/}}
directory? I mean, did you not forget the \sphinxcode{\sphinxupquote{install}} part?

\item {} 
\sphinxAtStartPar
Did you put \sphinxcode{\sphinxupquote{\$HOME/bin/}} in your path (see above)?

\item {} 
\sphinxAtStartPar
If you just added \sphinxcode{\sphinxupquote{\$HOME/bin/}} to your path, did you
follow the rest of the procedure (either closing the current shell and
opening a new shell or typing the \sphinxcode{\sphinxupquote{source}} and \sphinxcode{\sphinxupquote{rehash}} commands as
described above)?

\end{itemize}

\sphinxAtStartPar
If this does not help, then continue:

\item {} 
\sphinxAtStartPar
Close the shell, open a new shell.

\item {} 
\sphinxAtStartPar
Go to the RADMC\sphinxhyphen{}3D \sphinxcode{\sphinxupquote{src/}} directory.

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{./radmc3d}}. This should give the above message. If
not, then make sure that the compilation went right in the first place:

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{rm \sphinxhyphen{}f radmc3d}}, to make sure that any old executable
is not still present.

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{make clean}}. This should return the sentence
\sphinxcode{\sphinxupquote{OBJECT and MODULE files removed.}}

\item {} 
\sphinxAtStartPar
In case the problem lies with the OpenMP parallellization, you
could do \sphinxcode{\sphinxupquote{cp Makefile\_normal Makefile}}, which switches
off the OpenMP compilation.

\item {} 
\sphinxAtStartPar
Then type \sphinxcode{\sphinxupquote{make}}. This should produce a set of lines, each
representing a compilation of a module, e.g. \sphinxcode{\sphinxupquote{gfortran \sphinxhyphen{}c \sphinxhyphen{}O2
./amr\_module.f90 \sphinxhyphen{}o amr\_module.o}}, etc. The final line should be
something like \sphinxcode{\sphinxupquote{gfortran \sphinxhyphen{}O2 main.o ..... gascontinuum\_module.o \sphinxhyphen{}o radmc3d}}. If instead there
is an error message, then do the following:
\begin{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Check if the compiler used (by default \sphinxcode{\sphinxupquote{gfortran}}) is
available on your computer system.

\item {} 
\sphinxAtStartPar
If you use an other compiler, check if the compiler options used
are recognized by your compiler.

\item {} 
\sphinxAtStartPar
Check if the executable \sphinxcode{\sphinxupquote{radmc3d}} is now indeed present.
If it is not present, then something must have gone wrong with the
compilation. So then please check the compilation and linking stage
again carefully.

\end{itemize}

\sphinxAtStartPar
If you followed all these procedures, but you still cannot get even the
executable in the \sphinxcode{\sphinxupquote{src/}} directory to run by typing (in the
\sphinxcode{\sphinxupquote{src/}} directory) \sphinxcode{\sphinxupquote{./radmc3d}} (don’t forget the dot
slash!), then please contact the author.
\end{quote}

\item {} 
\sphinxAtStartPar
At this point we assume that the previous point worked. Now go to
another directory (any one), and type \sphinxcode{\sphinxupquote{radmc3d}}.  This should
also give the above message. If not, but the \sphinxcode{\sphinxupquote{radmc3d}} executable
was present, then apparently the shell path settings are wrong. Do this:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Check if, in the current directory (which is now not \sphinxcode{\sphinxupquote{src/}})
there is by some accident another copy of the executable
\sphinxcode{\sphinxupquote{radmc3d}}. If yes, please remove it.

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{which radmc3d}} to find out if it is recognized at all,
and if yes, to which location it points.

\item {} 
\sphinxAtStartPar
Did you make sure that the shell path includes the \sphinxcode{\sphinxupquote{\$HOME/bin/}}
directory, as it should? Otherwise the shell does not know
where to find the \sphinxcode{\sphinxupquote{\$HOME/bin/radmc3d}} executable (which is
a perl link to the \sphinxcode{\sphinxupquote{src/radmc3d}} executable).

\item {} 
\sphinxAtStartPar
Does the file \sphinxcode{\sphinxupquote{\$HOME/bin/radmc3d}} perl file exist in the
first place? If no, check why not.

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{less \$HOME/bin/radmc3d}} and you should
see a text with first line being \sphinxcode{\sphinxupquote{\#!/usr/bin/perl}} and the
second line being someting like
\sphinxcode{\sphinxupquote{system("/Users/user1/radmc\sphinxhyphen{}3d/version\_2.0/src/radmc3d @ARGV");}}
where the \sphinxcode{\sphinxupquote{/Users/user1}} should of course be the path to
your home directory, in fact to the directory in which you installed
RADMC\sphinxhyphen{}3D.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
If this all brings you no further, please first ask your system administrators
if they can help. If not, then please contact the author.


\section{Installing the simple Python analysis tools}
\label{\detokenize{installation:installing-the-simple-python-analysis-tools}}\label{\detokenize{installation:sec-install-pythonscripts}}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D offers (in addition to the model setup scripts in the \sphinxcode{\sphinxupquote{examples/}}
subdirectories) two Python support libraries:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{python/radmc3d\_tools/}}

\sphinxAtStartPar
This library contains only some bare\sphinxhyphen{}bones small Python scripts.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{python/radmc3dPy/}}

\sphinxAtStartPar
This library is a sophisticated stand\sphinxhyphen{}alone library developed by
Attila Juhasz, and further maintained together with the RADMC\sphinxhyphen{}3D
main author.

\end{enumerate}


\subsection{How to install and use the \sphinxstyleliteralintitle{\sphinxupquote{python/radmc3d\_tools/}}}
\label{\detokenize{installation:how-to-install-and-use-the-python-radmc3d-tools}}
\sphinxAtStartPar
The installation of the \sphinxcode{\sphinxupquote{python/radmc3d\_tools}} should be automatic when you
type \sphinxcode{\sphinxupquote{make install}} in the \sphinxcode{\sphinxupquote{src/}} code directory (see
above). It will copy the files to the \sphinxcode{\sphinxupquote{bin/python/radmc3d\_tools/}}
directory in your home directory. If this directory does not exist, you
will be asked if you want it to be created. If you confirm (typing ‘y’),
then the files from the \sphinxcode{\sphinxupquote{python/radmc3d\_tools/}} directory will be
copied into the \sphinxcode{\sphinxupquote{\$HOME/bin/python/radmc3d\_tools/}} directory.

\sphinxAtStartPar
Now you need to make sure that Python knows that these tools are there.
In Python here are two ways how you can make sure that Python automatically
finds these scripts:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Under Unix/Linux/MacOSX you can set the \sphinxcode{\sphinxupquote{PYTHONPATH}} directly in your
\sphinxcode{\sphinxupquote{.bashrc}} file. For example: in
\sphinxcode{\sphinxupquote{.bashrc}} (if you use the bash shell) you can write:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export PYTHONPATH=\PYGZdl{}HOME/bin/python:\PYGZdl{}PYTHONPATH
\end{sphinxVerbatim}

\end{enumerate}

\sphinxAtStartPar
(where \sphinxcode{\sphinxupquote{\$HOME}} is your home directory name).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Alternatively you can set the \sphinxcode{\sphinxupquote{PYTHONPATH}} directly from within
Python with the python command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{home} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{environ}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HOME}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{home}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/bin/python}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{enumerate}

\sphinxAtStartPar
If all goes well, if you now start Python you should be able to have access to
the basic Python tools of RADMC\sphinxhyphen{}3D directly. To test this, try typing \sphinxcode{\sphinxupquote{from
radmc3d\_tools.simpleread import *}} in Python. If this gives an error message
that \sphinxcode{\sphinxupquote{simpleread.py}} cannot be found, then please ask your system
administrators how to solve this.

\sphinxAtStartPar
You may ask why first copy these files to \sphinxcode{\sphinxupquote{\$HOME/bin/python/radmc3d\_tools/}}
and not point PYTHONPATH directly to the \sphinxcode{\sphinxupquote{python/radmc3d\_tools}} in your RADMC\sphinxhyphen{}3D
distribution? The reason is that if you have multiple versions of RADMC\sphinxhyphen{}3D on
your computer system, you always are assured that Python finds the python
routines belonging to the latest installation of RADMC\sphinxhyphen{}3D (note: only assured if
that latest compilation was done with \sphinxcode{\sphinxupquote{make install}}).

\sphinxAtStartPar
Now you should be ready to use the tools. The most important one would be
the \sphinxcode{\sphinxupquote{simpleread.py}} tool, which contains a set of functions for
reading typical RADMC\sphinxhyphen{}3D input and output files (though only for regular
model grid, not for octree grids). In a Python command line interface
you can import them by:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{radmc3d\PYGZus{}tools} \PYG{k+kn}{import} \PYG{n}{simpleread}
\end{sphinxVerbatim}

\sphinxAtStartPar
And you can then, for instance, read the dust density file with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{simpleread}\PYG{o}{.}\PYG{n}{read\PYGZus{}dustdens}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, \sphinxcode{\sphinxupquote{d}} is now an object containing a \sphinxcode{\sphinxupquote{d.grid}} subobject (which contain
information about the grid) and the dust density array \sphinxcode{\sphinxupquote{d.rhodust}}. Have a
look at the various functions in \sphinxcode{\sphinxupquote{simpleread}}, to see what is available.


\subsection{How to install and use the \sphinxstyleliteralintitle{\sphinxupquote{python/radmc3dPy}} library}
\label{\detokenize{installation:how-to-install-and-use-the-python-radmc3dpy-library}}
\sphinxAtStartPar
The installation of the \sphinxcode{\sphinxupquote{python/radmc3dPy}} package is described in the
\sphinxcode{\sphinxupquote{python/radmc3dPy/README}} file. In short, by going into the
\sphinxcode{\sphinxupquote{python/radmc3dPy/}} directory and typing in the shell:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{user}
\end{sphinxVerbatim}

\sphinxAtStartPar
it should install itself right into your Python distribution. For instance,
if you have \sphinxcode{\sphinxupquote{anaconda3}} on a Mac, it would copy the files into the
directory

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}HOME/.local/lib/python3.7/site\PYGZhy{}packages/radmc3dPy/
\end{sphinxVerbatim}

\sphinxAtStartPar
Python knows where to find it there.

\sphinxAtStartPar
Now you should be ready to use \sphinxcode{\sphinxupquote{radmc3dPy}}, by importing it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{radmc3dPy}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{radmc3dPy}} consists of
several sub libraries such as \sphinxcode{\sphinxupquote{radmc3dPy.analyze}} and
\sphinxcode{\sphinxupquote{radmc3dPy.image}}. For instance, to read the dust density
distribution, you could do this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{radmc3dPy} \PYG{k+kn}{import} \PYG{n}{analyze}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{analyze}\PYG{o}{.}\PYG{n}{readData}\PYG{p}{(}\PYG{n}{ddens}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{d.rhodust}} array now contains the dust density.

\sphinxAtStartPar
For more information, please consult the \sphinxcode{\sphinxupquote{radmc3dPy}} documentation
in the \sphinxcode{\sphinxupquote{python/radmc3dPy/doc/}} directory.


\section{Making special\sphinxhyphen{}purpose modified versions of RADMC\sphinxhyphen{}3D (optional)}
\label{\detokenize{installation:making-special-purpose-modified-versions-of-radmc-3d-optional}}\label{\detokenize{installation:sec-special-purpose-compile}}
\sphinxAtStartPar
For most purposes it should be fine to simply compile the latest version of
RADMC\sphinxhyphen{}3D once\sphinxhyphen{}and\sphinxhyphen{}for\sphinxhyphen{}all, and simply use the resulting \sphinxcode{\sphinxupquote{radmc3d}}
executable for all models you make. Normally there is no reason to have to
modify the code, because models can be defined quite flexibly by preparing
the various input files for RADMC\sphinxhyphen{}3D to your needs. So if you are an
average user, you can skip to the next subsection without problem.

\sphinxAtStartPar
But sometimes there \sphinxstyleemphasis{is} a good reason to want to modify the code.  For
instance to allow special behavior for a particular model. Or for a model
setup that is simply easier made internally in the code rather than by
preparing large input files. One can imagine some analytic model setup
that might be easier to create internally, so that one can make use of
the full AMR machinery to automatically refine the grid where needed.
Having to do so externally from the code would require you to set up
your own AMR machinery, which would be a waste of time.

\sphinxAtStartPar
The problem is that if the user would modify the central code for each
special purpose, one would quickly lose track of which modification of the
code is installed right now.

\sphinxAtStartPar
Here is how this problem is solved in RADMC\sphinxhyphen{}3D:
\begin{itemize}
\item {} 
\sphinxAtStartPar
For most purposes you can achieve your goals by only editing the file
\sphinxcode{\sphinxupquote{userdef\_module.f90}}. This is a set of standard subroutines
that the main code calls at special points in the code, and the user can
put anything he/she wants into those subroutines. See Chapter {\hyperref[\detokenize{internalsetup:chap-internal-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Modifying RADMC\sphinxhyphen{}3D: Internal setup and user\sphinxhyphen{}specified radiative processes}}}}
for more information about these standard
subroutines. This method is the safest way to create special\sphinxhyphen{}purpose
codes. It means (a) that you know that your modification cannot do much
harm unless you make really big blunders, because these subroutines are
meant to be modified, and (b) you have all your modifications \sphinxstyleemphasis{only}
in one single file, leaving the rest of the code untouched.

\item {} 
\sphinxAtStartPar
You can create a \sphinxstyleemphasis{local} version of the code, without touching
the main code. Suppose you have a model directory \sphinxcode{\sphinxupquote{run\_mymodel}} and for
this model you want to make a special\sphinxhyphen{}purpose version of the code.
This is what you do:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Copy the Makefile from the \sphinxcode{\sphinxupquote{src/}} directory into \sphinxcode{\sphinxupquote{run\_mymodel}}.

\item {} 
\sphinxAtStartPar
Copy the \sphinxcode{\sphinxupquote{.f90}} file(s) you want to modify from the \sphinxcode{\sphinxupquote{src/}}
directory into \sphinxcode{\sphinxupquote{run\_mymodel}}. Usually you only want to modify
the \sphinxcode{\sphinxupquote{userdef\_module.f90}} file, but you can also copy any other
file if you want.

\item {} 
\sphinxAtStartPar
In the \sphinxcode{\sphinxupquote{run\_mymodel/Makefile}} replace the \sphinxcode{\sphinxupquote{SRC = .}} line with
\sphinxcode{\sphinxupquote{SRC = XXXXXX}}, where \sphinxcode{\sphinxupquote{XXXXXX}} should
be the \sphinxstyleemphasis{full} path to the \sphinxcode{\sphinxupquote{src/}} directory. An example line
is given in the Makefile, but is commented out.

\item {} 
\sphinxAtStartPar
In the \sphinxcode{\sphinxupquote{run\_mymodel/Makefile}} make sure that all the
\sphinxcode{\sphinxupquote{.f90}} files that should remain as they are have a \sphinxcode{\sphinxupquote{\$(SRC)/}}
in front of the name, and all the \sphinxcode{\sphinxupquote{.f90}} files that
you want to modify (and which now have a copy in the \sphinxcode{\sphinxupquote{run\_mymodel}}
directory) have a \sphinxcode{\sphinxupquote{./}} in front of the name. By
default all \sphinxcode{\sphinxupquote{.f90}} files have \sphinxcode{\sphinxupquote{\$(SRC)/}} in front of
the name, except the \sphinxcode{\sphinxupquote{userdef\_module.f90}} file, which has a
\sphinxcode{\sphinxupquote{./}} in front of the name because that is the file that is
usually the one that is going to be edited by you.

\item {} 
\sphinxAtStartPar
Now edit the local \sphinxcode{\sphinxupquote{.f90}} files in the \sphinxcode{\sphinxupquote{run\_mymodel}} directory
in the way you want. See Chapter {\hyperref[\detokenize{internalsetup:chap-internal-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Modifying RADMC\sphinxhyphen{}3D: Internal setup and user\sphinxhyphen{}specified radiative processes}}}} for more details.

\item {} 
\sphinxAtStartPar
Now \sphinxstyleemphasis{inside} the \sphinxcode{\sphinxupquote{run\_mymodel}} directory you can now type
\sphinxcode{\sphinxupquote{make}} and you will create your own local \sphinxcode{\sphinxupquote{radmc3d}} executable.
NOTE: Do not type \sphinxcode{\sphinxupquote{make install}} in this case, because it should
remain a local executable, only inside the \sphinxcode{\sphinxupquote{run\_mymodel}} directory.

\item {} 
\sphinxAtStartPar
If you want (though this is not required) you can clean up all the
local \sphinxcode{\sphinxupquote{.o}} and \sphinxcode{\sphinxupquote{.mod}} files by typing \sphinxcode{\sphinxupquote{make
clean}}, so that your \sphinxcode{\sphinxupquote{run\_mymodel}} directory is not filled
with junk.

\item {} 
\sphinxAtStartPar
You can now use this special purpose version of \sphinxcode{\sphinxupquote{radmc3d}}
by simply calling on the command line: \sphinxcode{\sphinxupquote{./radmc3d}}, with any
command\sphinxhyphen{}line options you like. Just beware that, depending on the order
in which you have your paths set (in tcsh or bash) typing just
\sphinxcode{\sphinxupquote{radmc3d}} \sphinxstyleemphasis{may} instead use the global version (that you
may have created in the \sphinxcode{\sphinxupquote{src/}} directory with \sphinxcode{\sphinxupquote{make
install}}). So to be sure to use the \sphinxstyleemphasis{local} version, just put the
\sphinxcode{\sphinxupquote{./}} in front of the \sphinxcode{\sphinxupquote{radmc3d}}.

\end{enumerate}

\end{itemize}

\sphinxAtStartPar
Note: In chapter {\hyperref[\detokenize{internalsetup:chap-internal-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Modifying RADMC\sphinxhyphen{}3D: Internal setup and user\sphinxhyphen{}specified radiative processes}}}} there is more information on how to
set up models internally in the code using the method described here.

\sphinxAtStartPar
Note: You can use \sphinxcode{\sphinxupquote{make clean}} to remove all the .o and .mod files from your
model directory, because they can be annoying to have hanging around. By typing
\sphinxcode{\sphinxupquote{make cleanmodel}} you remove, in addition to the .o and .mod files, also all
model input and output files, with the exception of dust opacity or molecular
data files (because these latter files are usually not created locally by the
\sphinxcode{\sphinxupquote{problem\_setup.py}} script). By typing \sphinxcode{\sphinxupquote{make cleanall}} you remove everything
\sphinxstyleemphasis{except} the basic files such as the \sphinxcode{\sphinxupquote{Makefile}}, any \sphinxcode{\sphinxupquote{.f90}} files, any
\sphinxcode{\sphinxupquote{.py}} files, the dust opacity or molecular data files and \sphinxcode{\sphinxupquote{README}} files.

\sphinxstepscope


\chapter{Basic structure and functionality}
\label{\detokenize{basicstructure:basic-structure-and-functionality}}\label{\detokenize{basicstructure:chap-basic-struct-and-func}}\label{\detokenize{basicstructure::doc}}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D is a very versatile radiative transfer package with many
possibilities. As a consequence it is a rather complex package. However, we
have tried to keep it still as easy as possible to use as a first\sphinxhyphen{}time
user. We tried to do so by keeping many of the sophisticated options
‘hidden’ and having many default settings already well\sphinxhyphen{}chosen. The idea is
that one can already use the code at an entry level, and then gradually work
oneself into the more fancy options.

\sphinxAtStartPar
RADMC\sphinxhyphen{}3D is a general\sphinxhyphen{}purpose package, so there are no ‘built\sphinxhyphen{}in’ models
inside the \sphinxcode{\sphinxupquote{radmc3d}} executable (Except if you insert one yourself
using the userdef module, see Chapter {\hyperref[\detokenize{internalsetup:chap-internal-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Modifying RADMC\sphinxhyphen{}3D: Internal setup and user\sphinxhyphen{}specified radiative processes}}}}).  For
instance, if you want to model a protoplanetary disk, then you would have to
design the grid and density structure of the disk on this grid yourself. To
make it easier for the user, we have provided several Python\sphinxhyphen{}scripts as
examples. Among these examples is indeed a protoplanetary disk model. So
this is as close as we go to ‘built\sphinxhyphen{}in’ models: we provide, for some cases,
already well\sphinxhyphen{}developed example models that you, the user, can use
out\sphinxhyphen{}of\sphinxhyphen{}the\sphinxhyphen{}box, or that you can adapt to your needs.

\sphinxAtStartPar
In this chapter we give an overview of the rough functionality of the code
in its simplest form: ignoring all the hidden fancy options and
possibilities. For the details we then refer to the chapters ahead.


\section{Basic dataflow}
\label{\detokenize{basicstructure:basic-dataflow}}\label{\detokenize{basicstructure:sec-dataflow}}
\sphinxAtStartPar
Let us first clarify the basic philosophy of the code package (details will
be done later). When we talk about RADMC\sphinxhyphen{}3D we talk about the
fortran\sphinxhyphen{}90 program. The source codes are in the directory \sphinxcode{\sphinxupquote{src/}}
and the executable is called \sphinxcode{\sphinxupquote{radmc3d}}. This is the code that does
all the main calculations. You can call the code from the bash shell
(in Unix/Linux/MacOSX systems) and you can specify command\sphinxhyphen{}line options to
tell RADMC\sphinxhyphen{}3D what you want it to do.

\sphinxAtStartPar
The code RADMC\sphinxhyphen{}3D is in a way just a dumb computational engine. It has no
physical data (such as opacities or material properties) implemented, nor does
it have any model implemented. It is totally dependent on input files of various
kinds. These input files have filenames that end in \sphinxcode{\sphinxupquote{.inp}}, or \sphinxcode{\sphinxupquote{.binp}},
dependent on whether the data in ASCII, or binary form. You, the user, will have
to create these input files. RADMC\sphinxhyphen{}3D will simply look if an \sphinxcode{\sphinxupquote{.inp}}, or a
\sphinxcode{\sphinxupquote{.binp}} file is present, and will switch to ASCII, dependent on which
file\sphinxhyphen{}extension it finds.

\sphinxAtStartPar
After you run RADMC\sphinxhyphen{}3D (by calling \sphinxcode{\sphinxupquote{radmc3d}} with the appropriate command\sphinxhyphen{}line
options) you will see that the code will have produced one or more output files,
with filenames ending in \sphinxcode{\sphinxupquote{.out}} or \sphinxcode{\sphinxupquote{.bout}}. Whether RADMC\sphinxhyphen{}3D produces ASCII
or binary files, depends on a flag called \sphinxcode{\sphinxupquote{rto\_style}} that you can set (see
Chapter {\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}}).

\sphinxAtStartPar
\sphinxstyleemphasis{IMPORTANT NOTE: In this manual we will mostly refer to the ASCII form
of input and output files for convenience. But each time we refer to an
*.inp, *.dat or *.out file, we implicitly assume that this could also
be a *.binp, *.bdat or *.bout file.}

\sphinxAtStartPar
This basic dataflow is shown in Fig. {\hyperref[\detokenize{basicstructure:fig-dataflow-basic}]{\sphinxcrossref{\DUrole{std,std-ref}{Pictographic representation of the basic dataflow of RADMC\sphinxhyphen{}3D. The user
produces the input files; RADMC\sphinxhyphen{}3D reads them, performs the calculation,
and produces output files. The user can then analyze the output files.}}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{dataflow-basic}.pdf}
\caption{Pictographic representation of the basic dataflow of RADMC\sphinxhyphen{}3D. The user
produces the input files; RADMC\sphinxhyphen{}3D reads them, performs the calculation,
and produces output files. The user can then analyze the output files.}\label{\detokenize{basicstructure:id1}}\label{\detokenize{basicstructure:fig-dataflow-basic}}\end{figure}

\sphinxAtStartPar
Not always can RADMC\sphinxhyphen{}3D produce its output files in one go. Sometimes it has to
use a two\sphinxhyphen{}stage procedure: For dust continuum radiative transfer the dust
temperatures are computed first (stage 1), and the images and/or spectra are
rendered after that (stage 2). Between stage 1 and stage 2 an intermediate file
is then produced (with filename ending in \sphinxcode{\sphinxupquote{.dat}} or \sphinxcode{\sphinxupquote{.bdat}}),
which in the case of dust continuum radiative transfer is \sphinxcode{\sphinxupquote{dust\_temperature.dat}}
(or \sphinxcode{\sphinxupquote{*.bdat}}).

\sphinxAtStartPar
This basic dataflow is shown in Fig. {\hyperref[\detokenize{basicstructure:fig-dataflow-twostage}]{\sphinxcrossref{\DUrole{std,std-ref}{Pictographic representation of the dataflow of RADMC\sphinxhyphen{}3D for the case
of a 2\sphinxhyphen{}stage procedure, such as for dust continuum transfer. An intermediate
file is produced that will be used by stage 2, but of course the user can
also analyze the intermediate file itself.}}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.850\linewidth]{{dataflow-twostage}.pdf}
\caption{Pictographic representation of the dataflow of RADMC\sphinxhyphen{}3D for the case
of a 2\sphinxhyphen{}stage procedure, such as for dust continuum transfer. An intermediate
file is produced that will be used by stage 2, but of course the user can
also analyze the intermediate file itself.}\label{\detokenize{basicstructure:id2}}\label{\detokenize{basicstructure:fig-dataflow-twostage}}\end{figure}

\sphinxAtStartPar
Several of these input files contain large tables, for instance of the density
at each grid point, or the stellar flux at each wavelength bin. It is, of
course, impossible to create these datafiles by hand. The idea is that you
design a program (in any language you like) that creates these datafiles. In
that program you essentially ‘program the model’. We have provided a number of
example model setups in the \sphinxcode{\sphinxupquote{examples/}} directory. For these examples models
the setup programs were written in Python (their filenames all start with
\sphinxcode{\sphinxupquote{problem\_}} and end with \sphinxcode{\sphinxupquote{.py}}). For you as the user it is therefore the
easiest to start from one of these examples and modify the Python code to your
needs. However, if you prefer to use another language, you can use the examples
to see how the input files were generated and then program this in another
programming language.

\sphinxAtStartPar
\sphinxstyleemphasis{Note: The Python files called} \sphinxcode{\sphinxupquote{problem\_*.py}} \sphinxstyleemphasis{are meant to be edited and
changed by you! They are templates from which you can create your own models.}

\sphinxAtStartPar
For the analysis of the output files created by RADMC\sphinxhyphen{}3D you can use your own
favorite plotting or data\sphinxhyphen{}analysis software. But also here we provide some tools
in Python. These Python routines are in the \sphinxcode{\sphinxupquote{python/}} directory. Typically you
will create your own program, e.g. \sphinxcode{\sphinxupquote{plot\_model.py}} or so, that will use
these subroutines, e.g. by putting in the first line: \sphinxcode{\sphinxupquote{from radmc3dPy import
*}}. In this way Python is used also as a post\sphinxhyphen{}processing tool. But again: this
can also be done in another language.

\sphinxAtStartPar
This procedure is shown in Fig. {\hyperref[\detokenize{basicstructure:fig-dataflow-basic-python}]{\sphinxcrossref{\DUrole{std,std-ref}{Pictographic representation of how the Python programs in the example directories
are used to create the input files of RADMC\sphinxhyphen{}3D.}}}} for the
single\sphinxhyphen{}stage dataflow and in Fig. {\hyperref[\detokenize{basicstructure:fig-dataflow-twostage-python}]{\sphinxcrossref{\DUrole{std,std-ref}{Pictographic representation of the dataflow of RADMC\sphinxhyphen{}3D for the case
of a 2\sphinxhyphen{}stage procedure, such as for dust continuum transfer. An intermediate
file is produced that will be used by stage 2, but of course the user can
also analyze the intermediate file itself.}}}} for the
two\sphinxhyphen{}stage dataflow.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{dataflow-basic-python}.pdf}
\caption{Pictographic representation of how the Python programs in the example directories
are used to create the input files of RADMC\sphinxhyphen{}3D.}\label{\detokenize{basicstructure:id3}}\label{\detokenize{basicstructure:fig-dataflow-basic-python}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.850\linewidth]{{dataflow-twostage-python}.pdf}
\caption{Pictographic representation of the dataflow of RADMC\sphinxhyphen{}3D for the case
of a 2\sphinxhyphen{}stage procedure, such as for dust continuum transfer. An intermediate
file is produced that will be used by stage 2, but of course the user can
also analyze the intermediate file itself.}\label{\detokenize{basicstructure:id4}}\label{\detokenize{basicstructure:fig-dataflow-twostage-python}}\end{figure}


\section{Radiative processes}
\label{\detokenize{basicstructure:radiative-processes}}\label{\detokenize{basicstructure:sec-rad-processes}}
\sphinxAtStartPar
Currently RADMC\sphinxhyphen{}3D handles the following radiative processes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Dust thermal emission and absorption

\sphinxAtStartPar
RADMC\sphinxhyphen{}3D can compute spectra and images in dust continuum. The dust
temperature must be known in addition to the dust density. In typical
applications you will know the dust density distribution, but not the dust
temperature, because the latter is the results of a balance between
radiative absorption and re\sphinxhyphen{}emission. So in order to make spectra and
images of a dusty object we must first calculate the dust temperature
consistently. This can be done with RADMC\sphinxhyphen{}3D by making it perform a
‘thermal Monte Carlo’ simulation (see Chapter {\hyperref[\detokenize{dustradtrans:chap-dust-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Dust continuum radiative transfer}}}}).
This can be a time\sphinxhyphen{}consuming computation. But once this is done, RADMC\sphinxhyphen{}3D
writes the resulting dust temperatures out to the file
\sphinxcode{\sphinxupquote{dust\_temperature.dat}}, which it can then later use for images and
spectra. We can then call RADMC\sphinxhyphen{}3D again with the command to make an image
or a spectrum (see Chapter {\hyperref[\detokenize{dustradtrans:chap-dust-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Dust continuum radiative transfer}}}}). To summarize: a
typical dust continuum radiative transfer calculation goes in two stages:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
A thermal Monte Carlo simulation with RADMC\sphinxhyphen{}3D to compute the dust
temperatures.

\item {} 
\sphinxAtStartPar
A spectrum or image computation using ray\sphinxhyphen{}tracing with RADMC\sphinxhyphen{}3D.

\end{enumerate}

\item {} 
\sphinxAtStartPar
Dust scattering

\sphinxAtStartPar
Dust scattering is automatically included in the thermal Monte Carlo
simulations described above, as well as in the production of images and
spectra. For more details, consult Chapter {\hyperref[\detokenize{dustradtrans:chap-dust-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Dust continuum radiative transfer}}}}.

\item {} 
\sphinxAtStartPar
Gas atomic/molecular lines

\sphinxAtStartPar
RADMC\sphinxhyphen{}3D can compute spectra and images in gas lines (see Chapter
{\hyperref[\detokenize{lineradtrans:chap-line-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Line radiative transfer}}}}). The images are also known as \sphinxstyleemphasis{channel maps}. To
compute these, RADMC\sphinxhyphen{}3D must know the population densities of the various
atomic/molecular levels. For now there are the following options how to let
RADMC\sphinxhyphen{}3D know these values:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Tell RADMC\sphinxhyphen{}3D to assume that the molecules or atoms are in \sphinxstyleemphasis{Local
Thermodynamic Equilibrium} (LTE), and specify the gas temperature at
each location to allow RADMC\sphinxhyphen{}3D to compute these LTE level populations.
\sphinxstyleemphasis{Note that in principle one is now faced with the same problem as
with the dust continuum: we need to know the gas temperature, which we
typically do not know in advance.} However, computing the gas
temperature self\sphinxhyphen{}consistently is very difficult, because it involves
many heating and cooling processes, some of which are very complex.
That is why most line radiative transfer codes assume that the user gives
the gas temperature as input. We do so as well. If you like, you can
tell RADMC\sphinxhyphen{}3D to use the (previously calculated) dust temperature as the
gas temperature, for convenience.

\item {} 
\sphinxAtStartPar
Deliver RADMC\sphinxhyphen{}3D an input file with all the level populations
that you have calculated youself using some method.

\item {} 
\sphinxAtStartPar
Tell RADMC\sphinxhyphen{}3D to compute the level populations according to some
simple local non\sphinxhyphen{}LTE prescription such as the Sobolev approximation
(\sphinxstyleemphasis{Large Velocity Gradient method}) or the Escape Probability Method.

\end{itemize}

\sphinxAtStartPar
Currently RADMC\sphinxhyphen{}3D does not have a full non\sphinxhyphen{}local non\sphinxhyphen{}LTE computation
method implemented. The reason is that it is very costly, and for many
applications presumably not worth the computational effort.

\end{itemize}


\section{Coordinate systems}
\label{\detokenize{basicstructure:coordinate-systems}}\label{\detokenize{basicstructure:sec-coord-systems}}
\sphinxAtStartPar
With RADMC\sphinxhyphen{}3D you can specify your density distribution in two coordinate
systems:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Cartesian coordinates: 3\sphinxhyphen{}D

\sphinxAtStartPar
The simplest coordinate system is the Cartesian coordinate system
\((x,y,z)\). For now each model must be 3\sphinxhyphen{}D (i.e. you must specify the
densities and other quantities as a function of \(x\), \(y\) and \(z\)).

\item {} 
\sphinxAtStartPar
Cartesian coordinates: 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel

\sphinxAtStartPar
This is like the normal cartesian coordinates, but now the \(x\)\sphinxhyphen{} and \(y\)\sphinxhyphen{}
directions are infinitely extended. Only the \(z\)\sphinxhyphen{}direction has
finite\sphinxhyphen{}size cells, and hence the grid is only in \(z\)\sphinxhyphen{}direction.  This mode
is the usual plane\sphinxhyphen{}parallel mode of radiative transfer. See Section
{\hyperref[\detokenize{gridding:sec-1d-plane-parallel}]{\sphinxcrossref{\DUrole{std,std-ref}{1\sphinxhyphen{}D Plane\sphinxhyphen{}parallel models}}}} for more details on this mode.

\item {} 
\sphinxAtStartPar
Cartesian coordinates: 2\sphinxhyphen{}D pencil\sphinxhyphen{}parallel

\sphinxAtStartPar
This is the intermediate between full 3\sphinxhyphen{}D cartesian and 1\sphinxhyphen{}D
plane\sphinxhyphen{}parallel.  In this mode only the \(x\)\sphinxhyphen{}direction is infinitely
extended and a finite grid is in both \(y\) and \(z\) directions. This mode is
only useful in very special cases, and is much less familiar to most \sphinxhyphen{} so
use only when you are confident.

\item {} 
\sphinxAtStartPar
Spherical coordinates

\sphinxAtStartPar
You can also specify your model in spherical coordinates
\((r,\theta,\phi)\). These coordinates are related to the cartesian
ones by:
\begin{equation*}
\begin{split}\begin{split}
x &= r \sin\theta \cos\phi \\
y &= r \sin\theta \sin\phi \\
z &= r \cos\theta
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
This means that the spatial variables (density, temperature etc) are all
specified as a function of \((r,\theta,\phi)\). However, the location of the
stars, the motion and direction of photon packages etc. are still given in
cartesian coordinates \((x,y,z)\). In other words: any function of space
\(f(\vec x)\) will be in spherical coordinates \(f(r,\theta,\phi)\), but any
point\sphinxhyphen{}like specification of position \(\vec x\) will be given as Cartesian
coordinates \(\vec x=(x,y,z)\). This hybrid method allows us to do all
physics in cartesian coordinates: photon packages or rays are treated
always in cartesian coordinates, and so is the physics of scattering, line
emission etc.  Only if RADMC\sphinxhyphen{}3D needs to know what the local conditions
are (dust temperature, gas microturbulence, etc) RADMC\sphinxhyphen{}3D looks up which
coordinates \((r,\theta,\phi)\) belong to the current \((x,y,z)\) and looks up
the value of the density, microturbulence etc.at that location in the
\((r,\theta,\phi)\) grid. And the same is true if RADMC\sphinxhyphen{}3D updates or
calculates for instance the dust temperature: it will compute the
\((r,\theta,\phi)\) belong to the current \((x,y,z)\) and update the
temperature in the cell belonging to \((r,\theta,\phi)\). For the rest, all
the physics is done in the Cartesian coordinate system. This has the major
advantage that we do not need different physics modules for cartesian and
spherical coordinates. Most parts of the code don’t care which coordinate
system is used: they will do their own work in Cartesian coordinates.
When using spherical coordinates, please read Section
{\hyperref[\detokenize{gridding:sec-separable-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{Separable grid refinement in spherical coordinates (important!)}}}}.

\end{itemize}


\section{The spatial grid}
\label{\detokenize{basicstructure:the-spatial-grid}}\label{\detokenize{basicstructure:sec-spatial-grid}}
\sphinxAtStartPar
To specify the density or temperature structure (or any other spatial
variable) as a function of spatial location we must have a grid. There
are two basic types of grids:

\sphinxAtStartPar
The standard gridding is a simple rectangular grid.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Cartesian coordinates

\sphinxAtStartPar
When cartesian coordinates are used, this simply means that each cell is
defined as \(x_l<x<x_r\), \(y_l<y<y_r\) and \(z_l<z<z_r\), where
\(l\) and \(r\) stand for the left and right cell walls respectively.

\item {} 
\sphinxAtStartPar
Spherical coordinates

\sphinxAtStartPar
When spherical coordinates are used, this simply means that each cell is
defined as \(r_l<r<r_r\), \(\theta_l<\theta<\theta_r\) and
\(\phi_l<\phi<\phi_r\).  Note therefore that the shape of the cells in
spherical coordinates is (in real space) curved. For spherical coordinates the
following four modes are available:
\begin{itemize}
\item {} 
\sphinxAtStartPar
1\sphinxhyphen{}D Spherical symmetry:

\sphinxAtStartPar
All spatial functions depend only on \(r\).

\item {} 
\sphinxAtStartPar
2\sphinxhyphen{}D Axial symmetry:

\sphinxAtStartPar
All spatial functions depend only on \(r\) and \(\theta\).

\item {} 
\sphinxAtStartPar
2\sphinxhyphen{}D Axial symmetry with mirror symmetry:

\sphinxAtStartPar
All spatial functions depend only on \(r\) and \(\theta\), where the
\(\theta\) grid only covers the part above the \(z=0\)
plane. Internally it is in this mode assumed that all quantities below the
\(z=0\) plane are equal to those above the plane by mirror symmetry in
the \(z=0\) plane.  This saves a factor of two in computational effort
for Monte Carlo calculations, as well as in memory useage. Note that also
the resulting output files such as \sphinxcode{\sphinxupquote{dust\_temperature.dat}} will only be
specified for \(z>0\).

\item {} 
\sphinxAtStartPar
3\sphinxhyphen{}D:

\sphinxAtStartPar
All spatial functions depend on all three variables
\(r\), \(\theta\) and \(\phi\).

\item {} 
\sphinxAtStartPar
3\sphinxhyphen{}D with mirror symmetry:

\sphinxAtStartPar
All spatial functions depend on all three variables \(r\),
\(\theta\) and \(\phi\), but like in the 2\sphinxhyphen{}D case only the upper
part of the model needs to be specified: the lower part is assumed to be a
mirror copy.

\end{itemize}

\sphinxAtStartPar
When using spherical coordinates, please read Section
{\hyperref[\detokenize{gridding:sec-separable-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{Separable grid refinement in spherical coordinates (important!)}}}}.

\end{itemize}

\sphinxAtStartPar
In all cases these structured grids allow for oct\sphinxhyphen{}tree\sphinxhyphen{}style grid refinement, or
its simplified version: the layer\sphinxhyphen{}style grid refinement. See Section
{\hyperref[\detokenize{inputoutputfiles:sec-grid-input}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): amr\_grid.inp}}}} and Chapter {\hyperref[\detokenize{gridding:chap-gridding}]{\sphinxcrossref{\DUrole{std,std-ref}{More information about the gridding}}}} for more information
about the gridding and the (adaptive) mesh refinement (AMR).


\section{Computations that RADMC\sphinxhyphen{}3D can perform}
\label{\detokenize{basicstructure:computations-that-radmc-3d-can-perform}}\label{\detokenize{basicstructure:sec-actions}}
\sphinxAtStartPar
The code RADMC\sphinxhyphen{}3D (i.e. the executable \sphinxcode{\sphinxupquote{radmc3d}}) is \sphinxstyleemphasis{one} code for \sphinxstyleemphasis{many}
actions. Depending on which command\sphinxhyphen{}line arguments you give, RADMC\sphinxhyphen{}3D can do
various actions. Here is a list:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Compute the dust temperature:

\sphinxAtStartPar
With \sphinxcode{\sphinxupquote{radmc3d mctherm}} you call RADMC\sphinxhyphen{}3D with the command of performing a
thermal Monte Carlo simulation to compute the dust temperature under the
assumption that the dust is in radiative equilibrium with its radiation
field. This is normally a prerequisite for computing SEDs and images from
dusty objects (see \sphinxstyleemphasis{computing spectra and images} below).  The output file of
this computation is \sphinxcode{\sphinxupquote{dust\_temperature.dat}} which contains the dust
temperature everywhere in the model.

\item {} 
\sphinxAtStartPar
Compute a spectrum or SED:

\sphinxAtStartPar
With \sphinxcode{\sphinxupquote{radmc3d sed}} you call RADMC\sphinxhyphen{}3D with the command of performing a
ray\sphinxhyphen{}tracing computation to compute the spectral energy distribution (SED) for
the model at hand. Typically you first need to have called \sphinxcode{\sphinxupquote{radmc3d
mctherm}} (see above) beforehand to compute dust temperatures (unless you
have created the file \sphinxcode{\sphinxupquote{dust\_temperature.dat}} yourself because you have a
special way of computing the dust temperature). With \sphinxcode{\sphinxupquote{radmc3d sed}} the
spectrum is computed for the wavelengths points given in the file
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}}, which is the same wavelength grid that is used for
\sphinxcode{\sphinxupquote{radmc3d mctherm}}. If you want to compute the spectrum at wavelength other
than those used for the thermal Monte Carlo simulation, you should instead
call \sphinxcode{\sphinxupquote{radmc3d spectrum}}, and you have the full freedom to choose the
spectral wavelengths points at will, and you can specify these in various
ways described in Section {\hyperref[\detokenize{imagesspectra:sec-set-camera-frequencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}}}}.  Most easily you
can create a file called \sphinxcode{\sphinxupquote{camera\_wavelength\_micron.inp}} (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-camera-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (optional): camera\_wavelength\_micron.inp}}}}) and call RADMC\sphinxhyphen{}3D using \sphinxcode{\sphinxupquote{radmc3d spectrum
loadlambda}}. In all these cases the vantage point (where is the observer)
can of course be set as well, see Section {\hyperref[\detokenize{dustradtrans:sec-dust-ray-tracing}]{\sphinxcrossref{\DUrole{std,std-ref}{Making SEDs, spectra, images for dust continuum}}}} and
Chapter {\hyperref[\detokenize{imagesspectra:chap-images-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making images and spectra}}}}.

\item {} 
\sphinxAtStartPar
Compute an image:

\sphinxAtStartPar
With \sphinxcode{\sphinxupquote{radmc3d image}} you call RADMC\sphinxhyphen{}3D with the command of performing a
ray\sphinxhyphen{}tracing computation to compute an image. You must specify the
wavelength(s) at which you want the image by, for instance, calling RADMC\sphinxhyphen{}3D
as \sphinxcode{\sphinxupquote{radmc3d image lambda 10}}, which makes the image at
\(\lambda=10\mu\mathrm{m}\). But there are other ways by which the wavelength(s) can be set, see
Section {\hyperref[\detokenize{imagesspectra:sec-set-camera-frequencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}}}}.  In all these cases the vantage
point (where is the observer) can of course be set as well, see Section
{\hyperref[\detokenize{dustradtrans:sec-dust-ray-tracing}]{\sphinxcrossref{\DUrole{std,std-ref}{Making SEDs, spectra, images for dust continuum}}}} and Chapter {\hyperref[\detokenize{imagesspectra:chap-images-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making images and spectra}}}}.

\item {} 
\sphinxAtStartPar
Compute the local radiation field inside the model:

\sphinxAtStartPar
With \sphinxcode{\sphinxupquote{radmc3d mcmono}} you call RADMC\sphinxhyphen{}3D with the command of performing a
wavelength\sphinxhyphen{}by\sphinxhyphen{}wavlength monochromatic Monte Carlo simulation (at the
wavelengths that you specify in the file
\sphinxcode{\sphinxupquote{mcmono\_wavelength\_micron.inp}}). The output file of this computation is
\sphinxcode{\sphinxupquote{mean\_intensity.out}} which contains the mean intensity \(J_\nu\) as a
function of the \((x,y,z)\) (cartesian) or \((r,\theta,\phi)\)
(spherical) coordinates at the frequencies \(\nu_i\equiv
10^4c/\lambda_i\) where \(\lambda_i\) are the wavelengths (in
\(\mu\)m) specified in the file \sphinxcode{\sphinxupquote{mcmono\_wavelength\_micron.inp}}. The
results of this computation can be interesting for, for instance, models of
photochemistry. But if you use RADMC\sphinxhyphen{}3D only for computing spectra and
images, then you will not use this.

\end{enumerate}

\sphinxAtStartPar
In addition to the above main methods, you can ask RADMC\sphinxhyphen{}3D to do various minor
things as well, which will be described throughout this manual.


\section{How a model is set up and computed: a rough overview}
\label{\detokenize{basicstructure:how-a-model-is-set-up-and-computed-a-rough-overview}}
\sphinxAtStartPar
A radiative transfer code such as RADMC\sphinxhyphen{}3D has the task of computing synthetic
images and spectra of a model that you specify. You tell the code what the dust
and/or gas density distribution in 3\sphinxhyphen{}D space is and where the star(s) are, and
the code will then tell you what your cloud looks like in images and/or
spectra. That’s basically it. That’s the main task of RADMC\sphinxhyphen{}3D.

\sphinxAtStartPar
First you have to tell RADMC\sphinxhyphen{}3D what 3\sphinxhyphen{}D distribution of dust and/or gas you
want it to model. For that you must specify a coordinate system (cartesian or
spherical) and a spatial grid. For cartesian coordinates this grid should be 3\sphinxhyphen{}D
(although there are exceptions to this), while for spherical coordinates it can
be 1\sphinxhyphen{}D (spherical symmetry), 2\sphinxhyphen{}D (axial symmetry) or 3\sphinxhyphen{}D (no symmetry). RADMC\sphinxhyphen{}3D
is (for most part) a cell\sphinxhyphen{}based code, i.e. your grid devides space in cells and
you have to tell RADMC\sphinxhyphen{}3D what the average densities of dust and/or gas are in
these cells.

\sphinxAtStartPar
The structure of the grid is specified in a file \sphinxcode{\sphinxupquote{amr\_grid.inp}} (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-grid-input}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): amr\_grid.inp}}}}). All the other data, such as dust density and/or gas
density are specified in other files, but all assume that the grid is given by
\sphinxcode{\sphinxupquote{amr\_grid.inp}}.

\sphinxAtStartPar
We can also specify the locations and properties of one or more stars in the
model. This is done in the \sphinxcode{\sphinxupquote{stars.inp}} (see Section {\hyperref[\detokenize{inputoutputfiles:sec-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (mostly required): stars.inp}}}}) file.

\sphinxAtStartPar
Now suppose we want to compute the appearance of our model in dust continuum. We
will describe this in detail in Chapter {\hyperref[\detokenize{dustradtrans:chap-dust-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Dust continuum radiative transfer}}}}, but let us
give a very rough idea here. We write, in addition to the \sphinxcode{\sphinxupquote{amr\_grid.inp}} and
\sphinxcode{\sphinxupquote{stars.inp}} files, a file \sphinxcode{\sphinxupquote{dust\_density.inp}} which specifies the density of
dust in each cell (see Section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}).  We also must write the
main input file \sphinxcode{\sphinxupquote{radmc3d.inp}} (see Section {\hyperref[\detokenize{inputoutputfiles:sec-radmc-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: radmc3d.inp}}}}), but we can
leave it empty for now. We must give RADMC\sphinxhyphen{}3D a dust opacity table in the files
\sphinxcode{\sphinxupquote{dustopac.inp}} and for instance \sphinxcode{\sphinxupquote{dustkappa\_silicate.inp}} (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-opacities}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dustopac.inp and dustkappa\_*.inp or dustkapscatmat\_*.inp or dust\_optnk\_*.inp}}}}). And finally, we have to give RADMC\sphinxhyphen{}3D a table of discrete
wavelengths in the file \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} that it will use to perform
its calculations on. We then call the \sphinxcode{\sphinxupquote{radmc3d}} code with the keyword
\sphinxcode{\sphinxupquote{mctherm}} (see Chapter {\hyperref[\detokenize{dustradtrans:chap-dust-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Dust continuum radiative transfer}}}}) to tell it to perform a
Monte Carlo simulation to compute dust temperatures everywhere. RADMC\sphinxhyphen{}3D will
write this to the file \sphinxcode{\sphinxupquote{dust\_temperature.dat}}. If we now want to make a
spectral energy distribution, for instance, we call \sphinxcode{\sphinxupquote{radmc3d sed}} (see Section
{\hyperref[\detokenize{imagesspectra:sec-making-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making spectra}}}}) and it will write a file called \sphinxcode{\sphinxupquote{spectrum.out}}
which is a list of fluxes at the discrete wavelengths we specified in
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}}.  Then we are done: we have computed the spectral
energy distribution of our model. We could also make an image at wavelength 10
\(\mu\)m for instance with \sphinxcode{\sphinxupquote{radmc3d image lambda 10}} (see Section
{\hyperref[\detokenize{imagesspectra:sec-images}]{\sphinxcrossref{\DUrole{std,std-ref}{Basics of image making with RADMC\sphinxhyphen{}3D}}}}). This will write out a file \sphinxcode{\sphinxupquote{image.out}} containing the
image data (see Section {\hyperref[\detokenize{inputoutputfiles:sec-image-out}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT: image.out or image\_****.out}}}}).

\sphinxAtStartPar
As you see, RADMC\sphinxhyphen{}3D reads all its information from tables in various
files. Since you don’t want to make large tables by hand, you will have to write
a little computer program that generates these tables automatically.  You can do
this in any programming language you want. But in the example models (see
Section {\hyperref[\detokenize{basicstructure:sec-example-models}]{\sphinxcrossref{\DUrole{std,std-ref}{Running the example models}}}}) we use the programming language Python (see
Section {\hyperref[\detokenize{overview:sec-requirements}]{\sphinxcrossref{\DUrole{std,std-ref}{Requirements}}}}) for this. It is easiest to indeed have a look
at the example models to see how this is (or better: can be) done.

\sphinxAtStartPar
We will explain all these things in much more detail below, and we will discuss
also many other radiative transfer problem types. The above example is really
just meant to give an impression of how RADMC\sphinxhyphen{}3D works.


\section{Organization of model directories}
\label{\detokenize{basicstructure:organization-of-model-directories}}\label{\detokenize{basicstructure:sec-rough-overview-models}}
\sphinxAtStartPar
The general philosophy of the RADMC\sphinxhyphen{}3D code package is the following. The core
of everything is the fortran code \sphinxcode{\sphinxupquote{radmc3d}}. This is the main code which does
the hard work for you: it makes the radiative transfer calculations, makes
images, makes spectra etc. Normally you compile this code just once\sphinxhyphen{}and\sphinxhyphen{}for\sphinxhyphen{}all
(see Chapter {\hyperref[\detokenize{installation:chap-compilation}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation of RADMC\sphinxhyphen{}3D}}}}), and then simply use the executable
\sphinxcode{\sphinxupquote{radmc3d}} for all models. There is an exception to this ‘once\sphinxhyphen{}and\sphinxhyphen{}for\sphinxhyphen{}all’
rule described in Section {\hyperref[\detokenize{installation:sec-special-purpose-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Making special\sphinxhyphen{}purpose modified versions of RADMC\sphinxhyphen{}3D (optional)}}}}, but in the present
chapter we will not use this (see Chapter {\hyperref[\detokenize{internalsetup:chap-internal-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Modifying RADMC\sphinxhyphen{}3D: Internal setup and user\sphinxhyphen{}specified radiative processes}}}} for this
instead). So we will stick here to the philosophy of compiling this code once
and using it for all models.

\sphinxAtStartPar
So how to set up a model? The trick is to present \sphinxcode{\sphinxupquote{radmc3d}} with a set of
input files in which the model is described in all its details. The procedure to
follow is this:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The best thing to do (to avoid a mess) is to make a directory for
\sphinxstyleemphasis{each model}: one model, one directory. Since \sphinxcode{\sphinxupquote{radmc3d}} reads
multiple input files, and also outputs a number of files, this is a good
way to keep organized and we recommend it strongly.  So if we wish to make
a new model, we make a new directory, or copy an old directory to a new
name (if we merely want to make small changes to a prior model).

\item {} 
\sphinxAtStartPar
In this directory we generate the input files according to their required
format (see Chapter {\hyperref[\detokenize{inputoutputfiles:chap-input-files}]{\sphinxcrossref{\DUrole{std,std-ref}{Main input and output files of RADMC\sphinxhyphen{}3D}}}}). You can create these input files
in any way you want. But since many of these input files will/must contain
huge lists of numbers (for instance, giving the density at each location in
your model), you will typically want to write some script or program in some
language (be it either C, C++, Fortran, IDL, GDL, perl, python, you name it)
that automatically creates these input files. \sphinxstyleemphasis{We recommend using Python,
because we provide examples and standard subroutines in the programming
language Python; see below for more details.}  Section
{\hyperref[\detokenize{basicstructure:sec-example-models}]{\sphinxcrossref{\DUrole{std,std-ref}{Running the example models}}}} describes how to use the example Python scripts to
make these input files with Python.

\item {} 
\sphinxAtStartPar
When all the input files are created, and we make sure that we are inside the
model directory, we call \sphinxcode{\sphinxupquote{radmc3d}} with the desired command\sphinxhyphen{}line options
(see Chapter {\hyperref[\detokenize{clioptions:chap-command-line-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Command\sphinxhyphen{}line options}}}}). This will do the work for us.

\item {} 
\sphinxAtStartPar
Once this is done, we can analyze the results by reading the output files
(see Chapter {\hyperref[\detokenize{inputoutputfiles:chap-input-files}]{\sphinxcrossref{\DUrole{std,std-ref}{Main input and output files of RADMC\sphinxhyphen{}3D}}}}). To help you reading and analyzing
these output files you can use a set of Python routines that we created for
the user (see Chapter {\hyperref[\detokenize{pythontools:chap-python-analysis-tools}]{\sphinxcrossref{\DUrole{std,std-ref}{Python analysis tool set}}}} and Section
{\hyperref[\detokenize{installation:sec-install-pythonscripts}]{\sphinxcrossref{\DUrole{std,std-ref}{Installing the simple Python analysis tools}}}}). But here again, you are free to use any
other plotting software and/or data postprocessing packages.

\end{enumerate}


\section{Running the example models}
\label{\detokenize{basicstructure:running-the-example-models}}\label{\detokenize{basicstructure:sec-example-models}}
\sphinxAtStartPar
Often the fastest and easiest way to learn a code is simply to analyze and run a
set of example models. They are listed in the \sphinxcode{\sphinxupquote{examples}} directory. Each model
occupies a separate directory. This is also the style we normally recommend:
each model should have its own directory. Of course there are also exceptions to
this rule, and the user is free to organize her/his data in any way he/she
pleases. But in all the examples and throughout this manual each model has its
own directory.

\sphinxAtStartPar
To run an example model, go into the directory of this model, and follow the
directions that are written in the \sphinxcode{\sphinxupquote{README}} file in each of these
directories. \sphinxstyleemphasis{This is under the assumption that you have a full Python
distribution installed on your system, including Numpy and Matplotlib.}

\sphinxAtStartPar
Let us do for instance \sphinxcode{\sphinxupquote{run\_simple\_1/}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{run\PYGZus{}simple\PYGZus{}1}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we must create all the input files for this model. These input files are
all described in chapter {\hyperref[\detokenize{inputoutputfiles:chap-input-files}]{\sphinxcrossref{\DUrole{std,std-ref}{Main input and output files of RADMC\sphinxhyphen{}3D}}}}, but let us here just
‘blindly’ follow the example. In this example most (all except one) of the
input files are created using a Python script called \sphinxcode{\sphinxupquote{problem\_setup.py}}.
To execute this script, this is what you do on the shell:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{problem\PYGZus{}setup}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

\sphinxAtStartPar
This Python script has now created a whole series
of input files, all ending with the extension \sphinxcode{\sphinxupquote{.inp}}. To see which
files are created, type the following in the shell:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ls} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{o}{*}\PYG{o}{.}\PYG{n}{inp}
\end{sphinxVerbatim}

\sphinxAtStartPar
There is one file that this example does not create, and that is the file
\sphinxcode{\sphinxupquote{dustkappa\_silicate.inp}}. This is a file that contains the dust opacity in
tabulated form. This is a file that you as the user should provide to the
RADMC\sphinxhyphen{}3D code package. The file \sphinxcode{\sphinxupquote{dustkappa\_silicate.inp}} is merely an example,
which is an amorphous spherical silicate grain with radius 0.1 micron. But see
Section {\hyperref[\detokenize{inputoutputfiles:sec-opacities}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dustopac.inp and dustkappa\_*.inp or dustkapscatmat\_*.inp or dust\_optnk\_*.inp}}}} for more information about the opacities.

\sphinxAtStartPar
Now that the input files are created, we must run \sphinxcode{\sphinxupquote{radmc3d}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{mctherm}
\end{sphinxVerbatim}

\sphinxAtStartPar
This tells RADMC\sphinxhyphen{}3D to do the thermal Monte Carlo simulation. This may
take some time. When the model is ready, the prompt of the shell returns.
To see what files have been created by this run of the code, type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ls} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{o}{*}\PYG{o}{.}\PYG{n}{dat}
\end{sphinxVerbatim}

\sphinxAtStartPar
You will find the \sphinxcode{\sphinxupquote{dust\_temperature.dat}} containing the dust temperature
everywhere in the model. See again chapter {\hyperref[\detokenize{inputoutputfiles:chap-input-files}]{\sphinxcrossref{\DUrole{std,std-ref}{Main input and output files of RADMC\sphinxhyphen{}3D}}}} for
details of these files. To create a spectral energy distribution (SED):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{sed} \PYG{n}{incl} \PYG{l+m+mf}{45.}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will create a file \sphinxcode{\sphinxupquote{spectrum.out}}.  To analyze these data you can use the
Python routines delivered with the code (see Chapter
{\hyperref[\detokenize{pythontools:chap-python-analysis-tools}]{\sphinxcrossref{\DUrole{std,std-ref}{Python analysis tool set}}}} and Section {\hyperref[\detokenize{installation:sec-install-pythonscripts}]{\sphinxcrossref{\DUrole{std,std-ref}{Installing the simple Python analysis tools}}}}).

\sphinxAtStartPar
There is a file \sphinxcode{\sphinxupquote{Makefile}} in the directory. This is here only meant to make
it easy to clean the directory. Type \sphinxcode{\sphinxupquote{make cleanmodel}} to clean all the output
from the radmc3d code. Type \sphinxcode{\sphinxupquote{make cleanall}} to clean the directory back to
basics.

\sphinxAtStartPar
Let us now do for instance model \sphinxcode{\sphinxupquote{run\_simple\_1\_userdef/}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{run\PYGZus{}simple\PYGZus{}1\PYGZus{}userdef}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is the same model as above, but now the grid and the dust density are set
up \sphinxstyleemphasis{inside} \sphinxcode{\sphinxupquote{radmc3d}}, using the file \sphinxcode{\sphinxupquote{userdef\_module.f90}} which is
present in this directory.  See Chapter {\hyperref[\detokenize{internalsetup:chap-internal-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Modifying RADMC\sphinxhyphen{}3D: Internal setup and user\sphinxhyphen{}specified radiative processes}}}} for details
and follow the directions in the \sphinxcode{\sphinxupquote{README}} file. In short: first edit the
variable \sphinxcode{\sphinxupquote{SRC}} in the \sphinxcode{\sphinxupquote{Makefile}} to point to the \sphinxcode{\sphinxupquote{src/}} directory. Then
type \sphinxcode{\sphinxupquote{make}}. Then type \sphinxcode{\sphinxupquote{python problem\_setup.py}} on the shell command line
(which now only sets up the frequency grid, the star and the \sphinxcode{\sphinxupquote{radmc3d.inp}}
file and some small stuff). Now you can run the model.

\sphinxAtStartPar
\sphinxstyleemphasis{Please read the README file in each of the example model directories.
Everything is explained there, including how to make the relevant plots.}

\sphinxstepscope


\chapter{Dust continuum radiative transfer}
\label{\detokenize{dustradtrans:dust-continuum-radiative-transfer}}\label{\detokenize{dustradtrans:chap-dust-transfer}}\label{\detokenize{dustradtrans::doc}}
\sphinxAtStartPar
Many of the things related to dust continuum radiative transfer have
already been said in the previous chapters. But here we combine these
things, and expand with more in\sphinxhyphen{}depth information.

\sphinxAtStartPar
Most users simply want RADMC\sphinxhyphen{}3D to compute images and spectra from a
model. This is done in a two\sphinxhyphen{}stage procedure:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
First compute the dust temperature everywhere using the thermal Monte
Carlo computation (Section {\hyperref[\detokenize{dustradtrans:sec-dust-thermal-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{The thermal Monte Carlo simulation: computing the dust temperature}}}}).

\item {} 
\sphinxAtStartPar
Then making the images and/or spectra (Section {\hyperref[\detokenize{dustradtrans:sec-dust-ray-tracing}]{\sphinxcrossref{\DUrole{std,std-ref}{Making SEDs, spectra, images for dust continuum}}}}).

\end{enumerate}

\sphinxAtStartPar
You can then view the output spectra and images with the Python tools or use
your own plotting software.

\sphinxAtStartPar
Some expert users may wish to use RADMC\sphinxhyphen{}3D for something entirely different:
to compute the local radiation field \{em inside\} a model, and use this
for e.g. computing photochemistry rates of a chemical model or so.
This is described in Section {\hyperref[\detokenize{dustradtrans:sec-dust-monochromatic-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Special\sphinxhyphen{}purpose feature: Computing the local radiation field}}}}.

\sphinxAtStartPar
You may also use the thermal Monte Carlo computation of the dust temperature
to help estimating the \{em gas\} temperature for the line radiative transfer.
See Chapter {\hyperref[\detokenize{lineradtrans:chap-line-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Line radiative transfer}}}} for more on line transfer.


\section{The thermal Monte Carlo simulation: computing the dust temperature}
\label{\detokenize{dustradtrans:the-thermal-monte-carlo-simulation-computing-the-dust-temperature}}\label{\detokenize{dustradtrans:sec-dust-thermal-monte-carlo}}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D can compute the dust temperature using the Monte Carlo method of
Bjorkman \& Wood (2001, ApJ 554, 615) with various improvements such as the
continuous absorption method of Lucy (1999, A\&A 344, 282). Once a model is
entirely set up, you can ask \sphinxcode{\sphinxupquote{radmc3d}} to do the Monte Carlo
run for you by typing in a shell:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{mctherm}
\end{sphinxVerbatim}

\sphinxAtStartPar
if you use the standard \sphinxcode{\sphinxupquote{radmc3d}} code, or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{/}\PYG{n}{radmc3d} \PYG{n}{mctherm}
\end{sphinxVerbatim}

\sphinxAtStartPar
if you have created a local version of \sphinxcode{\sphinxupquote{radmc3d}} (see Section
{\hyperref[\detokenize{installation:sec-special-purpose-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Making special\sphinxhyphen{}purpose modified versions of RADMC\sphinxhyphen{}3D (optional)}}}}).

\sphinxAtStartPar
What the method does is the following: First all the netto sources of energy
(or more accurately: sources of luminosity) are identified. The following
net sources of energy can be included:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Stars:} You can specify any number of individual stars: their
position, and their spectrum and luminosity (See Section
{\hyperref[\detokenize{inputoutputfiles:sec-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (mostly required): stars.inp}}}}). This is the most commonly used source of luminosity, and
as a beginning user we recommend to use only this for now.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Continuum stellar source:} For simulations of galaxies it would
require by far too many individual stars to properly include the input
of stellar light from the billions of stars in the galaxy. To overcome
this problem you can specify a continuously spatially distributed source
of stars. \sphinxstyleemphasis{NOTE: Still in testing phase.}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Viscous heating / internal heating:} Sometimes the dust grains
acquire energy directly from the gas, for instance through viscous heating
of the gas or adiabatic compression of the gas. This can be included as a
spatially distributed source of energy. \sphinxstyleemphasis{NOTE: Still in
progress… Not yet working.}

\end{itemize}

\sphinxAtStartPar
To compute the dust temperature we must have at least one source of luminosity,
otherwise the equilibrium dust temperature would be everywhere 0.

\sphinxAtStartPar
The next step is that this total luminosity is divided into \sphinxcode{\sphinxupquote{nphot}} packages,
where \sphinxcode{\sphinxupquote{nphot}} is 100000 by default, but can be set to any value by the user
(see the file \sphinxcode{\sphinxupquote{radmc3d.inp}} described in Section {\hyperref[\detokenize{inputoutputfiles:sec-radmc-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: radmc3d.inp}}}}). Then
these photon packages are emitted by these sources one\sphinxhyphen{}by\sphinxhyphen{}one. As they move
through the grid they may scatter off dust grains and thus change their
direction. They may also get absorbed by the dust. If that happens, the photon
package is immediately re\sphinxhyphen{}emitted in another direction and with another
wavelength. The wavelength is chosen according to the recipe by Bjorkman \& Wood
(2001, ApJ 554, 615). The luminosity fraction that each photon package
represents remains, however, the same. Each time a photon package enters a cell
it increases the ‘energy’ of this cell and thus increases the temperature of
the dust of this cell.  The recipe for this is again described by Bjorkman \&
Wood (2001, ApJ 554, 615), but contrary to that paper we increase the
temperature of the dust always when a photon package enters a cell, while
Bjorkman \& Wood only increase the dust temperature if a discrete absorption
event has taken place. Each photon package will ping\sphinxhyphen{}pong through the model and
never gets lost until it escapes the model through the outer edge of the grid
(which, for cartesianl coordinates, is any of the grid edges in \(x\),
\(y\) or \(z\), and for spherical coordinates is the outer edge of
\(r\)). Once it escapes, a new photon package is launched, until also it
escapes. After all photon packages have been launched and escaped, the dust
temperature that remains is the final answer of the dust temperature.

\sphinxAtStartPar
One must keep in mind that the temperature thus computed is an \sphinxstyleemphasis{equilibrium}
dust temperature. It assumes that each dust grain acquires as much energy as it
radiates away. This is for most cases presumably a very good approximation,
because the heating/cooling time scales for dust grains are typically very short
compared to any time\sphinxhyphen{}dependent dynamics of the system. But there might be
situations where this may not be true: in case of rapid compression of gas, near
shock waves or in extremely optically thick regions.

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE:} Monte Carlo simulations are based on pseudo\sphinxhyphen{}random numbers.
The seed for the random number generator is by default set to \sphinxhyphen{}17933201.
If you want to perform multiple identical simulations with a different
random sequence you will need to set the seed by hand. This can be
done by adding a line

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iseed} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5415}
\end{sphinxVerbatim}

\sphinxAtStartPar
(where \sphinxhyphen{}5415 is to be replaced by the value you want) to the \sphinxcode{\sphinxupquote{radmc3d.inp}} file.


\subsection{Modified Random Walk method for high optical depths}
\label{\detokenize{dustradtrans:modified-random-walk-method-for-high-optical-depths}}\label{\detokenize{dustradtrans:sec-modrandwalk}}
\sphinxAtStartPar
As you will soon find out: very optically thick models make the RADMC\sphinxhyphen{}3D thermal
Monte Carlo simulations to be slow. This is because in the thermal Monte Carlo
method a photon package is never destroyed unless it leaves the system. A photon
package can thus ‘get lost’ deep inside an optically thick region, making
millions (or even billions) of absorption+reemission or scattering
events. Furthermore, you will notice that in order to get the temperatures in
these very optically thick regions to be reliable (i.e. not too noisy) you may
need a very large number of photon packages for your simulation, which slows
down the simulation even more. It is hard to prevent such problems. Min,
Dullemond, Dominik, de Koter \& Hovenier (2009) A\&A 497, 155 discuss two methods
of dealing with this problem. One is a diffusion method, which we will not
discuss here. The other is the ‘Modified Random Walk’ (MRW) method, based on the
method by Fleck \& Canfield (1984) J.Comput.Phys. 54, 508. Note that
Robitaille (2010) A\&A 520, 70 presented a simplification of this method. Min et
al. first implemented this method into the MCMax code. It is also implemented in
RADMC\sphinxhyphen{}3D, in Robitaille’s simplified form.

\sphinxAtStartPar
The crucial idea of the method is that if a photon package ‘gets lost’ deep
inside a single ultra\sphinxhyphen{}optically\sphinxhyphen{}thick cell, we can use the analytical solutions
of the diffusion equation in a constant\sphinxhyphen{}density medium to predict where the
photon package will go next. This thus allows RADMC\sphinxhyphen{}3D to make a single large
step of the photon package which actually corresponds to hundreds or thousands
of absorption+reemission or scattering events.

\sphinxAtStartPar
The method works best if the optically thick cells are as large as possible.
This is because the analytical solutions are only valid within a single cell,
and thus the ‘large step’ can not be larger than a single cell size.  Moreover,
cell crossings will reduce the step length again to the physical mean free path,
so the more cell crossings are made, the less effective the MRW becomes.

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE:} The MRW is by default switched off. The reason is that it is, after all,
an approximation. However, if RADMC\sphinxhyphen{}3D thinks that the MRW may help speed up the
thermal Monte Carlo, it will make the suggestion to the user to switch on the
MRW method.

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE:} So far the MRW method is only implemented using the Planck mean opacity
for estimating the ‘large step’. This could, under certain conditions, be
inaccurate. The reason why the (more accurate) Rosseland mean opacity is not
used is that this precludes the precomputation and tabulation of the mean
opacities if multiple independent dust species are used. Strictly speaking,
even the Rosseland mean opacity is not entirely correct, but it is a good
approximation (see Min et al. 2009). So far these simplifications do not seem
to matter a lot. But if strong effects are seen, please report these. Conditions
under which it is likely to make a difference (i.e.  the present implementation
becoming inaccurate) are when an internal heat source inside a super\sphinxhyphen{}optically
thick region is introduced (e.g. viscous heating in a disk), and/or when the
opacities are extremely wavelength\sphinxhyphen{}dependent (varying by orders of magnitude in
small distances in wavelengths). So please use MRW with care. Upon request we
may implement the true MRW: with the Rosseland mean, which, however, may make
the code slower.

\sphinxAtStartPar
You can switch on the MRW by adding the following line to the
\sphinxcode{\sphinxupquote{radmc3d.inp}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{modified\PYGZus{}random\PYGZus{}walk} \PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\section{Making SEDs, spectra, images for dust continuum}
\label{\detokenize{dustradtrans:making-seds-spectra-images-for-dust-continuum}}\label{\detokenize{dustradtrans:sec-dust-ray-tracing}}
\sphinxAtStartPar
You can use RADMC\sphinxhyphen{}3D for computing spectra and images in dust continuum
emission. This is described in detail in Chapter
{\hyperref[\detokenize{imagesspectra:chap-images-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making images and spectra}}}}. RADMC\sphinxhyphen{}3D needs to know not only the dust spatial
distribution, given in the file \sphinxcode{\sphinxupquote{dust\_density.inp}}, but also the
dust temperature, given in the file \sphinxcode{\sphinxupquote{dust\_temperature.dat}} (see
Chapter {\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}} for the binary version of these files, which
are more compact, and which you can use instead of the ascii versions). The
\sphinxcode{\sphinxupquote{dust\_temperature.dat}} is normally computed by RADMC\sphinxhyphen{}3D itself
through the thermal Monte Carlo computation (see Section
{\hyperref[\detokenize{dustradtrans:sec-dust-thermal-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{The thermal Monte Carlo simulation: computing the dust temperature}}}}). But if you, the user, wants to specify
the dust temperature at each location in the model youself, then you can
simply create your own file \sphinxcode{\sphinxupquote{dust\_temperature.dat}} and skip the
thermal Monte Carlo simulation and go straight to the creation of images or
spectra.

\sphinxAtStartPar
The basic command to make a spectrum at the global grid of wavelength
(specified in the file \sphinxcode{\sphinxupquote{wavelength\_micron.inp}},
see Section {\hyperref[\detokenize{inputoutputfiles:sec-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): wavelength\_micron.inp}}}}) is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{sed}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can specify the direction of the observer with \sphinxcode{\sphinxupquote{incl}} and \sphinxcode{\sphinxupquote{phi}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{sed} \PYG{n}{incl} \PYG{l+m+mi}{20} \PYG{n}{phi} \PYG{l+m+mi}{80}
\end{sphinxVerbatim}

\sphinxAtStartPar
which means: put the observer at inclination 20 degrees and \(\phi\)\sphinxhyphen{}angle
80 degrees.

\sphinxAtStartPar
You can also make a spectrum for a given grid of wavelength (independent of the
global wavelength grid). You first create a file
\sphinxcode{\sphinxupquote{camera\_wavelength\_micron.inp}}, which has the same format as
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}}. You can put any set of wavelengths in this file
without modifying the global wavelength grid (which is used by the thermal Monte
Carlo computation). Then you type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{spectrum} \PYG{n}{loadlambda}
\end{sphinxVerbatim}

\sphinxAtStartPar
and it will create the spectrum on this wavelength grid. More information about
making spectra is given in Chapter {\hyperref[\detokenize{imagesspectra:chap-images-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making images and spectra}}}}.

\sphinxAtStartPar
For creating an image you can type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxAtStartPar
which creates an image at wavelength \(\lambda`=10:math:\)mu\textasciigrave{}m. More information
about making images is given in Chapter {\hyperref[\detokenize{imagesspectra:chap-images-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making images and spectra}}}}.

\sphinxAtStartPar
\sphinxstyleemphasis{Important note:} To handle scattering of light off dust grains, the ray\sphinxhyphen{}tracing
is preceded by a quick Monte Carlo run that is specially designed to compute the
‘scattering source function’. This Monte Carlo run is usually \sphinxstyleemphasis{much} faster
than the thermal Monte Carlo run, but must be done at each wavelength. It can
lead, however, to slight spectral noise, because the random photon paths are
different for each wavelength.  See Section {\hyperref[\detokenize{dustradtrans:sec-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{More about scattering of photons off dust grains}}}} for details.


\section{OpenMP parallelized Monte Carlo}
\label{\detokenize{dustradtrans:openmp-parallelized-monte-carlo}}\label{\detokenize{dustradtrans:sec-omp-mc}}
\sphinxAtStartPar
Depending on the model properties and the number of photon packages used in
the simulation the Monte Carlo calculation (in particular the thermal Monte
Carlo, but under some conditions also the scattering Monte Carlo) can be a
time\sphinxhyphen{}consuming computation when executed only in a serial mode. To improve
this, these Monte Carlo calculations can be done in OpenMP parallel mode.
The loop over photon packages is then distributed amongst the different
threads, where each thread adopts a specific number of loop iterations
following the order of the thread identification number. To this end the
random number generator was modified. The important point for the parallel
version is that different threads must not share the same random seed
initially. To be certain that each thread is assigned a different seed at
the beginning, the thread identity number is added to the initial seed.

\sphinxAtStartPar
The default value for the number of threads in the parallel version is set to
one, so that the program is identical with the serial version, except for the
random generator’s initial seed. The user can change the value by either typing
\sphinxcode{\sphinxupquote{setthreads \textless{}nr\textgreater{}}}, where \sphinxcode{\sphinxupquote{\textless{}nr\textgreater{}}} is the number of requested threads (integer
value) in the command line or by adding a corresponding line to the
\sphinxcode{\sphinxupquote{radmc3d.inp}} file. If the chosen number of threads is larger than the
available number of processor cores, the user is asked to reduce it.

\sphinxAtStartPar
For example, you can ask \sphinxcode{\sphinxupquote{radmc3d}} to do the parallelized Monte
Carlo run for you by typing in a shell:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{mctherm} \PYG{n}{setthreads} \PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\sphinxAtStartPar
or by adding the following keyword to the \sphinxcode{\sphinxupquote{radmc3d.inp}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{setthreads} \PYG{o}{=} \PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\sphinxAtStartPar
which means that four threads are used for the thermal Monte Carlo computation.

\sphinxAtStartPar
For the image or spectrum you can do the same: just add \sphinxcode{\sphinxupquote{setthreads 4}} or so
on the command line or put \sphinxcode{\sphinxupquote{setthreads = 4}} into the \sphinxcode{\sphinxupquote{radmc3d.inp}} file.

\sphinxAtStartPar
Make sure that you have included the \sphinxcode{\sphinxupquote{\sphinxhyphen{}fopenmp}} keyword in the \sphinxcode{\sphinxupquote{Makefile}}
and have compiled the whole \sphinxcode{\sphinxupquote{radmc3d}} source code with this additional command
before using the OpenMP parallelized thermal Monte Carlo version (cf. Section
{\hyperref[\detokenize{installation:sec-makeing}]{\sphinxcrossref{\DUrole{std,std-ref}{Compiling the code with ‘make’}}}}).


\section{Overview of input data for dust radiative transfer}
\label{\detokenize{dustradtrans:overview-of-input-data-for-dust-radiative-transfer}}
\sphinxAtStartPar
In order to perform any of the actions described in Sections
{\hyperref[\detokenize{dustradtrans:sec-dust-thermal-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{The thermal Monte Carlo simulation: computing the dust temperature}}}}, {\hyperref[\detokenize{dustradtrans:sec-dust-monochromatic-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Special\sphinxhyphen{}purpose feature: Computing the local radiation field}}}}
or {\hyperref[\detokenize{dustradtrans:sec-dust-ray-tracing}]{\sphinxcrossref{\DUrole{std,std-ref}{Making SEDs, spectra, images for dust continuum}}}}, you must give RADMC\sphinxhyphen{}3D the following
data:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{amr\_grid.inp}}: The grid file (see Section {\hyperref[\detokenize{inputoutputfiles:sec-grid-input}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): amr\_grid.inp}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}}: The global wavelength file (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): wavelength\_micron.inp}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stars.inp}}: The locations and properties of stars (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (mostly required): stars.inp}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dust\_density.inp}}: The spatial distribution of dust on the grid (see
Section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dustopac.inp}}: A file with overall information about the various species of
dust in the model (see Section {\hyperref[\detokenize{inputoutputfiles:sec-opacities}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dustopac.inp and dustkappa\_*.inp or dustkapscatmat\_*.inp or dust\_optnk\_*.inp}}}}).  One of the main pieces
of information here is (a) how many dust species are included in the model
and (b) the tag names of these dust species (see \sphinxcode{\sphinxupquote{dustkappa\_XXX.inp}}
below). The file \sphinxcode{\sphinxupquote{dust\_density.inp}} must contain exactly this number of
density distributions: one density distribution for each dust species.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dustkappa\_XXX.inp}}: One or more dust opacity files (where \sphinxcode{\sphinxupquote{XXX}} should in
fact be a tag name you define, for instance \sphinxcode{\sphinxupquote{dustkappa\_silicate.inp}}). The
labels are listed in the \sphinxcode{\sphinxupquote{dustopac.inp}} file. See Section
{\hyperref[\detokenize{inputoutputfiles:sec-opacities}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dustopac.inp and dustkappa\_*.inp or dustkapscatmat\_*.inp or dust\_optnk\_*.inp}}}} for more information.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_wavelength\_micron.inp (optional)}}: This file is only needed if you
want to create a spectrum at a special set of wavelengths (otherwise use
\sphinxcode{\sphinxupquote{radmc3d sed}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcmono\_wavelength\_micron.inp (optional)}}: This file is only needed if you
want to compute the radiation field inside the model by calling \sphinxcode{\sphinxupquote{radmc3d
mcmono}} (e.g. for photochemistry).

\end{itemize}

\sphinxAtStartPar
Other input files could be required in certain cases, but you will then
be asked about it by RADMC\sphinxhyphen{}3D.


\section{Special\sphinxhyphen{}purpose feature: Computing the local radiation field}
\label{\detokenize{dustradtrans:special-purpose-feature-computing-the-local-radiation-field}}\label{\detokenize{dustradtrans:sec-dust-monochromatic-monte-carlo}}
\sphinxAtStartPar
If you wish to use RADMC\sphinxhyphen{}3D for computing the radiation field \sphinxstyleemphasis{inside}
the model, for instance for computing photochemical rates in a chemical model,
then RADMC\sphinxhyphen{}3D can do so by calling RADMC\sphinxhyphen{}3D in the following way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{mcmono}
\end{sphinxVerbatim}

\sphinxAtStartPar
This computes the mean intensity
\begin{equation*}
\begin{split}J_\nu = \frac{1}{4\pi}\oint I_\nu(\Omega)d\Omega\end{split}
\end{equation*}
\sphinxAtStartPar
(in units of
\(\mathrm{erg}\,\mathrm{s}^{-1}\,\mathrm{cm}^{-2}\,\mathrm{Hz}^{-1}\,\mathrm{ster}^{-1}\))
as a function of the \((x,y,z)\) (cartesian) or \((r,\theta,\phi)\)
(spherical) coordinates at frequencies \(\nu_i\equiv 10^4c/\lambda_i\) where
\(\lambda_i\) are the wavelengths (in \(\mu\)m) specified in the file \sphinxcode{\sphinxupquote{mcmono\_wavelength\_micron.inp}} (same format as the file
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}} which is described in Section
{\hyperref[\detokenize{inputoutputfiles:sec-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): wavelength\_micron.inp}}}}). The results of this computation can be interesting for,
for instance, models of photochemistry.

\sphinxAtStartPar
The file that is produced by \sphinxcode{\sphinxupquote{radmc3d mcmono}} is called
\sphinxcode{\sphinxupquote{mean\_intensity.out}} and has the following form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{2} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{nrcells}
\PYG{n}{nfreq}                                    \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Nr} \PYG{n}{of} \PYG{n}{frequencies}
\PYG{n}{freq\PYGZus{}1} \PYG{n}{freq\PYGZus{}2} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{freq\PYGZus{}nfreq}             \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{List} \PYG{n}{of} \PYG{n}{frequencies} \PYG{o+ow}{in} \PYG{n}{Hz}
\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{n}{nrcells}\PYG{p}{]}
\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{n}{nrcells}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{meanint}\PYG{p}{[}\PYG{n}{nfreq}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{meanint}\PYG{p}{[}\PYG{n}{nfreq}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{meanint}\PYG{p}{[}\PYG{n}{nfreq}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{n}{nrcells}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The list of frequencies will, in fact, be the same as those listed in the file
\sphinxcode{\sphinxupquote{mcmono\_wavelength\_micron.inp}}.

\sphinxAtStartPar
Note that if your model is very large, the computation of the radiation field on
a large set of wavelength could easily overload the memory of the
computer. However, often you are in the end not interested in the entire
spectrum at each location, but just in integrals of this spectrum over some
cross section. For instance, if you want to compute the degree to which dust
shields molecular photodissociation lines in the UV, then you only need to
compute the total photodissociation rate, which is an integral of the
photodissociation cross section times the radiation field. In Section
{\hyperref[\detokenize{internalsetup:sec-compute-radiation-integrals}]{\sphinxcrossref{\DUrole{std,std-ref}{Using the userdef module to compute integrals of J\_\textbackslash{}nu}}}} it will be explained how you can create a
userdef subroutine (see Chapter {\hyperref[\detokenize{internalsetup:chap-internal-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Modifying RADMC\sphinxhyphen{}3D: Internal setup and user\sphinxhyphen{}specified radiative processes}}}}) that will do this
for you in a memory\sphinxhyphen{}saving way.

\sphinxAtStartPar
There is an important parameter for this Monochromatic Monte Carlo that you
may wish to play with:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nphot\_mono}}
The parameter \sphinxcode{\sphinxupquote{nphot\_mono}} sets the number of photon packages
that are used for the Monochromatic Monte Carlo simulation. It has as
default 100000, but that may be too little for 3\sphinxhyphen{}D models. You can set
this value in two ways:
\begin{itemize}
\item {} 
\sphinxAtStartPar
In the \sphinxcode{\sphinxupquote{radmc3d.inp}} file as a line \sphinxcode{\sphinxupquote{nphot\_mono = 1000000}} for instance.

\item {} 
\sphinxAtStartPar
On the command\sphinxhyphen{}line by adding \sphinxcode{\sphinxupquote{nphot\_mono 1000000}}.

\end{itemize}

\end{itemize}


\section{More about scattering of photons off dust grains}
\label{\detokenize{dustradtrans:more-about-scattering-of-photons-off-dust-grains}}\label{\detokenize{dustradtrans:sec-scattering}}
\sphinxAtStartPar
Photons can not only be absorbed and re\sphinxhyphen{}emitted by dust grains: They can also be
scattered. Scattering does nothing else than change the direction of propagation
of a photon, and in case polarization is included, its Stokes
parameters. Strictly speaking it may also slightly change its wavelength, if the
dust grains move with considerable speed they may Doppler\sphinxhyphen{}shift the wavelength
of the outgoing photon (which may be relevant, if at all, when dust radiative
transfer is combined with line radiative transfer, see chapter
{\hyperref[\detokenize{lineradtrans:chap-line-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Line radiative transfer}}}}), but this subtle effect is not treated in
RADMC\sphinxhyphen{}3D. For RADMC\sphinxhyphen{}3D scattering is just the changing of direction of a photon.


\subsection{Five modes of treating scattering}
\label{\detokenize{dustradtrans:five-modes-of-treating-scattering}}\label{\detokenize{dustradtrans:sec-modes-of-scattering}}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D has five levels of realism of treatment of scattering, starting
with \sphinxcode{\sphinxupquote{scattering\_mode=1}} (simplest) to \sphinxcode{\sphinxupquote{scattering\_mode=5}} (most realistic):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{No scattering} (\sphinxcode{\sphinxupquote{scattering\_mode=0}}):

\sphinxAtStartPar
If either the \sphinxcode{\sphinxupquote{dustkappa\_XXX.inp}} files do not contain a scattering opacity
or scattering is switched off by setting \sphinxcode{\sphinxupquote{scattering\_mode\_max}} to 0 in the
\sphinxcode{\sphinxupquote{radmc3d.inp}} file, then scattering is ignored. It is then assumed that the
dust grains have zero albedo.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Isotropic scattering} (\sphinxcode{\sphinxupquote{scattering\_mode=1}}):

\sphinxAtStartPar
If either the \sphinxcode{\sphinxupquote{dustkappa\_XXX.inp}} files do not contain information about the
anisotropy of the scattering or anisotropic scattering is switched off by
setting \sphinxcode{\sphinxupquote{scattering\_mode\_max}} to 1 in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file, then
scattering is treated as isotropic scattering.  Note that this can be a bad
approximation.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Anisotropic scattering using Henyey\sphinxhyphen{}Greenstein} (\sphinxcode{\sphinxupquote{scattering\_mode=2}}):

\sphinxAtStartPar
If the \sphinxcode{\sphinxupquote{dustkappa\_XXX.inp}} files contain the scattering opacity and the
\(g\) parameter of anisotropy (the Henyey\sphinxhyphen{}Greenstein \(g\) parameter
which is equal, by definition, to \(g=\langle\cos\theta\rangle\), where
\(\theta\) is the scattering deflection angle), and
\sphinxcode{\sphinxupquote{scattering\_mode\_max}} is set to 2 or higher in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file then
anisotropic scattering is treated using the Henyey\sphinxhyphen{}Greenstein approximate
formula.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Anisotropic scattering using tabulated phase function} (\sphinxcode{\sphinxupquote{scattering\_mode=3}}):

\sphinxAtStartPar
To treat scattering using a tabulated phase function, you must specify the
dust opacities using \sphinxcode{\sphinxupquote{dustkapscatmat\_XXX.inp}} files instead of the simpler
\sphinxcode{\sphinxupquote{dustkappa\_XXX.inp}} files (see Section {\hyperref[\detokenize{inputoutputfiles:sec-dustkapscatmat-files}]{\sphinxcrossref{\DUrole{std,std-ref}{The dustkapscatmat\_*.inp files}}}}). You
must also set \sphinxcode{\sphinxupquote{scattering\_mode\_max}} is set to 3 or higher.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Anisotropic scattering with polarization for last scattering} (\sphinxcode{\sphinxupquote{scattering\_mode=4}}):

\sphinxAtStartPar
To treat scattering off randomly oriented particles with the full polarization
you need to set \sphinxcode{\sphinxupquote{scattering\_mode\_max}} is set to 4 or higher, and you must
specify the full dust opacity and scattering matrix using the
\sphinxcode{\sphinxupquote{dustkapscatmat\_XXX.inp}} files instead of the simpler \sphinxcode{\sphinxupquote{dustkappa\_XXX.inp}}
files (see Section {\hyperref[\detokenize{inputoutputfiles:sec-dustkapscatmat-files}]{\sphinxcrossref{\DUrole{std,std-ref}{The dustkapscatmat\_*.inp files}}}}). If \sphinxcode{\sphinxupquote{scattering\_mode=4}}
the full polarization is only done upon the last scattering before light
reaches the observer (i.e. it is only treated in the computation of the
scattering source function that is used for the images, but it is not used for
the movement of the photons in the Monte Carlo simulation).  See Section
{\hyperref[\detokenize{dustradtrans:sec-polarized-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{Polarization, Stokes vectors and full phase\sphinxhyphen{}functions}}}} for more information about polarized
scattering.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Anisotropic scattering with polarization, full treatment} (\sphinxcode{\sphinxupquote{scattering\_mode=5}}):

\sphinxAtStartPar
For the full treatment of polarized scattering off randomly oriented
particles, you need to set \sphinxcode{\sphinxupquote{scattering\_mode\_max}} is set to 5, and you must
specify the full dust opacity and scattering matrix using the
\sphinxcode{\sphinxupquote{dustkapscatmat\_XXX.inp}} files instead of the simpler \sphinxcode{\sphinxupquote{dustkappa\_XXX.inp}}
files (see Section {\hyperref[\detokenize{inputoutputfiles:sec-dustkapscatmat-files}]{\sphinxcrossref{\DUrole{std,std-ref}{The dustkapscatmat\_*.inp files}}}}).  See Section
{\hyperref[\detokenize{dustradtrans:sec-polarized-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{Polarization, Stokes vectors and full phase\sphinxhyphen{}functions}}}} for more information about polarized
scattering.  end\{enumerate\} Please refer to Sections
{\hyperref[\detokenize{dustradtrans:sec-scat-phasefunc}]{\sphinxcrossref{\DUrole{std,std-ref}{Scattering phase functions}}}} and {\hyperref[\detokenize{dustradtrans:sec-polarized-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{Polarization, Stokes vectors and full phase\sphinxhyphen{}functions}}}} for more
information about these different scattering modes.

\end{itemize}

\sphinxAtStartPar
So in summary: the dust opacity files themselves tell how detailed the
scattering is going to be included. If no scattering information is present in
these files, RADMC\sphinxhyphen{}3D has no choice but to ignore scattering. If they only
contain scattering opacities but no phase information (no \(g\)\sphinxhyphen{}factor),
then RADMC\sphinxhyphen{}3D will treat scattering in the isotropic approximation. If the
\(g\)\sphinxhyphen{}factor is also included, then RADMC\sphinxhyphen{}3D will use the Henyey\sphinxhyphen{}Greenstein
formula for anisotropic scattering. If you specify the full scattering matrix
(using the \sphinxcode{\sphinxupquote{dustkapscatmat\_XXX.inp}} files instead of the \sphinxcode{\sphinxupquote{dustkappa\_XXX.inp}}
files) then you can use tabulated scattering phase functions, and even polarized
scattering.

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{scattering\_mode\_max}} is \sphinxstyleemphasis{not} set in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file, it is by
default 9999, meaning: RADMC\sphinxhyphen{}3D will always use the maximally realistic
scattering mode that the dust opacities allow.

\sphinxAtStartPar
BUT you can always limit the realism of scattering by setting the
\sphinxcode{\sphinxupquote{scattering\_mode\_max}} to 4, 3, 3, 1 or 0 in the file \sphinxcode{\sphinxupquote{radmc3d.inp}}. This can
be useful to speed up the calculations or be sure to avoid certain complexities
of the full phase\sphinxhyphen{}function treatment of scattering.

\sphinxAtStartPar
At the moment there are some limitations to the full anisotropic scattering
treatment:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Anisotropic scattering in 1\sphinxhyphen{}D and 2\sphinxhyphen{}D Spherical coordinates:}

\sphinxAtStartPar
For 1\sphinxhyphen{}D spherical coordinates there is currently no possibility of treating
anisotropic scattering in the image\sphinxhyphen{} and spectrum\sphinxhyphen{}making. The reason is that
the scattering source function (see Section {\hyperref[\detokenize{dustradtrans:sec-scat-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Scattered light in images and spectra: The ‘Scattering Monte Carlo’ computation}}}}) must
be stored in an angle\sphinxhyphen{}dependent way.  However, for 2\sphinxhyphen{}D spherical coordinates,
this has been implemented, and for each grid ‘cell’ (actually an annulus) the
scattering source function is now stored for an entire sequence of angles.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Full phase functions and polarization only for randomly\sphinxhyphen{}oriented particles:}

\sphinxAtStartPar
Currently RADMC\sphinxhyphen{}3D cannot handle scattering off fixed\sphinxhyphen{}oriented non\sphinxhyphen{}spherical
particles, because it requires a much more detailed handling of the angles. It
would require at least 3 scattering angles (for axially\sphinxhyphen{}symmetric particles)
or more (for completely asymmetric particles), which is currently beyond the
scope of RADMC\sphinxhyphen{}3D.

\end{itemize}


\subsection{Scattering phase functions}
\label{\detokenize{dustradtrans:scattering-phase-functions}}\label{\detokenize{dustradtrans:sec-scat-phasefunc}}
\sphinxAtStartPar
As mentioned above, for the different \sphinxcode{\sphinxupquote{scattering\_mode}} settings
you have different levels of realism of treating scattering.

\sphinxAtStartPar
The transfer equation along each ray, ignoring polarization for now, is:

\phantomsection\label{\detokenize{dustradtrans:eq-ray-tracing-rt}}\begin{equation*}
\begin{split}\frac{dI_\nu}{ds} = j_\nu^{\mathrm{therm}} + j_\nu^{\mathrm{scat}}
- (\alpha_\nu^{\mathrm{abs}}+\alpha_\nu^{\mathrm{scat}}) I_\nu\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\alpha_\nu^{\mathrm{abs}}\) and \(\alpha_\nu^{\mathrm{scat}}\) are the
extinction coefficients for absorption and scattering.  Let us assume, for
convenience of notation, that we have just one dust species with density
dstribution \(\rho\), absorption opacity \(\kappa_\nu^{\mathrm{abs}}\) and
scattering opacity \(\kappa_\nu^{\mathrm{scat}}\). We then have

\phantomsection\label{\detokenize{dustradtrans:eq-thermal-source-function}}\begin{equation*}
\begin{split}\begin{split}
\alpha_\nu^{\mathrm{abs}} &\equiv \rho\kappa_\nu^{\mathrm{abs}}\\
\alpha_\nu^{\mathrm{scat}} &\equiv \rho\kappa_\nu^{\mathrm{scat}}\\
j_\nu^{\mathrm{therm}} &= \alpha_\nu^{\mathrm{abs}} B_\nu(T)
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(B_\nu(T)\) is the Planck function. The last equation is an
expression of Kirchhoff’s law.

\sphinxAtStartPar
For \sphinxstyleemphasis{isotropic} scattering (\sphinxcode{\sphinxupquote{scattering\_mode=1}}) the
scattering source function \(j_\nu^{\mathrm{scat}}\) is given by
\begin{equation*}
\begin{split}j_\nu^{\mathrm{scat}} = \alpha_\nu^{\mathrm{scat}} \frac{1}{4\pi}\oint I_\nu d\Omega\end{split}
\end{equation*}
\sphinxAtStartPar
where the integral is the integral over solid angle. In this case
\(j_\nu^{\mathrm{scat}}\) does not depend on solid angle.

\sphinxAtStartPar
For \sphinxstyleemphasis{anisotropic} scattering (\sphinxcode{\sphinxupquote{scattering\_mode\textgreater{}1}}) we
must introduce the scattering phase function
\(\Phi({\bf n}_{\mathrm{in}}, {\bf n}_{\mathrm{out}})\), where
\({\bf n}_{\mathrm{in}}\) is the unit direction vector for incoming radiation
and \({\bf n}_{\mathrm{out}}\) is the unit direction vector for the scattered
radiation. The
scattering phase function is normalized to unity:
\begin{equation*}
\begin{split}\frac{1}{4\pi}\oint\Phi({\bf n}_{\mathrm{in}},
{\bf n}_{\mathrm{out}}) d\Omega_{\mathrm{out}}
=\frac{1}{4\pi}\oint\Phi({\bf n}_{\mathrm{in}},
{\bf n}_{\mathrm{out}}) d\Omega_{\mathrm{in}}=1\end{split}
\end{equation*}
\sphinxAtStartPar
where we integrated over all possible \({\bf n}_{\mathrm{out}}\) or
\({\bf n}_{\mathrm{in}}\).
Then the scattering source function becomes:
\begin{equation*}
\begin{split}\begin{split}
j_\nu^{\mathrm{scat}}({\bf n}_{\mathrm{out}}) =
\alpha_\nu^{\mathrm{scat}} \frac{1}{4\pi}\oint I_\nu({\bf n}_{\mathrm{in}})
\Phi({\bf n}_{\mathrm{in}},{\bf n}_{\mathrm{out}}) d\Omega_{\mathrm{in}}
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
which is angle\sphinxhyphen{}dependent. The angular dependence means: a photon package has not
completely forgotten from which direction it came before hitting the dust grain.

\sphinxAtStartPar
If we do not include the polarization of radiation and we have randomly oriented
particles, then the scattering phase function will only depend on the scattering
(deflection) angle \(\theta\) defined by
\begin{equation*}
\begin{split}\cos\theta \equiv \mu = {\bf n}_{\mathrm{out}}\cdot {\bf n}_{\mathrm{in}}\end{split}
\end{equation*}
\sphinxAtStartPar
We will thus be able to write
\begin{equation*}
\begin{split}\Phi({\bf n}_{\mathrm{in}},{\bf n}_{\mathrm{out}})
\equiv \Phi(\mu)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Phi(\mu)\) is normalized as
\begin{equation*}
\begin{split}\frac{1}{2}\int_{-1}^{+1} \Phi(\mu) d\mu = 1\end{split}
\end{equation*}
\sphinxAtStartPar
If we have \sphinxcode{\sphinxupquote{scattering\_mode=2}} then the phase function is
the Henyey\sphinxhyphen{}Greenstein phase function defined as
\begin{equation*}
\begin{split}\Phi(\mu)=\frac{1-g^2}{(1+g^2-2g\mu)^{3/2}}\end{split}
\end{equation*}
\sphinxAtStartPar
where the value of the anisotropy parameter \(g\) is taken from the dust
opacity file. Note that for \(g=0\) you get \(\Phi(\mu)=1\) which is the
phase function for isotropic scattering.

\sphinxAtStartPar
If we have \sphinxcode{\sphinxupquote{scattering\_mode=3}} then the phase function is
tabulated by you. You have to provide the tabulated phase function as the
\(Z_{11}(\theta)\) scattering matrix element for a tabulated set of \(\theta_i\)
values, and this is done in a file \sphinxcode{\sphinxupquote{dustkapscatmat\_xxx.inp}} (see
Section {\hyperref[\detokenize{inputoutputfiles:sec-dustkapscatmat-files}]{\sphinxcrossref{\DUrole{std,std-ref}{The dustkapscatmat\_*.inp files}}}} and note that for \sphinxcode{\sphinxupquote{scattering\_mode=3}}
the other \(Z_{ij}\) elements can be kept 0 as they are
of no consequence). The relation between \(Z_{11}(\theta)\) and
\(\Phi(\mu)\) is:
\begin{equation*}
\begin{split}\Phi(\mu) \equiv \Phi(\cos(\theta)) = \frac{4\pi}{\kappa_{\mathrm{scat}}}\,Z_{11}(\theta)\end{split}
\end{equation*}
\sphinxAtStartPar
(which holds at each wavelength individually).

\sphinxAtStartPar
If we have \sphinxcode{\sphinxupquote{scattering\_mode=4}} then the scattering in the Monte Carlo code is
done according to the tabulated \(\Phi(\mu)\) mode mentioned above, but for
computing the scattering source function the full polarized scattering matrix is
used. See Section {\hyperref[\detokenize{dustradtrans:sec-polarized-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{Polarization, Stokes vectors and full phase\sphinxhyphen{}functions}}}}.

\sphinxAtStartPar
If we have \sphinxcode{\sphinxupquote{scattering\_mode=5}} then the scattering phase function is not only
dependent on \(\mu\) but also on the other angle.  And it depends on the
polarization state of the input radiation. See Section
{\hyperref[\detokenize{dustradtrans:sec-polarized-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{Polarization, Stokes vectors and full phase\sphinxhyphen{}functions}}}}.


\section{Scattering of photons in the Thermal Monte Carlo run}
\label{\detokenize{dustradtrans:scattering-of-photons-in-the-thermal-monte-carlo-run}}\label{\detokenize{dustradtrans:sec-scat-in-therm-mc}}
\sphinxAtStartPar
So how is scattering treated in practice? In the thermal Monte Carlo model
(Section {\hyperref[\detokenize{dustradtrans:sec-dust-thermal-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{The thermal Monte Carlo simulation: computing the dust temperature}}}}) the scattering has only one
effect: it changes the direction of propagation of the photon packages whenever
such a photon package experiences a scattering event. This may change the
results for the dust temperatures subtly. In special cases it may even change
the dust temperatures more strongly, for instance if scattering allows ‘hot’
photons to reach regions that would have otherwise been in the shadow. It may
also increase the optical depth of an object and thus change the temperatures
accordingly. But this is all there is to it.

\sphinxAtStartPar
If you include the full treatment of polarized scattering
(\sphinxcode{\sphinxupquote{scattering\_mode=5}}), then a photon package also gets polarized when it
undergoes a scattering event. This can affect the phase function for the next
scattering event. This means that the inclusion of the full polarized scattering
processes (as opposed to using non\sphinxhyphen{}polarized photon packages) can, at least in
principle, have an effect on the dust temperatures that result from the thermal
Monte Carlo computation. This effect is, however, rather small in practice.


\section{Scattering of photons in the Monochromatic Monte Carlo run}
\label{\detokenize{dustradtrans:scattering-of-photons-in-the-monochromatic-monte-carlo-run}}\label{\detokenize{dustradtrans:sec-scat-in-mono-mc}}
\sphinxAtStartPar
For the monochromatic Monte Carlo calculation for computing the mean intensity
radiation field (Section {\hyperref[\detokenize{dustradtrans:sec-dust-monochromatic-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Special\sphinxhyphen{}purpose feature: Computing the local radiation field}}}}) the
scattering has the same effect as for the thermal Monte Carlo model: it changes
the direction of photon packages. In this way ‘hot’ radiation may enter regions
which would otherwise have been in a shadow. And by increasing the optical depth
of regions, it may increase the local radiation field by the greenhouse effect
or decrease it by preventing photons from entering it. As in the thermal Monte
Carlo model the effect of scattering in the monochromatic Monte Carlo model is
simply to change the direction of motion of the radiation field, but for the
rest nothing differs to the case without scattering. Also here the small effects
caused by polarized scattering apply, like in the thermal Monte Carlo case.


\subsection{Scattered light in images and spectra: The ‘Scattering Monte Carlo’ computation}
\label{\detokenize{dustradtrans:scattered-light-in-images-and-spectra-the-scattering-monte-carlo-computation}}\label{\detokenize{dustradtrans:sec-scat-monte-carlo}}
\sphinxAtStartPar
For making images and spectra with the ray\sphinxhyphen{}tracing capabilities of RADMC\sphinxhyphen{}3D (see
Section {\hyperref[\detokenize{dustradtrans:sec-dust-ray-tracing}]{\sphinxcrossref{\DUrole{std,std-ref}{Making SEDs, spectra, images for dust continuum}}}} and Chapter {\hyperref[\detokenize{imagesspectra:chap-images-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making images and spectra}}}}) the
role of scattering is a much more complex one than in the thermal and
monochromatic Monte Carlo runs. The reason is that the scattered radiation will
eventually end up on your images and spectra.

\sphinxAtStartPar
If we want to make an image or a spectrum, then for each pixel we must integrate
Eq. (\sphinxcode{\sphinxupquote{eq\sphinxhyphen{}ray\sphinxhyphen{}tracing\sphinxhyphen{}rt}}) along the 1\sphinxhyphen{}D ray belonging to that pixel. If we
performed the thermal Monte Carlo simulation beforehand (or if we specified the
dust temperatures by hand) we know the thermal source function through
Eq. (\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}thermal\sphinxhyphen{}source\sphinxhyphen{}function}). But we have, at that point, no
information yet about the scattering source function. The thermal Monte Carlo
calculation \{em could\} have also stored this function at each spatial point and
each wavelength and each observer direction, but that would require gigantic
amounts of memory (for a typical 3\sphinxhyphen{}D model it might be many Gbytes, going into
the Tbyte regime). So in RADMC\sphinxhyphen{}3D the scattering source function is \{em not\}
computed during the thermal Monte Carlo run.

\sphinxAtStartPar
In RADMC\sphinxhyphen{}3D the scattering source function \(j_\nu^{\mathrm{scat}}(\Omega')\)
is computed \{em just prior to\} the ray\sphinxhyphen{}tracing through a brief ‘Scattering
Monte Carlo’ run. This is done \{em automatically\} by RADMC\sphinxhyphen{}3D, so you
don’t have to worry about this. Whenever you ask RADMC\sphinxhyphen{}3D to make an image
(and if the scattering is in fact included in the model, see Section
{\hyperref[\detokenize{dustradtrans:sec-modes-of-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{Five modes of treating scattering}}}}), RADMC\sphinxhyphen{}3D will automatically realize that it
requires knowledge of \(j_\nu^{\mathrm{scat}}(\Omega')\), and it will start a
brief single\sphinxhyphen{}wavelength Monte Carlo simulation for computing
\(j_\nu^{\mathrm{scat}}(\Omega')\). This single\sphinxhyphen{}wavelength ‘Scattering Monte
Carlo’ simulation is relatively fast compared to the thermal Monte Carlo
simulation, because photon packages can be destroyed by absorption. So
photon packages do not bounce around for long, as they do in the thermal
Monte Carlo simulation.  This Scattering Monte Carlo simulation is in fact
very similar to the monochromatic Monte Carlo model described in Section
{\hyperref[\detokenize{dustradtrans:sec-dust-monochromatic-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Special\sphinxhyphen{}purpose feature: Computing the local radiation field}}}}. While the monochromatic Monte
Carlo model is called specifically by the user (by calling RADMC\sphinxhyphen{}3D with
\sphinxcode{\sphinxupquote{radmc3d mcmono}}), the Scattering Monte Carlo simulation is not
something the user must specify him/her\sphinxhyphen{}self: it is automatically done by
RADMC\sphinxhyphen{}3D if it is needed (which is typically before making an image or
during the making of a spectrum). And while the monochromatic Monte Carlo
model returns the mean intensity inside the model, the Scattering Monte Carlo
simulation provides the raytracing routines with the scattering source
function but does \sphinxstyleemphasis{not} store this function in a file.

\sphinxAtStartPar
You can see this happen if you have a model with scattering opacity included,
and you make an image with RADMC\sphinxhyphen{}3D, you see that it prints \sphinxcode{\sphinxupquote{1000}}, \sphinxcode{\sphinxupquote{2000}},
\sphinxcode{\sphinxupquote{3000}}, … etc., in other words, it performs a little Monte Carlo simulation
before making the image.

\sphinxAtStartPar
There is an important parameter for this Scattering Monte Carlo that you
may wish to play with:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nphot\_scat}}

\sphinxAtStartPar
The parameter \sphinxcode{\sphinxupquote{nphot\_scat}} sets the number of photon packages
that are used for the Scattering Monte Carlo simulation. It has as default
100000, but that may be too little for 3\sphinxhyphen{}D models and/or cases where you
wish to reduce the ‘streaky’ features sometimes visible in
scattered\sphinxhyphen{}light images when too few photon packages are used. You can
set this value in two ways:
\begin{itemize}
\item {} 
\sphinxAtStartPar
In the \sphinxcode{\sphinxupquote{radmc3d.inp}} file as a line \sphinxcode{\sphinxupquote{nphot\_scat = 1000000}} for instance.

\item {} 
\sphinxAtStartPar
On the command\sphinxhyphen{}line by adding \sphinxcode{\sphinxupquote{nphot\_scat 1000000}}.

\end{itemize}

\sphinxAtStartPar
In Figure \hyperref[\detokenize{dustradtrans:fig-polscat}]{Fig.\@ \ref{\detokenize{dustradtrans:fig-polscat}}} you can see how the quality of an image in
scattered light improves when increasing \sphinxcode{\sphinxupquote{nphot\_scat}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nphot\_spec}}

\sphinxAtStartPar
The parameter \sphinxcode{\sphinxupquote{nphot\_spec}} is actually exactly the same as
\sphinxcode{\sphinxupquote{nphot\_scat}}, but is used (and used only!) for the creation of
spectra. The default is 10000, i.e. substantially smaller than \sphinxcode{\sphinxupquote{nphot\_scat}}.
The reason for this separate parameter is that if you make
spectra, you integrate over the image to obtain the flux (i.e. the value of
the spectrum at that wavelength). Even if the scattered light image may
look streaky, the integral may still be accurate. We can thus afford much
fewer photon packages when we make spectra than when we make images, and
can thus speed up the calculation of the spectrum. You can set this value
in two ways:
\begin{itemize}
\item {} 
\sphinxAtStartPar
In the \sphinxcode{\sphinxupquote{radmc3d.inp}} file as a line \sphinxcode{\sphinxupquote{nphot\_spec = 100000}} for instance.

\item {} 
\sphinxAtStartPar
On the command\sphinxhyphen{}line by adding \sphinxcode{\sphinxupquote{nphot\_spec 100000}}.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE:} It may be possible to get still very good results with even
smaller values of \sphinxcode{\sphinxupquote{nphot\_spec}} than the default value of
10000. That might speed up the calculation of the spectrum even more in some
cases. On the other hand, if you notice ‘noise’ on your spectrum, you may want
to increase \sphinxcode{\sphinxupquote{nphot\_spec}}. If you are interested in an optimal balance
between accuracy (high value of \sphinxcode{\sphinxupquote{nphot\_spec}}) and speed of calculation (low
value of \sphinxcode{\sphinxupquote{nphot\_spec}}) then it is recommended to experiment with this value.
If you want to be on the safe side, then set \sphinxcode{\sphinxupquote{nphot\_spec}} to a high value
(i.e. set it to 100000, as \sphinxcode{\sphinxupquote{nphot\_spec}}).

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{polscat}.pdf}
\caption{The effect of \sphinxcode{\sphinxupquote{nphot\_scat}} on the image quality when the image is dominated
by scattered light. The images show the result of model
\sphinxcode{\sphinxupquote{examples/run\_simple\_2\_scatmat}} at \(\lambda=0.84\mu\)m in which
polarized scattering with the full scattering phase function and scattering
matrix is used. See Section {\hyperref[\detokenize{dustradtrans:sec-polarized-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{Polarization, Stokes vectors and full phase\sphinxhyphen{}functions}}}} about the
scattering matrices for polarized scattering. See Section
{\hyperref[\detokenize{dustradtrans:sec-single-multiple-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{Single\sphinxhyphen{}scattering vs. multiple\sphinxhyphen{}scattering}}}} for a discussion about the ‘scratches’
seen in the top two panels.}\label{\detokenize{dustradtrans:id1}}\label{\detokenize{dustradtrans:fig-polscat}}\end{figure}

\sphinxAtStartPar
\sphinxstyleemphasis{WARNING:} At wavelengths where the dominant source of photons is thermal dust
emission but scattering is still important (high albedo), it cannot be excluded
that the ‘scattering monte carlo’ method used by RADMC\sphinxhyphen{}3D produces very large
noise. Example: a very optically thick dust disk consisting of large grains (10
\(\mu\)m size), producing thermal dust emission in the near infrared in its
inner disk regions. This thermal radiation can scatter off the large dust grains
at large radii (where the disk is cold and where the only ‘emission’ in the
near\sphinxhyphen{}infrared is thus the scattered light) and thus reveal the outer disk in
scattered light emerging from the inner disk. However, unless \sphinxcode{\sphinxupquote{nphot\_scat}} is
huge, most thermally emitted photons from the inner disk will be emitted so
deeply in the disk interior (i.e. below the surface) that they will be
immediately reabsorbed and lost. This means that that radiation that does escape
is extremely noisy. The corresponding scattered light source function at large
radii is therefore very noisy as well, unless \sphinxcode{\sphinxupquote{nphot\_scat}} is taken to be
huge. Currently no elegant solution is found, but maybe there will in the
future. Stay tuned…

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE:} Monte Carlo simulations are based on pseudo\sphinxhyphen{}random numbers.
The seed for the random number generator is by default set to \sphinxhyphen{}17933201.
If you want to perform multiple identical simulations with a different
random sequence you will need to set the seed by hand. This can be
done by adding a line

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iseed} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5415}
\end{sphinxVerbatim}

\sphinxAtStartPar
(where \sphinxhyphen{}5415 is to be replaced by the value you want) to the \sphinxcode{\sphinxupquote{radmc3d.inp}} file.


\subsection{Single\sphinxhyphen{}scattering vs. multiple\sphinxhyphen{}scattering}
\label{\detokenize{dustradtrans:single-scattering-vs-multiple-scattering}}\label{\detokenize{dustradtrans:sec-single-multiple-scattering}}
\sphinxAtStartPar
If scattering is included in the images and spectra, the Monte Carlo run
computes the full multiple\sphinxhyphen{}scattering problem. Photon packages are followed as
they scatter and change their direction (possibly many times) until they escape
to infinity or until they are extincted by many orders of magnitude (the exact
extinction limit can be set by \sphinxcode{\sphinxupquote{mc\_scat\_maxtauabs}}, which by default is set to
30, meaning a photon package is considered extincted when it has travelled an
absorption optical depth of 30).

\sphinxAtStartPar
\sphinxstylestrong{Important note:} \sphinxstyleemphasis{In many (most?) cases this default value of}
\sphinxcode{\sphinxupquote{mc\_scat\_maxtauabs=30}} \sphinxstyleemphasis{is overly conservative. Especially
when the scattering Monte Carlo is very time\sphinxhyphen{}consuming, you may want
to experiment with a lower value. Try adding a line to the}
\sphinxcode{\sphinxupquote{radmc3d.inp}} \sphinxstyleemphasis{with}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mc\PYGZus{}scat\PYGZus{}maxtauabs} \PYG{o}{=} \PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{This may speed up the scattering Monte Carlo by up to a factor
of 6, while still yielding reasonable results.}

\sphinxAtStartPar
It can be useful to figure out how important the effect of
multiple scattering in an image is compared to single scattering. For
instance: a protoplanetary disk with a ‘self\sphinxhyphen{}shadowed’ geometry will
show some scattering even in the shadowed region because some photon
packages scatter \{em into\} the shadowed region and then scatter into
the line of sight. To figure out if this is indeed what happens, you
can make two images: one normal image with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mf}{1.0}
\PYG{n}{cp} \PYG{n}{image}\PYG{o}{.}\PYG{n}{out} \PYG{n}{image\PYGZus{}fullscat}\PYG{o}{.}\PYG{n}{out}
\end{sphinxVerbatim}

\sphinxAtStartPar
and then another image which only treats single scattering:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mf}{1.0} \PYG{n}{maxnrscat} \PYG{l+m+mi}{1}
\PYG{n}{cp} \PYG{n}{image}\PYG{o}{.}\PYG{n}{out} \PYG{n}{image\PYGZus{}singlescat}\PYG{o}{.}\PYG{n}{out}
\end{sphinxVerbatim}

\sphinxAtStartPar
The command\sphinxhyphen{}line option \sphinxcode{\sphinxupquote{maxnrscat 1}} tells RADMC\sphinxhyphen{}3D to stop following photon
packages once they hit their first discrete scattering event. You can also check
out the effect of single\sphinxhyphen{} and double\sphinxhyphen{}scattering (but excluding triple and higher
order scattering) with: \sphinxcode{\sphinxupquote{maxnrscat 2}}, etc.

\sphinxAtStartPar
Note that multiple scattering may require a very high number of photon packages
(i.e. setting \sphinxcode{\sphinxupquote{nphot\_scat}} to a very high number). For single scattering with
too low \sphinxcode{\sphinxupquote{nphot\_scat}} you typically see radial ‘rays’ in the image emanating
from each stellar source of photons. For multiple scattering, when taking too
low \sphinxcode{\sphinxupquote{nphot\_scat}} small you would see strange non\sphinxhyphen{}radial ‘scratches’ in the
image (see Fig. \hyperref[\detokenize{dustradtrans:fig-polscat}]{Fig.\@ \ref{\detokenize{dustradtrans:fig-polscat}}}, top two images). It looks as if someone has
used a pen and randomly added some streaks. These streaks are the
double\sphinxhyphen{}scattering events which, in that case, apparently are rare enough that
they show up as individual streaks. To test whether these streaks are indeed
such double scattering events, you can use \sphinxcode{\sphinxupquote{maxnrscat 1}}, and they should
disappear. If the streaks are indeed very few, it may turn out that the
single\sphinxhyphen{}scattering image (\sphinxcode{\sphinxupquote{maxnrscat 1}}) is almost already the correct
image. The double scattering is then only a minor addition to the image, but due
to the finite Monte Carlo noise it would yield annoying streaks which ruin a
nice image. If you are \{em very sure\} that the second scattering and
higher\sphinxhyphen{}order scattering are only a very minor effect, then you might use the
\sphinxcode{\sphinxupquote{maxnrscat 1}} image as the final image. By comparing the flux in the images
with full scattering and single scattering you can estimate how important the
multiple\sphinxhyphen{}scattering contribution is compared to single scattering. But of
course, it is always safer to simply increase \sphinxcode{\sphinxupquote{nphot\_scat}} and patiently wait
until the Monte Carlo run is finished.


\subsubsection{Tip: Analyzing the effect of multiple scattering using \sphinxstyleliteralintitle{\sphinxupquote{selectscat}}}
\label{\detokenize{dustradtrans:tip-analyzing-the-effect-of-multiple-scattering-using-selectscat}}\label{\detokenize{dustradtrans:sec-select-scattering}}
\sphinxAtStartPar
If you are interested in analyzing the role that multiple scattering plays in your
image (as opposed to single scattering), you can ask RADMC\sphinxhyphen{}3D to compute the
scattering source function only for, for instance, the second scattering:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mf}{1.0} \PYG{n}{selectscat} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that this should not be used for production runs, because the image that
is produced is unphysical (it omits the first and third, fourth etc scatterings).
But it can be useful to get a feeling for how important multiple scattering
is, or to investigate if certain features in your image are due to multiple
scattering or not. You can also select only the first scattering:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mf}{1.0} \PYG{n}{selectscat} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
or all scatterings except the first:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mf}{1.0} \PYG{n}{selectscat} \PYG{l+m+mi}{2} \PYG{l+m+mi}{100000}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that if you make an image with \sphinxcode{\sphinxupquote{selectscat}}, the thermal emission from
the dust is still included (as is the case without \sphinxcode{\sphinxupquote{selectscat}}). So if
you want to see \sphinxstyleemphasis{only} the scattered light in the image, you need to manually
set the dust temperature to zero everywhere (in the file \sphinxcode{\sphinxupquote{dust\_temperature.dat}},
see Chapter {\hyperref[\detokenize{inputoutputfiles:chap-input-files}]{\sphinxcrossref{\DUrole{std,std-ref}{Main input and output files of RADMC\sphinxhyphen{}3D}}}}).

\sphinxAtStartPar
Also note that you can use \sphinxcode{\sphinxupquote{selectscat}} also for the monochromatic
Monte Carlo for computing the mean intensity field
(see Section {\hyperref[\detokenize{dustradtrans:sec-dust-monochromatic-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Special\sphinxhyphen{}purpose feature: Computing the local radiation field}}}}).


\subsection{Simplified single\sphinxhyphen{}scattering mode (spherical coordinates)}
\label{\detokenize{dustradtrans:simplified-single-scattering-mode-spherical-coordinates}}\label{\detokenize{dustradtrans:sec-simple-single-scattering}}
\sphinxAtStartPar
If you are sure that multiple scattering is rare (low albedo and/or low optical
depth), then you may be interested in using a simpler (non\sphinxhyphen{}Monte\sphinxhyphen{}Carlo) mode for
including scattering in your images.  But please first read Section
{\hyperref[\detokenize{dustradtrans:sec-single-multiple-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{Single\sphinxhyphen{}scattering vs. multiple\sphinxhyphen{}scattering}}}} and test if multiple scattering is indeed
unimportant. If so, and if you are using spherical coordinates, a single star at
the center which is point\sphinxhyphen{}like, and if you are confident that at the wavelength
you are interested in the thermal dust emission is not strong enough to be a
considerable source of light that can be scattered into the line\sphinxhyphen{}of\sphinxhyphen{}sight
(i.e. all scattered light is scattered \sphinxstyleemphasis{star} light), then you can use the
simplified single\sphinxhyphen{}scattering mode.

\sphinxAtStartPar
This mode does not use the Monte Carlo method to compute the scattering source
function, but instead uses direct integration of the starlight through the
grid. It is much faster than Monte Carlo, and it does not contain noise.

\sphinxAtStartPar
By adding \sphinxcode{\sphinxupquote{simplescat}} to the command line when making an image or spectrum,
you switch this mode on. Please compare first to the single\sphinxhyphen{}scattering Monte
Carlo method (see Section {\hyperref[\detokenize{dustradtrans:sec-single-multiple-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{Single\sphinxhyphen{}scattering vs. multiple\sphinxhyphen{}scattering}}}}; it should yield
very similar result, but without noise) and then to the full multiple scattering
Monte Carlo. The full multiple scattering case will likely produce more flux. If
the difference is large, then you should not use the simple single scattering
mode. However, if the difference is minor, then the single scattering
approximation is reasonable.


\subsection{Warning when using an\sphinxhyphen{}isotropic scattering}
\label{\detokenize{dustradtrans:warning-when-using-an-isotropic-scattering}}
\sphinxAtStartPar
An important issue with anisotropic scattering is that if the phase function is
very forward\sphinxhyphen{}peaked, then you may get problems with the \sphinxstyleemphasis{spatial} resolution
of your model: it could then happen that one grid cell may be too much to the
left to ‘beam’ the scattered light into your line of sight, while the next grid
point will be too much to the right. A proper treatment of strongly anisotropic
scattering therefore requires also a good check of the spatial resolution of
your model. There are, however, also two possible tricks (approximations) to
prevent problems. They both involve slight modifications of the dust opacity
files:
\begin{itemize}
\item {} 
\sphinxAtStartPar
You can simply assure in the opacity files that the forward peaking of
the phase function has some upper limit.

\item {} 
\sphinxAtStartPar
Or you can simply treat extremely forward\sphinxhyphen{}peaked scattering as no
scattering at all (simply setting the scattering opacity to zero at those
wavelengths).

\end{itemize}

\sphinxAtStartPar
Both ‘tricks’ are presumably reasonable and will not affect your results, unless
you concentrate in your modeling very much on the angular dependence of the
scattering.


\subsection{For experts: Some more background on scattering}
\label{\detokenize{dustradtrans:for-experts-some-more-background-on-scattering}}\label{\detokenize{dustradtrans:sec-scat-background}}
\sphinxAtStartPar
The inclusion of the scattering source function in the images and spectra is a
non\sphinxhyphen{}trivial task for RADMC\sphinxhyphen{}3D because of memory constraints. If we would have
infinite random access memory, then the inclusion of scattering in the images
and spectra would be relatively easy, as we could then store the entire
scattering source function \(j^{\mathrm{scat}}(x,y,z,\nu,\Omega)\) and use
what we need at any time. But as you see, this function is a 6\sphinxhyphen{}dimensional
function: three spatial dimensions, one frequency and one angular direction
(which consists of two angles). For any respectable model this function is far
too large to be stored. So nearly all the ‘numerical logistic’ complexity of the
treatment of scattering comes from various ways to deal with this problem. In
principle RADMC\sphinxhyphen{}3D makes the choices of which method to use itself, so the user
is not bothered with it. But depending on which kind of model the user sets up,
the performance of RADMC\sphinxhyphen{}3D may change as a result of this issue.

\sphinxAtStartPar
So here are a few hints as to the internal workings of RADMC\sphinxhyphen{}3D in this
regard. You do not have to read this, but it may help understanding the
performance of RADMC\sphinxhyphen{}3D in various cases.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Scattering in spectra and multi\sphinxhyphen{}wavelength images}

\sphinxAtStartPar
If no scattering is present in the model (see Section
{\hyperref[\detokenize{dustradtrans:sec-modes-of-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{Five modes of treating scattering}}}}), then RADMC\sphinxhyphen{}3D can save time when making
spectra and/or multi\sphinxhyphen{}wavelength images. I will then do each integration of
Eq. (\sphinxcode{\sphinxupquote{eq\sphinxhyphen{}ray\sphinxhyphen{}tracing\sphinxhyphen{}rt}}) directly for all wavelengths at once before
going to the next pixel. This saves some time because RADMC\sphinxhyphen{}3D then has to
calculate the geometric stuff (how the ray moves through the model) just once
for each ray. If, however, scattering is included, the scattering source
function must be computed using the Scattering Monte Carlo computation. Since
for large models it would be too memory consuming (in particular for 3\sphinxhyphen{}D
models) to store this function for all positions \sphinxstyleemphasis{and} all wavelengths, it
must do this calculation one\sphinxhyphen{}by\sphinxhyphen{}one for each wavelength, and calculate the
image for that wavelength, and then go off to the next wavelength. This means
that for each ray (pixel) the geometric computations (where the ray moves
through the model) has to be redone for each new wavelength. This may slow
down the code a bit.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Anisotropic scattering and multi\sphinxhyphen{}viewpoint images}

\sphinxAtStartPar
Suppose we wish to look at an object at one single wavelength, but from a
number of different vantage points. If we have \{em isotropic\} scattering,
then we need to do the Scattering Monte Carlo calculation just once, and we
can make multiple images at different vantage points with the same scattering
source function. This saves time, if you use the ‘movie’ mode of RADMC\sphinxhyphen{}3D
(Section {\hyperref[\detokenize{imagesspectra:sec-movie-mode}]{\sphinxcrossref{\DUrole{std,std-ref}{Multiple vantage points: the ‘Movie’ mode}}}}). However, if the scattering is anisotropic,
then the source function would differ for each vantage point.  In that case
the scattering source function must be recalculated for each vantage
point. There is, deeply hidden in RADMC\sphinxhyphen{}3D, a way to compute scattering source
functions for multiple vantage points within a single Scattering Monte Carlo
run, but for the moment this is not yet activated.  end\{itemize\}

\end{itemize}


\section{Polarization, Stokes vectors and full phase\sphinxhyphen{}functions}
\label{\detokenize{dustradtrans:polarization-stokes-vectors-and-full-phase-functions}}\label{\detokenize{dustradtrans:sec-polarized-scattering}}
\sphinxAtStartPar
The module in RADMC\sphinxhyphen{}3D that deals with polarization
(\sphinxcode{\sphinxupquote{polarization\_module.f90}}) is based on code developed by Michiel Min for his
MCMAX code, and has been used and modified for use in RADMC\sphinxhyphen{}3D with his
permission.

\sphinxAtStartPar
Radiative transfer of polarized radiation is a relatively complex issue. A good
and extensive review on the details of polarization is given in the book by
Mishchenko, Travis \& Lacis, ‘Scattering, Absorption and Emission of Light by
Small Particles’, 2002, Cambridge University Press (also electronically
available on\sphinxhyphen{}line). Another good book (and a classic!)  is the book by Bohren \&
Huffman ‘Absorption and scattering of light by small particles’,
Wiley\sphinxhyphen{}VCH. Finally, the ultimate classic is the book by van de Hulst ‘Light
scattering by small particles’, 1981. For some discussions on how polarization
can be built in into radiative transfer codes, see e.g. Wolf, Voshchinnikov \&
Henning (2002, A\&A 385, 365).

\sphinxAtStartPar
When we wish to include polarization in our model we must follow not just the
intensity \(I\) of light (or equivalently, the energy \(E\) of a photon
package), but the full Stokes vector \((I,Q,U,V)\) (see review above for
definitions, or any textbook on radiation processes). If a photon scatters off a
dust grain, then the scattering angular probability density function depends not
only on the scattering angle \(\mu\), but also on the input state of
polarization, i.e. the values of \((I,Q,U,V)\). And the output polarization
state will be modified. Moreover, even if we would not be interested in
polarization at all, but we \{em do\} want to have a correct scattering phase
function, we need to treat polarization, because a first scattering will
polarize the photon, which will then have different angular scattering
probability in the next scattering event. Normally these effects are very small,
so if we are not particularly interested in polarization, one can usually ignore
this effect without too high a penalty in reliability. But if one wants to be
accurate, there is no way around a full treatment of the \((I,Q,U,V)\).

\sphinxAtStartPar
Interaction between polarized radiation with matter happens through so\sphinxhyphen{}called
Müller matrices, which are \(4\times 4\) matrices that can be multiplied by
the \((I,Q,U,V)\) vector. More on this later.

\sphinxAtStartPar
It is important to distinguish between two situations:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The simplest case (and fortunately applicable in many cases) is if all
dust particles are \sphinxstyleemphasis{randomly oriented}, and there is \sphinxstyleemphasis{no
preferential helicity} of the dust grains (i.e. for each particle shape
there are equal numbers of particles with that shape and with its mirror
copy shape). This is also automatically true if all grains are spherically
symmetric. In this case the problem of polarized radiative transfer
simplifies in several ways:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The scattering Müller matrix simplifies, and contains only 6
independent matrix elements (see later). Moreover, these matrix elements
depend only on a single angle: the scattering angle \(\theta\), and of
course on the wavelength. This means that the amount of information is
small enough that these Müller matrix elements can be stored in
computer memory in tabulated form, so that they do not have to be
calculated real\sphinxhyphen{}time.

\item {} 
\sphinxAtStartPar
The total scattering cross section is independent of the input
polarization state. Only the output radiation (i.e. in which
direction the photon will scatter) depends on the input polarization
state.

\item {} 
\sphinxAtStartPar
The absorption cross section is the same for all components of
the \((I,Q,U,V)\)\sphinxhyphen{}vector. In other words: the absorption Müller
matrix is the usual scalar absorption coefficient times the unit
matrix.

\end{itemize}

\sphinxAtStartPar
The last two points assure that most of the structure of the RADMC\sphinxhyphen{}3D code
for non\sphinxhyphen{}polarized radiation can remain untouched. Only for computing the
new direction and polarization state of a photon after a scattering event
in the Monte Carlo module, as well as for computing the scattering source
function in the Monte Carlo module (for use in the camera module) we must
do extra work. Thermal emission and thermal absorption remain the same,
and computing optical depths remains also the same.

\item {} 
\sphinxAtStartPar
A (much!) more complex situation arises if dust grains are \sphinxstyleemphasis{non\sphinxhyphen{}spherical}
and are somehow \sphinxstyleemphasis{aligned due to external forces}. For
instance, particles tend to align themselves in the interstellar medium if
strong enough magnetic fields are present. Or particles tend to align
themselves due to the combination of gravity and friction if they are in a
planetary/stellar atmosphere. Here are the ways in which things become more
complex:
\begin{itemize}
\item {} 
\sphinxAtStartPar
All the scattering Müller matrix components will become
non\sphinxhyphen{}zero and independent. We will thus get 16 independent variables.

\item {} 
\sphinxAtStartPar
The matrix elements will depend on four angles, of which one can,
in some cases, be removed due to symmetry (e.g. if we have gravity,
there is still a remaining rotational symmetry; same is true of
particles are aligned by a \(\vec B\)\sphinxhyphen{}field; but if both gravity and a
\(\vec B\)\sphinxhyphen{}field are present, this symmetry may get lost). It will in
most practical circumstances not be possible to precalculate the
scattering Müller matrix beforehand and tabulate it, because there
are too many variables. The matrix must be computed on\sphinxhyphen{}the\sphinxhyphen{}fly.

\item {} 
\sphinxAtStartPar
The total scattering cross section now \sphinxstyleemphasis{does} depend on the
polarization state of the input photon, and on the incidence angle.
This means that scattering extinction becomes anisotropic.

\item {} 
\sphinxAtStartPar
Thermal emission and absorption extinction will also no longer
be isotropic. Moreover, they are no longer scalar: they are described
by a non\sphinxhyphen{}trivial Müller matrix.

\end{itemize}

\sphinxAtStartPar
The complexity of this case is rather large. As of version 0.41 we
have included polarized thermal emission by aligned grains (see
Section {\hyperref[\detokenize{dustradtrans:sec-polarized-thermal-emission}]{\sphinxcrossref{\DUrole{std,std-ref}{Polarized emission and absorption by aligned grains}}}}), and we will
implement more of the above mentioned aspects of aligned grains
step by step.

\end{enumerate}


\subsection{Definitions and conventions for Stokes vectors}
\label{\detokenize{dustradtrans:definitions-and-conventions-for-stokes-vectors}}\label{\detokenize{dustradtrans:sec-definitions-stokes}}
\sphinxAtStartPar
There are different conventions for how to set up the coordinate system and
define the Stokes vectors. Our definition follows the IAU 1974 definition as
described in Hamaker \& Bregman (1996) A\&AS 117, pp.161.

\sphinxAtStartPar
In this convention the \(x'\) axis points to the north on the sky, while the
\(y'\) axis points to the east on the sky (but see the ‘important note’
below). The \(z'\) axis points to the observer. This coordinate system is
positively right\sphinxhyphen{}handed. The radiation moves toward positive \(z'\). Angles
in the \((x',y')\) plane are measured counter\sphinxhyphen{}clockwise (angle=0 means
positive \(x'\) direction, angle=\(\pi/2\) means positive \(y'\)
direction).

\sphinxAtStartPar
In the following we will (still completely consistent with the IAU definitions
above, see the ‘important note’ below) define “up” to be positive \(y'\) and
“right” to be positive \(x'\). So, the \((x',y')\) coordinates are in a
plane perpendicular to the photon propagation, and oriented as seen by the
observer of that photon. So the direction of propagation is toward you, while
\(y'\) points up and \(x'\) points to the right, just as one would
normally orient it.

\sphinxAtStartPar
\sphinxstyleemphasis{Important Note}: This is fully equivalent to adjusting the IAU 1974 definition
to have \(x'\) pointing west and \(y'\) pointing north, which is perhaps
more intuitive, since most images in the literature have this orientation. So
for convenience of communication, let us simply adjust the IAU 1974 definition
to have positive \(x'\) (‘right’) pointing west and positive \(y'\)
(‘up’) pointing north.  It will have no further consequences for the definitions
and internal workings of RADMC\sphinxhyphen{}3D because RADMC\sphinxhyphen{}3D does not know what ‘north’
and ‘east’ are.

\sphinxAtStartPar
The \((Q,U)\) definition (linear polarization) is such that a linearly
polarized ray with \(Q=+I\), \(U=V=0\) has the electric field in the
\((x',y')=(1,0)\) direction, while \(Q=-I\), \(U=V=0\) has the
electric field in the \((x',y')=(0,1)\) direction. If we have \(Q=0\),
\(U=+I\), \(V=0\) then the E\sphinxhyphen{}field points in the \(x'=y'\)
direction, while \(Q=0\), \(U=-I\), \(V=0\) the E\sphinxhyphen{}field points in
the \(x'=-y'\) direction (see Figure 1 of Hamaker \& Bregman 1996).

\sphinxAtStartPar
The \((V)\) definition (circular polarization) is such that (quoting
directly from the Hamaker \& Bregman paper): \sphinxstyleemphasis{For right\sphinxhyphen{}handed circularly
polarized radiation, the position angle of the electric vector at any point
increases with time; this implies that the} \(y'\) \sphinxstyleemphasis{component of the field
lags the} \(x'\) \sphinxstyleemphasis{component. Also the electric vectors along the line of sight
form a left\sphinxhyphen{}handed screw. The Stokes} \(V\) \sphinxstyleemphasis{is positive for
right\sphinxhyphen{}handed circular polarization.}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{stokes_and_angles_iaudef}.pdf}
\caption{The definition of the Stokes parameters used in RADMC\sphinxhyphen{}3D, which is consistent
with the IAU 1974 definitions (see Hamaker \& Bregman (1996) A\&AS 117,
pp.161). First panel shows that positive angle means counter\sphinxhyphen{}clockwise. In
the second to fourth panels the fat lines show how the tip of the real
electric field vector goes as a function of time for an observer at a fixed
location in space watching the radiation. The radiation moves toward the
reader. We call the second panel (\(Q=+I\)) ‘horizontally polarized’, the
third panel (\(U=+I\)) ‘diagonally polarized by +45 degrees’ and the
fourth panel (\(V=+I\)) ‘right\sphinxhyphen{}handed circularly polarized’. In the
images produced by RADMC\sphinxhyphen{}3D (\sphinxcode{\sphinxupquote{image.out}}, see Section {\hyperref[\detokenize{inputoutputfiles:sec-image-out}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT: image.out or image\_****.out}}}}
and Fig. \hyperref[\detokenize{imagesspectra:fig-cameraorient}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-cameraorient}}}) the \(x'\) direction is the horizontal
direction and the \(y'\) direction is the vertical direction.}\label{\detokenize{dustradtrans:id2}}\label{\detokenize{dustradtrans:fig-stokes-definition}}\end{figure}

\sphinxAtStartPar
We can put these definitions into the standard formulae:
\begin{equation*}
\begin{split}\begin{split}
Q &= I\cos(2\beta)\cos(2\chi)\\
U &= I\cos(2\beta)\sin(2\chi)\\
V &= I\sin(2\beta)
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
The angle \(\chi\) is the angle of the E\sphinxhyphen{}field in the \((x',y')\)
coordinates, measured counter\sphinxhyphen{}clockwise from \(x'\) (consistent with our
definition of angles). Example: \(\chi\) = 45 deg = \(\pi/4\), then
\(\cos(2\chi)=0\) and \(\sin(2\chi)=1\), meaning that \(Q=0\) and
\(U/I=+1\). Indeed this is consistent with the above definition that
\(U/I=+1\) is \(E_x'=E_y'\).

\sphinxAtStartPar
The angle \(2\beta\) is the phase difference between the
\(y'\)\sphinxhyphen{}component of the E\sphinxhyphen{}field and the \(x'\)\sphinxhyphen{}component of the E\sphinxhyphen{}field
such that for \(0<\beta<\pi/2\) the E\sphinxhyphen{}field rotates in a counter\sphinxhyphen{}clockwise
sense. In other words: the \(y'\)\sphinxhyphen{}wave lags \(2\beta\) behind the
\(x'\) wave. Example: if we have \(\beta=\pi/4\), i.e.
\(2\beta=\pi/2\), then \(\cos(2\beta)=0\) and \(\sin(2\beta)=1\), so
we have \(Q=U=0\) and \(V/I=+1\). This corresponds to the \(y'\)
wave being lagged \(\pi/2\) behind the \(x'\) wave, meaning that we have
a counter\sphinxhyphen{}clockwise rotation. If we use the right\sphinxhyphen{}hand\sphinxhyphen{}rule and point the thumb
into the direction of propagation (toward us) then the fingers indeed point in
counter\sphinxhyphen{}rotating direction, meaning that \(V/I=+1\) is righthanded polarized
radiation.

\sphinxAtStartPar
In terms of the \sphinxstyleemphasis{real} electric fields of a plane monochromatic wave:
\begin{equation*}
\begin{split}\begin{split}
E_x'(t) &= E_h \cos(\omega t-\Delta_h)\\
E_y'(t) &= E_v \cos(\omega t-\Delta_v)
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
(with \(E_h>0\) and \(E_v>0\) and \(\Delta_{h,v}\) are the phase
lags of the components with respect to some arbitrary phase) we can write the
Stokes components as:
\begin{equation*}
\begin{split}\begin{split}
I &= E_h^2 + E_v^2 \\
Q &= E_h^2 - E_v^2\\
U &= 2 E_h E_v \cos(\Delta) \\
V &= 2 E_h E_v \sin(\Delta)
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
with \(\Delta = \Delta_v - \Delta_h = 2\beta\).

\sphinxAtStartPar
In terms of the \{em complex\} electric fields of a plane monochromatic wave
(the sign before the \(i\omega t\) is important):
\begin{equation*}
\begin{split}\begin{split}
E_x'(t) &= E_h e^{i(\Delta_h-\omega t)}\\
E_y'(t) &= E_v e^{i(\Delta_v-\omega t)}
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
(with \(E_h>0\) and \(E_v>0\) real numbers and \(\Delta_{h,v}\) are
the phase lags of the components with respect to some arbitrary phase) we can
write the Stokes components as:
\begin{equation*}
\begin{split}\begin{split}
I &= \langle E_{x'}E_{x'}^{*} + E_{y'}E_{y'}^{*}   \rangle\\
Q &= \langle E_{x'}E_{x'}^{*} - E_{y'}E_{y'}^{*}   \rangle\\
U &= \langle E_{x'}E_{y'}^{*} + E_{y'}E_{x'}^{*}   \rangle\\
V &= i\langle E_{x'}E_{y'}^{*} - E_{y'}E_{x'}^{*}  \rangle
\end{split}\end{split}
\end{equation*}

\subsection{Our conventions compared to other literature}
\label{\detokenize{dustradtrans:our-conventions-compared-to-other-literature}}\label{\detokenize{dustradtrans:sec-stokes-convent-differences}}
\sphinxAtStartPar
The IAU 1974 definition is different from the definitions used in the
Planck mission, for instance. So be careful. There is something said about
this on the website of the healpix software
\sphinxurl{http://healpix.jpl.nasa.gov/html/intronode12.htm} .

\sphinxAtStartPar
Our definition is also different from the Mishchenko book and papers (see
below). Compared to the books of Mishchenko and Bohren \& Huffman, our
definitions are:
\begin{equation*}
\begin{split}\begin{split}
I_{\mathrm{ours}} &=  I_{\mathrm{mishch}}  = I_{\mathrm{bohrenhuffman}} \\
Q_{\mathrm{ours}} &=  Q_{\mathrm{mishch}}  = Q_{\mathrm{bohrenhuffman}} \\
U_{\mathrm{ours}} &=  -U_{\mathrm{mishch}} = -U_{\mathrm{bohrenhuffman}} \\
V_{\mathrm{ours}} &=  -V_{\mathrm{mishch}} = -V_{\mathrm{bohrenhuffman}}
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
As you see: only the \(U\) and \(V\) change sign. For a \(4\times 4\)
Müller matrix \(M\) this means that the \(M_{II}\), \(M_{IQ}\),
\(M_{QI}\), \(M_{QQ}\), as well as the \(M_{UU}\), \(M_{UV}\),
\(M_{VU}\), \(M_{VV}\) stay the same, while \(M_{IU}\),
\(M_{IV}\), \(M_{QU}\), \(M_{QV}\), as well as \(M_{UI}\),
\(M_{UQ}\), \(M_{VI}\), \(M_{VQ}\) components would flip sign.

\sphinxAtStartPar
Compared to Mishchenko, Travis \& Lacis book, what we call \(x'\) they call
\(\theta\) and what we call \(y'\) they call \(\phi\). In their
Figure 1.3 (which describes the definition of the Stokes parameters) they have
the \(\theta\) direction pointing downward, rather than toward the right,
i.e. rotated by 90 degrees clockwise compared to RADMC\sphinxhyphen{}3D. However, since
RADMC\sphinxhyphen{}3D does not know what ‘right’ or ‘down’ are (only what \(x'\) and
\(y'\) are) this rotation is merely a difference in how we plot things in a
figure, and has no consequences for the results, as long as we define how
\(x'\) and \(y'\) are oriented compared to our model (see
Fig. \hyperref[\detokenize{imagesspectra:fig-cameraorient}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-cameraorient}}} where \(x_{\mathrm{image}}\) is our \(x'\)
here and likewise for \(y'\)).

\sphinxAtStartPar
Bohren \& Huffman have the two unit vectors plotted in the following way:
\({\bf e}_{\parallel}\) is plotted horizontally to the left and \({\bf
e}_{\perp}\) is plotted vertically upward. Compared to us, our \(x'\) points
toward \{em minus\} their \({\bf e}_{\parallel}\), while our \(y'\)
points toward their \({\bf e}_{\perp}\), but since they plot their
\({\bf e}_{\parallel}\) to the left, the orientation of our plot and their
plots are consistent (i.e. if they say ‘pointing to the right’, they mean the
same direction as we). But their definition of ‘right\sphinxhyphen{}handed circular
polarization’ (clockwise when seen toward the source of the radiation) is our
‘left handed’.

\sphinxAtStartPar
The book by Wendisch \& Yang ‘Theory of Atmospheric Radiative Transfer’ uses the
same conventions as Bohren \& Huffman, but their basis vector \({\bf
e}_{\parallel}\) is plotted vertically and \({\bf e}_{\perp}\) is plotted
horizontally to the right. This only affects what they call ‘horizontal’ and
‘vertical’ but the math stays the same.

\sphinxAtStartPar
Our definition is identical to the one on the \sphinxstyleemphasis{English} Wikipedia page on Stokes
parameters \sphinxurl{http://en.wikipedia.org/wiki/Stokes\_parameters} (on 2 January 2013),
with the only exception that what they call ‘righthanded’ circularly polarized,
we call ‘lefthanded’. This is just a matter of nomenclature of what is
right/left\sphinxhyphen{}handed, and since RADMC\sphinxhyphen{}3D does not know what ‘right/lefthanded’ is,
this difference has no further consequences. \sphinxstyleemphasis{Note}, however, that the same
Wikipedia page in different languages use different conventions! For instance,
the German version of the page (on 2 January 2013) has the same Q and U
definitions, but has the sign of V flipped.

\sphinxAtStartPar
Note that in RADMC\sphinxhyphen{}3D we have no global definition of the orientation of
\(x'\) and \(y'\) (see e.g. Section
{\hyperref[\detokenize{dustradtrans:sec-orientation-vector-stokes}]{\sphinxcrossref{\DUrole{std,std-ref}{Defining orientation for non\sphinxhyphen{}observed radiation}}}}). If we make an image with RADMC\sphinxhyphen{}3D, then
the horizontal (x\sphinxhyphen{}) direction in the image corresponds to \(x'\) and the
vertical (y\sphinxhyphen{}) direction corresponds to \(y'\), just as one would expect. So
if you obtain an image from RADMC\sphinxhyphen{}3D and all the pixels in the image have
\(Q=I\) and \(U=V=0\), then the electric field points horizontally in
the image.


\subsection{Defining orientation for non\sphinxhyphen{}observed radiation}
\label{\detokenize{dustradtrans:defining-orientation-for-non-observed-radiation}}\label{\detokenize{dustradtrans:sec-orientation-vector-stokes}}
\sphinxAtStartPar
To complete our description of the Stokes parameters we still need to define in
which direction we let \(x'\) and \(y'\) point if we do \sphinxstyleemphasis{not} have an
obvious observer, i.e. for radiation moving through our object of interest which
may never reach us. In the Monte Carlo modules of RADMC\sphinxhyphen{}3D, when polarization is
switched on, any photon package does not only have a wavelength \(\lambda\)
and a direction of propagation \({\bf n}\) associated with it, but also a
second unit vector \({\bf S}\), which is always assured to obey:
\begin{equation*}
\begin{split}|{\bf S}| = 1 \qquad \hbox{and} \qquad {\bf S}\cdot{\bf n}=0\end{split}
\end{equation*}
\sphinxAtStartPar
This leaves, for a given \({\bf n}\), one degree of freedom (any direction
as long as it is perpendicular to \({\bf n}\)). It is irrelevant which
direction is chosen for this, but whatever choice is made, it sets the
definitions of the \(x'\) and \(y'\) directions. The definitions are:
\begin{equation*}
\begin{split}\begin{split}
x' &= \quad\hbox{points in the direction}\quad {\bf S}\times {\bf n}\\
y' &= \quad\hbox{points in the direction}\quad {\bf S}\\
z' &= \quad\hbox{points in the direction}\quad {\bf n}
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
So for \(Q=-I\), \(U=V=0\) the electric field points in the direction of
\({\bf S}\), while for \(Q=+I\), \(U=V=0\) it is perpendicular to
both \({\bf n}\) and \({\bf S}\).

\sphinxAtStartPar
However, if you are forced to change the direction of \({\bf S}\) for whatever
reason, the Stokes components will also change. This coordinate transformation
works as follows.
We can transform from a ‘\sphinxhyphen{}basis to a ‘’\sphinxhyphen{}basis by rotating the \({\bf S}\)\sphinxhyphen{}vector
counter\sphinxhyphen{}clockwise (as seen by the observer watching the radiation) by an
angle \(\alpha\). Any vector \((x',y')\) in the ‘\sphinxhyphen{}basis will become a vector
\((x'',y'')\) in a ‘’\sphinxhyphen{}basis, given by the transformation:
\begin{equation*}
\begin{split}\left(\begin{matrix}
x''\\y''
\end{matrix}\right)
=
\left(\begin{matrix}
\cos(\alpha) & \sin(\alpha)\\
-\sin(\alpha) & \cos(\alpha)
\end{matrix}\right)
\left(\begin{matrix}
x'\\y'
\end{matrix}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
NOTE: We choose \((x',y')\) to be the usual counter\sphinxhyphen{}clockwise basis for the
observer seeing the radiation. Rotating the basis in counter\sphinxhyphen{}clockwise direction
means rotating the vector in that basis in clockwise direction, hence the sign
convention in the matrix.

\sphinxAtStartPar
If we have \((I,Q,U,V)\) in the ‘\sphinxhyphen{}basis (which we might have written as
\((I',Q',U',V')\) but by convention we drop the ‘), the
\((I'',Q'',U'',V'')\) in the ‘’\sphinxhyphen{}basis becomes
\begin{equation*}
\begin{split}\left(\begin{matrix}
I''\\Q''\\U''\\V''
\end{matrix}\right)
=
\left(\begin{matrix}
1 & 0 & 0 & 0 \\
0 & \cos(2\alpha) & \sin(2\alpha) & 0 \\
0 & -\sin(2\alpha) & \cos(2\alpha) & 0 \\
0 & 0 & 0 & 1
\end{matrix}\right)
\left(\begin{matrix}
I\\Q\\U\\V
\end{matrix}\right)\end{split}
\end{equation*}

\subsection{Polarized scattering off dust particles: general formalism}
\label{\detokenize{dustradtrans:polarized-scattering-off-dust-particles-general-formalism}}
\sphinxAtStartPar
Suppose we have \sphinxstyleemphasis{one} dust particle of mass \(m_{\mathrm{grain}}\) and we
place it at location \({\bf x}\). Suppose this particle is exposed to a
plane wave of electromagnetic radiation pointing in direction \({\bf
n}_{\mathrm{in}}\) with a flux \({\bf F}_{\mathrm{in}}=F_{\mathrm{in}}\,{\bf
n}_{\mathrm{in}}\). This radiation can be polarized, so that
\(F_{\mathrm{in}}\) actually is a Stokes vector:
\begin{equation*}
\begin{split}F_{\mathrm{in}} = \left(\begin{matrix}
F_{I,\mathrm{in}}\\
F_{Q,\mathrm{in}}\\
F_{U,\mathrm{in}}\\
F_{V,\mathrm{in}}
\end{matrix}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
This particle will scatter some of this radiation into all directions.
What will the flux of scattered radiation be, as observed at location
\({\bf y}\neq{\bf x}\)? Let us define the vector
\begin{equation*}
\begin{split}{\bf r} = {\bf y} - {\bf x}\end{split}
\end{equation*}
\sphinxAtStartPar
its length
\begin{equation*}
\begin{split}r = |{\bf r}|\end{split}
\end{equation*}
\sphinxAtStartPar
and the unit vector
\begin{equation*}
\begin{split}{\bf e}_r = \frac{{\bf r}}{r}\end{split}
\end{equation*}
\sphinxAtStartPar
We will assume that \(r\gg a\) where \(a\) is the particle size.  We
define the \{em scattering matrix elements\} \(Z_{ij}\) (with \(i,j\) =
\(1,2,3,4\)) such that the measured outgoing flux from the particle at
\({\bf y}\) is
\begin{equation*}
\begin{split}{\bf F}_{\mathrm{out}} = F_{\mathrm{out}}{\bf e}_r\end{split}
\end{equation*}\begin{equation*}
\begin{split}F_{\mathrm{out}} = \left(\begin{matrix}
F_{I,\mathrm{out}}\\
F_{Q,\mathrm{out}}\\
F_{U,\mathrm{out}}\\
F_{V,\mathrm{out}}
\end{matrix}\right)
=\frac{m_{\mathrm{grain}}}{r^2}
\left(\begin{matrix}
Z_{11} & Z_{12} & Z_{13} & Z_{14} \\
Z_{21} & Z_{22} & Z_{23} & Z_{24} \\
Z_{31} & Z_{32} & Z_{33} & Z_{34} \\
Z_{41} & Z_{42} & Z_{43} & Z_{44}
\end{matrix}\right)
\left(\begin{matrix}
F_{I,\mathrm{in}}\\
F_{Q,\mathrm{in}}\\
F_{U,\mathrm{in}}\\
F_{V,\mathrm{in}}
\end{matrix}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
The values \(Z_{ij}\) depend on the direction into which the radiation is
scattered (i.e. \({\bf e}_r\)) and on the direction of the incoming flux
(i.e. \({\bf n}\)), but not on \(r\): the radial dependence of the
outgoing flux is taken care of through the \(1/r^2\) factor in the above
formula.

\sphinxAtStartPar
Some notes about our conventions are useful at this place. In many books the
‘scattering matrix’ is written as \(F_{ij}\) instead of \(Z_{ij}\), and is
defined as the \(Z_{ij}\) for the case when radiation comes from one
particular direction: \({\bf n}=(0,0,1)\). In this manual and in the RADMC\sphinxhyphen{}3D
code, however, we will always write \(Z_{ij}\), because the symbol \(F\) can be
confused with flux. The normalization of these matrix elements is also
different in different books. In our case it has the dimension
\(\mathrm{cm}^2\;\mathrm{gram}^{-1}\;\mathrm{ster}^{-1}\).
The conversion from the conventions of other books is
(where \(k=2\pi/\lambda\) is the wave number in units of 1/cm):
\begin{equation*}
\begin{split}Z_{ij,\mathrm{RADMC-3D}} = \frac{Z_{ij,\mathrm{Mishchenko}}}{m_{\mathrm{grain}}}
= \frac{S_{ij,\mathrm{BohrenH}}}{k^2m_{\mathrm{grain}}}\end{split}
\end{equation*}
\sphinxAtStartPar
except that for the \(Z_{13}\), \(Z_{14}\), \(Z_{23}\),
\(Z_{24}\), \(Z_{31}\), \(Z_{41}\), \(Z_{32}\), \(Z_{42}\)
elements (if non\sphinxhyphen{}zero) there must be a minus sign before the
\(Z_{ij,\mathrm{RADMC-3D}}\) because of the opposite \(U\) and \(V\)
sign conventions (see Section {\hyperref[\detokenize{dustradtrans:sec-stokes-convent-differences}]{\sphinxcrossref{\DUrole{std,std-ref}{Our conventions compared to other literature}}}}).

\sphinxAtStartPar
Note that the \(S_{ij,\mathrm{BohrenH}}\) are the matrix elements obtained
from the famous \sphinxcode{\sphinxupquote{BHMIE.F}} code from the Bohren \& Huffman book
(see Chapter {\hyperref[\detokenize{opacitieswww:chap-acquiring-opacities}]{\sphinxcrossref{\DUrole{std,std-ref}{Acquiring opacities from the WWW}}}}).


\subsection{Polarized scattering off dust particles: randomly oriented particles}
\label{\detokenize{dustradtrans:polarized-scattering-off-dust-particles-randomly-oriented-particles}}
\sphinxAtStartPar
In the special case in which we either have spherical particles or we
average over a large number of randomly oriented particles, the \(Z_{ij}\)
elements are no longer dependent on \sphinxstyleemphasis{both} \({\bf e}_r\) and \({\bf n}\) but
only on the angle between them:
\begin{equation*}
\begin{split}\cos\theta = {\bf n}\cdot{\bf e}_r\end{split}
\end{equation*}
\sphinxAtStartPar
So we go from \(Z_{ij}({\bf n},{\bf e}_r)\), i.e. a four\sphinxhyphen{}angle dependence, to
\(Z_{ij}(\theta)\), i.e. a one\sphinxhyphen{}angle dependence.

\sphinxAtStartPar
Now let us also assume that there is no netto helicity of the particles
(they are either axisymmetric or there exist equal amounts of particles
as their mirror symmetric counterparts). In that case (see e.g.
Mishchenko book) of the 16 matrix elements only 6 are non\sphinxhyphen{}zero and independent:

\phantomsection\label{\detokenize{dustradtrans:eq-scatmat-for-randorient-nohelic}}\begin{equation*}
\begin{split}F_{\mathrm{out}} = \left(\begin{matrix}
F_{I,\mathrm{out}}\\
F_{Q,\mathrm{out}}\\
F_{U,\mathrm{out}}\\
F_{V,\mathrm{out}}
\end{matrix}\right)
=\frac{m_{\mathrm{grain}}}{r^2}
\left(\begin{matrix}
Z_{11} & Z_{12} & 0 & 0 \\
Z_{12} & Z_{22} & 0 & 0 \\
0 & 0 & Z_{33} & Z_{34} \\
0 & 0 & -Z_{34} & Z_{44}
\end{matrix}\right)
\left(\begin{matrix}
F_{I,\mathrm{in}}\\
F_{Q,\mathrm{in}}\\
F_{U,\mathrm{in}}\\
F_{V,\mathrm{in}}
\end{matrix}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
This is the case for scattering in RADMC\sphinxhyphen{}3D. Note that in Mie scattering the
number of independent matrix elements reduces to just 4 because then
\(Z_{22}=Z_{11}\) and \(Z_{44}=Z_{33}\). But RADMC\sphinxhyphen{}3D also allows for
cases where \(Z_{22}\neq Z_{11}\) and \(Z_{44}\neq Z_{33}\), i.e. for
opacities resulting from more detailed calculations such as DDA or T\sphinxhyphen{}matrix
calculations.

\sphinxAtStartPar
Now, as described above, the Stokes vectors only have meaning if the directions
of \(x'\) and \(y'\) are well\sphinxhyphen{}defined. For
Eq. (\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}scatmat\sphinxhyphen{}for\sphinxhyphen{}randorient\sphinxhyphen{}nohelic}) to be valid (and for the correct
meaning of the \(Z_{ij}\) elements) the following definition is used: Before
the scattering, the \({\bf S}\)\sphinxhyphen{}vector of the photon package is rotated (and
the Stokes vectors accordingly transformed) such that the new \({\bf
S}\)\sphinxhyphen{}vector is perpendicular to both \({\bf n}\) and \({\bf e}_r\). In
other words, the scattering angle \(\theta\) is a rotation of the photon
propagation around the (new) \({\bf S}\)\sphinxhyphen{}vector. The sign convention is such
that
\begin{equation*}
\begin{split}({\bf n}\times {\bf e}_r)\cdot{\bf S}=\sin(\theta)\end{split}
\end{equation*}
\sphinxAtStartPar
In other words, if we look into the incoming light (with \(z'\) pointing
toward us), then for \(\sin(\theta)>0\) the photon is scattered into the
\(x'>0\), \(y'=0\) direction (i.e. for us it is scattered to the
right).  The \({\bf S}\) vector for the outgoing photon remains unchanged,
since the new \({\bf n}\) is also perpendicular to it.

\sphinxAtStartPar
So what does this all mean for the opacity? The scattering opacity tells us
how much of the incident radiation is removed and converted into outgoing
scattered radiation. The absorption opacity tells us how much of the
incident radiation is removed and converted into heat. For randomly oriented
particles without netto helicity both opacities are independent of the
polarization state of the radiation. Moreover, the thermal emission
is unpolarized in this case. This means that in the radiative
transfer equation the extinction remains simple:

\phantomsection\label{\detokenize{dustradtrans:eq-radtrans-randomorient}}\begin{equation*}
\begin{split}\frac{d}{ds}\left(
\begin{matrix}
I_I\\I_Q\\I_U\\I_V
\end{matrix}
\right)
=
\left(
\begin{matrix}
j_{\mathrm{emis},I}\\0\\0\\0
\end{matrix}
\right)
+
\left(
\begin{matrix}
j_{\mathrm{scat},I}\\j_{\mathrm{scat},Q}\\j_{\mathrm{scat},U}\\j_{\mathrm{scat},V}
\end{matrix}
\right)
-\rho(\kappa_{\mathrm{abs}}+\kappa_{\mathrm{scat}})
\left(
\begin{matrix}
I_I\\I_Q\\I_U\\I_V
\end{matrix}
\right)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(I_I\), \(I_Q\), \(I_U\), \(I_V\) are the intensities
(\(\mathrm{erg}\,\mathrm{s}^{-1}\,\mathrm{cm}^{-2}\,\mathrm{Hz}^{-1}\,\mathrm{ster}^{-1}\))
for the four Stokes parameters, and likewise for
\(j_{\mathrm{emis}}\) and \(j_{\mathrm{scat}}\), and finally, \(s\)
the path length along the ray under consideration. Note that if we would allow
for fixed\sphinxhyphen{}orientation dust particles (which we don’t),
Eq. (\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}radtrans\sphinxhyphen{}randomorient}) would become considerably more complex,
with extinction being matrix\sphinxhyphen{}valued and thermal emission being polarized.

\sphinxAtStartPar
Since \(\kappa_{\mathrm{scat}}\) converts incoming radiation into outgoing
scattered radiation, it should be possible to calculate
\(\kappa_{\mathrm{scat}}\) from angular integrals of the scattering matrix
elements. For randomly oriented non\sphinxhyphen{}helical particles we indeed have:

\phantomsection\label{\detokenize{dustradtrans:eq-scatmat-selfconsist-kappa}}\begin{equation*}
\begin{split}\kappa_{\mathrm{scat}} = \oint Z_{11} d\Omega =
2\pi \int_{-1}^{+1}Z_{11}(\mu)d\mu\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mu=\cos\theta\). In a similar exercise we can calculate the
anisotropy factor \(g\) from the scattering matrix elements:

\phantomsection\label{\detokenize{dustradtrans:eq-scatmat-selfconsist-g}}\begin{equation*}
\begin{split}g = \frac{2\pi}{\kappa_{\mathrm{scat}}}\int_{-1}^{+1}Z_{11}(\mu)\mu d\mu\end{split}
\end{equation*}
\sphinxAtStartPar
This essentially completes the description of scattering as it is implemented in
RADMC\sphinxhyphen{}3D.

\sphinxAtStartPar
We can precalculate the \(Z_{ij}(\theta)\) for every wavelength and for a
discrete set of values of \(\theta\), and store these in a table. This is
indeed the philosophy of RADMC\sphinxhyphen{}3D: You have to precompute them using, for
instance, the Mie code of Bohren and Huffman (see Chapter
{\hyperref[\detokenize{opacitieswww:chap-acquiring-opacities}]{\sphinxcrossref{\DUrole{std,std-ref}{Acquiring opacities from the WWW}}}} for RADMC\sphinxhyphen{}3D compliant wrappers around that
code), and then provide them to RADMC\sphinxhyphen{}3D through a file called
\sphinxcode{\sphinxupquote{dustkapscatmat\_xxx.inp}} (where \sphinxcode{\sphinxupquote{xxx}} is the name of the dust species) which
is described in Section {\hyperref[\detokenize{inputoutputfiles:sec-dustkapscatmat-files}]{\sphinxcrossref{\DUrole{std,std-ref}{The dustkapscatmat\_*.inp files}}}}.  This file provides not
only the matrix elements, but also the \(\kappa_{\mathrm{abs}}\),
\(\kappa_{\mathrm{scat}}\) and \(g\) (the anisotropy factor). RADMC\sphinxhyphen{}3D
will then internally check that Eqs.(\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}scatmat\sphinxhyphen{}selfconsist\sphinxhyphen{}kappa},
\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}scatmat\sphinxhyphen{}selfconsist\sphinxhyphen{}g}) are indeed fulfilled. If not, an error message
will result.

\sphinxAtStartPar
One more note: As mentioned in Section {\hyperref[\detokenize{dustradtrans:sec-definitions-stokes}]{\sphinxcrossref{\DUrole{std,std-ref}{Definitions and conventions for Stokes vectors}}}}, the sign
conventions of the Stokes vector components we use (the IAU 1974 definition) are
different from the Bohren \& Huffman and Mishchenko books. For randomly oriented
particles, however, the sign conventions of the \(Z\)\sphinxhyphen{}matrix elements are
not affected, because those matrix elements that would be affected are those
that are in the upper\sphinxhyphen{}right and lower\sphinxhyphen{}left quadrants of the matrix, and these
elements are anyway zero. So we can use, for randomly oriented particles, the
matrix elements from those books and their computer codes without having to
adjust the signs.


\subsection{Scattering and axially symmetric models}
\label{\detokenize{dustradtrans:scattering-and-axially-symmetric-models}}
\sphinxAtStartPar
In spherical coordinates it is possible in RADMC\sphinxhyphen{}3D to set up axially symmetric
models. The trick is simply to set the number of \(\phi\) coordinate points
\sphinxcode{\sphinxupquote{nphi}} to 1 and to switch off the \(\phi\)\sphinxhyphen{}dimension in the grid (see
Section {\hyperref[\detokenize{inputoutputfiles:sec-grid-input}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): amr\_grid.inp}}}}). For isotropic scattering this mode has always
been implemented. But for anisotropic scattering things become more complex. For
such a model the scattering remains a fully 3\sphinxhyphen{}D problem: the scattering source
function has to be stored not only as a function of \(r\) and
\(\theta\), but also as a function of \(\phi\) (for a given observer
vantage point). The reason is that anisotropic scattering \{em does\} care about
viewing angle (in contrast to isotropic scattering). So even though for an
axisymmetric model the density and temperature functions only depend on
\(r\) and \(\theta\) (and are therefore mathematically 2\sphinxhyphen{}D), the
scattering source function depends on \(r\), \(\theta\) and
\(\phi\).

\sphinxAtStartPar
For this reason anisotropic scattering was, until version 0.40, not allowed for
2\sphinxhyphen{}D axisymmetric models. As of version 0.41 it is now possible to use the full
polarized scattering mode (\sphinxcode{\sphinxupquote{scattering\_mode=5}}) also for 2\sphinxhyphen{}D axisymmetric
models. The intermediate scattering modes (\sphinxcode{\sphinxupquote{scattering\_mode=2, 3, 4}}) remain
incompatible with 2\sphinxhyphen{}D axisymmetry.  Isotropic scattering remains, as before,
fully compatible with 2\sphinxhyphen{}D axisymmetry.

\sphinxAtStartPar
One note of explanation: the way the full scattering is now implemented into
the case of 2\sphinxhyphen{}D axisymmetry is the following: internally we compute not just
the scattering source function for one angle, but for a whole set of \(\phi\)
angles (even though the grid has no \(\phi\)\sphinxhyphen{}points). Each time a photon in
the scattering Monte Carlo simulation enters a cell (which in 2\sphinxhyphen{}D
axisymmetry is an annulus), a loop over 360 \(\phi\) angles is performed, and
the scattering source function is computed for all of these angles.  \{em
This makes the code rather slow for each photon package!\} But one needs
fewer photon packages to get sufficiently high signal\sphinxhyphen{}to\sphinxhyphen{}noise ratio. You
can experiment with fewer \(\phi\) angles by adding, in \sphinxcode{\sphinxupquote{radmc3d.inp}},
the following line (as an example):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dust\PYGZus{}2daniso\PYGZus{}nphi} \PYG{o}{=} \PYG{l+m+mi}{60}
\end{sphinxVerbatim}

\sphinxAtStartPar
in which case instead of 360 the model will only use 60 \(\phi\)
points. That will speed up the code significantly, but of course will treat the
\(\phi\)\sphinxhyphen{}dependence of the scattering source function with lower precision.

\sphinxAtStartPar
For now the 2\sphinxhyphen{}D axisymmetric version of full scattering is only possible with
first\sphinxhyphen{}order integration.


\section{More about photon packages in the Monte Carlo simulations}
\label{\detokenize{dustradtrans:more-about-photon-packages-in-the-monte-carlo-simulations}}\label{\detokenize{dustradtrans:sec-photon-packages-mc}}
\sphinxAtStartPar
In the ‘standard’ Monte Carlo approach, the input energy (e.g. starlight or, for
the scattering Monte Carlo, the thermal emission of dust) is divided into
\(N\) equal energy packages of photons, which then travel through the model
and eventually either escape or get destroyed. This equal division scheme is,
however, problematic for some model setups. For instance, if you have stars with
vastly different luminosity in the model, then the brightest of these stars will
dominate, by far, the number of output photon packages.  This means that the
material around low\sphinxhyphen{}brightness stars (which, by their proximity to these
low\sphinxhyphen{}brightness stars, are still dominated by heating by these low\sphinxhyphen{}brightness
stars) will experience very bad photon statistics.

\sphinxAtStartPar
To avoid this problem, RADMC\sphinxhyphen{}3D has, by default, its ‘weighted photon package
mode’ switched on. This will make sure that each source of energy (i.e. each
star, but also each other type of source) emits the same amount of
photons. Only: bright stars will emit more energetic photon packages than dim
stars.

\sphinxAtStartPar
The ‘weighted photon package mode’ will also solve another problem.  Suppose a
star lies far outside of the grid. It will emit most of its photons in
directions that completely miss the grid. This means that RADMC\sphinxhyphen{}3D would waste a
lot of time drawing random numbers for photons that will anyway not affect the
model. Also here the ‘weighted photon package mode’ solves the problem: It will
focus the photon packages toward the model grid, and lower their energy to
compensate for their favorable focusing toward the grid.

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE:} You can switch the mode off by setting \sphinxcode{\sphinxupquote{mc\_weighted\_photons=0}} in the
\sphinxcode{\sphinxupquote{radmc3d.inp}} file.


\section{Polarized emission and absorption by aligned grains}
\label{\detokenize{dustradtrans:polarized-emission-and-absorption-by-aligned-grains}}\label{\detokenize{dustradtrans:sec-polarized-thermal-emission}}
\sphinxAtStartPar
\sphinxstyleemphasis{NOTE: This mode is still in the testing phase}

\sphinxAtStartPar
Grain alignment and its effects on radiative transfer is a complex topic. A
review is e.g. Andersson, B.G., Lazarian, A., \& Vaillancourt, J.E. (2015)
‘Interstellar Dust Grain Alignment’, Annual Review of Astronomy and
Astrophysics, 53(1), 501\textendash{}539. In RADMC\sphinxhyphen{}3D grain alignment is included only in a
limited form. First and foremost: RADMC\sphinxhyphen{}3D does not know about the physics \{em
causing\} the grain alignment. You, the user, will have to tell how the grain are
aligned by giving the code a directional vector field and for each wavelength
the degree to which the grain is aligned to that directional vector (more on
this later). This is according to the RADMC\sphinxhyphen{}3D philosophy of doing \{em only\}
the radiative transfer and leaving the physics of the material to the user.


\subsection{Basics}
\label{\detokenize{dustradtrans:basics}}\label{\detokenize{dustradtrans:sec-basic-equations}}
\sphinxAtStartPar
Suppose we have flattened (oblate) ellipsoidal grains with one axis of symmetry
and no helicity. (While helicity may be needed to radiatively spin up grains, we
assume that on average the helicity of the grains is zero.). Let us assume that
they are aligned with that symmetry axis along the \(y\)\sphinxhyphen{}axis. We view
radiation from the point where the \(z\)\sphinxhyphen{}axis points toward us. Horizontally
polarized light (which has \(E\)\sphinxhyphen{}field in horizontal direction, i.e. in
\(x\)\sphinxhyphen{}direction) has \(Q/I=+1\), vertically polarized light (with the
\(\vec E\) vector aligned with the symmetry axis of the grain) has
\(Q/I=-1\). We can then assume that the dust has different extinction
coefficients for the horizontal and vertical axis. Let us call these:
\begin{equation*}
\begin{split}\begin{split}
\alpha_{\mathrm{abs},\nu,\mathrm{h}} &\equiv \rho_d\kappa_{\mathrm{abs},\nu,\mathrm{h}}\\
\alpha_{\mathrm{abs},\nu,\mathrm{v}} &\equiv \rho_d\kappa_{\mathrm{abs},\nu,\mathrm{v}}
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
We can define \(I\), \(Q\), \(U\) and \(V\) in terms of the electric field
components \(E_x\) and \(E_y\). The electric field components for a perfectly
coherent wave can be written as
\begin{equation*}
\begin{split}\begin{split}
E_x&=E_{x,0}\cos(\omega t-\Delta_x)\\
E_y&=E_{y,0}\cos(\omega t-\Delta_y)
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Delta_x\) and \(\Delta_y\) are phase lags. The phase lag between
the \(y\) and \(x\)\sphinxhyphen{}fields is \(\Delta=\Delta_y-\Delta_x\), meaning that for
positive \(\Delta\) the \(y\)\sphinxhyphen{}field lags behind the \(x\)\sphinxhyphen{}field. We then
define the Stokes components as:

\phantomsection\label{\detokenize{dustradtrans:eq-def-stokes-iquv}}\begin{equation*}
\begin{split}\begin{split}
I &= E_{x,0}^2+E_{y,0}^2\\
Q &= E_{x,0}^2-E_{y,0}^2\\
U &= 2E_{x,0}E_{y,0}\cos\Delta\\
V &= 2E_{x,0}E_{y,0}\sin\Delta
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
Note that for \(V=I\) (\(\Delta=\pi/2\), i.e. the \(E_y\) lags
\(\pi/2\) behind \(E_x\)) we have \sphinxstyleemphasis{right\sphinxhyphen{}handed} circularly polarized
light, meaning that the tip of the \(\vec E\) field at a fixed point in
space, when looking into the light (the propagation of light is toward the
reader) rotates counter\sphinxhyphen{}clockwise (when the \(x\)\sphinxhyphen{}coordinate points right,
and the \(y\)\sphinxhyphen{}coordinate points up). The 3\sphinxhyphen{}D helix of his field will be \{em
left\sphinxhyphen{}handed\} (when the z\sphinxhyphen{}coordinate points into the propagation direction of the
light, i.e. toward the reader, i.e. a right\sphinxhyphen{}handed coordinate system). For
\(Q=I\) we have linearly polarized light in which the \(\vec E\)\sphinxhyphen{}field
lies in the \(x\)\sphinxhyphen{}direction. For \(U=I\) we have linearly polarized
light in which \(\vec E\) lies along the \(x=y\) line (when looking into
the light). These definitions are consistent with the IAU 1974 definitions
(Hamaker \& Bregman 1996, A\&AS 117, pp.161).

\sphinxAtStartPar
The \(E_x\) and \(E_y\) get absorbed in the following way:
\begin{equation*}
\begin{split}\begin{split}
E_{x,0}' &= E_{x,0} e^{-\tfrac{1}{2}\alpha_{\mathrm{abs},\nu,\mathrm{h}}s}\\
E_{y,0}' &= E_{y,0} e^{-\tfrac{1}{2}\alpha_{\mathrm{abs},\nu,\mathrm{v}}s}
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(s\) is a length along the ray.

\sphinxAtStartPar
For this kind of problem it is convenient to introduce the so\sphinxhyphen{}called \sphinxstyleemphasis{modified
Stokes parameters} \(I_{\mathrm{h}}\) and \(I_{\mathrm{v}}\):

\phantomsection\label{\detokenize{dustradtrans:eq-modif-stokes-hv}}\begin{equation*}
\begin{split}\begin{split}
I_{\mathrm{h}} &= \frac{1}{2}(I+Q)\\
I_{\mathrm{v}} &= \frac{1}{2}(I-Q)
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
so that we have
\begin{equation*}
\begin{split}\begin{split}
I &= I_{\mathrm{h}}+I_{\mathrm{v}}\\
Q &= I_{\mathrm{h}}-I_{\mathrm{v}}
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
so that one can say, for perfectly coherent light,
\begin{equation*}
\begin{split}\begin{split}
I_{\mathrm{h}} &= E_{x,0}^2\\
I_{\mathrm{v}} &= E_{y,0}^2
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
With this we get the following extinction law:
\begin{equation*}
\begin{split}\begin{split}
I_{\mathrm{h}}' &= I_{\mathrm{h}} e^{-\alpha_{\mathrm{abs},\nu,\mathrm{h}}s}\\
I_{\mathrm{v}}' &= I_{\mathrm{v}} e^{-\alpha_{\mathrm{abs},\nu,\mathrm{v}}s}
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
How do \(U\) and \(V\) extinct? If we use Eqs. (\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}def\sphinxhyphen{}stokes\sphinxhyphen{}u},
\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}def\sphinxhyphen{}stokes\sphinxhyphen{}v}), and assume that the phase lag \(\Delta\) will not
change during the extinction, then
\begin{equation*}
\begin{split}\begin{split}
U' &= U e^{-\tfrac{1}{2}\alpha_{\mathrm{abs},\nu,\mathrm{h}}s} e^{-\tfrac{1}{2}\alpha_{\mathrm{abs},\nu,\mathrm{v}}s}\\
   &= U e^{-\tfrac{1}{2}(\alpha_{\mathrm{abs},\nu,\mathrm{h}}+\alpha_{\mathrm{abs},\nu,\mathrm{v}})s}
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
This means that
\begin{equation*}
\begin{split}\alpha_{\mathrm{abs},\nu,\mathrm{uv}} =
\frac{1}{2}\left(\alpha_{\mathrm{abs},\nu,\mathrm{h}}+\alpha_{\mathrm{abs},\nu,\mathrm{v}}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
and
\begin{equation*}
\begin{split}\begin{split}
I_{\mathrm{u}}' &= I_{\mathrm{u}} e^{-\alpha_{\mathrm{abs},\nu,\mathrm{uv}}s}\\
I_{\mathrm{v}}' &= I_{\mathrm{v}} e^{-\alpha_{\mathrm{abs},\nu,\mathrm{uv}}s}
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
In matrix notation
\begin{equation*}
\begin{split}\frac{d}{ds}
\left(\begin{matrix}
I_{\mathrm{h}} \\
I_{\mathrm{v}} \\
U \\
V \\
\end{matrix}\right)
= -
\left(\begin{matrix}
\alpha_{\mathrm{h}} & 0 & 0 & 0 \\
0 & \alpha_{\mathrm{v}} & 0 & 0  \\
0 & 0 & \alpha_{\mathrm{uv}} & 0 \\
0 & 0 & 0 & \alpha_{\mathrm{uv}} \\
\end{matrix}\right)
\left(\begin{matrix}
I_{\mathrm{h}} \\
I_{\mathrm{v}} \\
U \\
V \\
\end{matrix}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
If we translate this to the usual Stokes components we get
\begin{equation*}
\begin{split}\frac{d}{ds}
\left(\begin{matrix}
I \\
Q \\
U \\
V \\
\end{matrix}\right)
= -
\left(\begin{matrix}
\alpha_1 & \alpha_2 & 0 & 0 \\
\alpha_2 & \alpha_1 & 0 & 0  \\
0 & 0 & \alpha_1 & 0 \\
0 & 0 & 0 & \alpha_1 \\
\end{matrix}\right)
\left(\begin{matrix}
I \\
Q \\
U \\
V \\
\end{matrix}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
with
\begin{equation*}
\begin{split}\begin{split}
\alpha_1 &= \frac{1}{2}\left(\alpha_{\mathrm{abs},\nu,\mathrm{h}}+\alpha_{\mathrm{abs},\nu,\mathrm{v}}\right)
= \alpha_{\mathrm{abs},\nu,\mathrm{uv}}\\
\alpha_2 &= \frac{1}{2}\left(\alpha_{\mathrm{abs},\nu,\mathrm{h}}-\alpha_{\mathrm{abs},\nu,\mathrm{v}}\right)
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
The emission will be also independently in horizontal and vertical
direction. But nothing will be emitted in U or V direction. So it is most
convenient to express the emission/absorption process in terms of the
modified Stokes parameters:
\begin{equation*}
\begin{split}\begin{split}
\frac{dI_{\nu,\mathrm{h}}}{ds} &= \alpha_{\mathrm{abs},\nu,\mathrm{h}} (\frac{1}{2}B_\nu(T)-I_{\nu,\mathrm{h}}) \\
\frac{dI_{\nu,\mathrm{v}}}{ds} &= \alpha_{\mathrm{abs},\nu,\mathrm{v}} (\frac{1}{2}B_\nu(T)-I_{\nu,\mathrm{v}}) \\
\frac{dU_{\nu}}{ds} &= -\alpha_{\mathrm{abs},\nu,\mathrm{uv}} U_{\nu} \\
\frac{dV_{\nu}}{ds} &= -\alpha_{\mathrm{abs},\nu,\mathrm{uv}} V_{\nu}
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
In terms of matrix notation this becomes

\phantomsection\label{\detokenize{dustradtrans:eq-formal-rt-emisabs-in-rotated-system}}\begin{equation*}
\begin{split}\frac{d}{ds}
\left(\begin{matrix}
I_{\mathrm{h}} \\
I_{\mathrm{v}} \\
U \\
V \\
\end{matrix}\right)
= \left(\begin{matrix}
\tfrac{1}{2}\alpha_{\mathrm{h}} B_\nu(T) \\
\tfrac{1}{2}\alpha_{\mathrm{v}} B_\nu(T) \\
0 \\
0 \\
\end{matrix}\right)
-
\left(\begin{matrix}
\alpha_{\mathrm{h}} & 0 & 0 & 0 \\
0 & \alpha_{\mathrm{v}} & 0 & 0  \\
0 & 0 & \alpha_{\mathrm{uv}} & 0 \\
0 & 0 & 0 & \alpha_{\mathrm{uv}} \\
\end{matrix}\right)
\left(\begin{matrix}
I_{\mathrm{h}} \\
I_{\mathrm{v}} \\
U \\
V \\
\end{matrix}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
In terms of the normal Stokes parameters this becomes
\begin{equation*}
\begin{split}\frac{d}{ds}
\left(\begin{matrix}
I \\
Q \\
U \\
V \\
\end{matrix}\right)
= \left(\begin{matrix}
\alpha_1 B_\nu(T) \\
\alpha_2 B_\nu(T) \\
0 \\
0 \\
\end{matrix}\right)
-
\left(\begin{matrix}
\alpha_1 & \alpha_2 & 0 & 0 \\
\alpha_2 & \alpha_1 & 0 & 0  \\
0 & 0 & \alpha_1 & 0 \\
0 & 0 & 0 & \alpha_1 \\
\end{matrix}\right)
\left(\begin{matrix}
I \\
Q \\
U \\
V \\
\end{matrix}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
or written slightly differently:
\begin{equation*}
\begin{split}\frac{d}{ds}
\left(\begin{matrix}
I \\
Q \\
U \\
V \\
\end{matrix}\right)
=
\left(\begin{matrix}
\alpha_1 & \alpha_2 & 0 & 0 \\
\alpha_2 & \alpha_1 & 0 & 0  \\
0 & 0 & \alpha_1 & 0 \\
0 & 0 & 0 & \alpha_1 \\
\end{matrix}\right)
\left[
\left(\begin{matrix}
B_\nu(T) \\
0 \\
0 \\
0 \\
\end{matrix}\right)
-\left(\begin{matrix}
I \\
Q \\
U \\
V \\
\end{matrix}\right)\right]\end{split}
\end{equation*}
\sphinxAtStartPar
So to sum things up: We need only the absorption opacity for light with
\(\vec E\) perpencidular to the symmetry axis
(\(\kappa_{\mathrm{abs},\nu,h}\)) and the absorption opacity for light with
\(\vec E\) parallel to the symmetry axis
(\(\kappa_{\mathrm{abs},\nu,v}\)).


\subsection{Implementation in RADMC\sphinxhyphen{}3D}
\label{\detokenize{dustradtrans:implementation-in-radmc-3d}}

\subsubsection{Polarized emission in the images and spectra}
\label{\detokenize{dustradtrans:polarized-emission-in-the-images-and-spectra}}
\sphinxAtStartPar
When creating images (and spectra) the \sphinxcode{\sphinxupquote{camera}} module of RADMC\sphinxhyphen{}3D
performs a ray\sphinxhyphen{}tracing calculation (‘volume rendering’) through the grid.
Normally (for randomly oriented grains) the extinction along the line of
sight is always unpolarized, i.e. each Stokes component is extincted
equally much. The thermal emission along the line of sight is also
unpolarized.

\sphinxAtStartPar
Now, however, we wish to include the effect of grain alignment in the
ray\sphinxhyphen{}tracing. We assume that at position \(\vec x\) in the grid our oblate
grain is aligned such that the minor axis points in the direction of the
orientation vector \(\vec n_{\mathrm{align}}(\vec x)\). If the grain is
prolate, we assume that it spins along one of its minor axes such that this
spin axis is pointing along \(\vec n_{\mathrm{align}}(\vec x)\), so that, in
effect, it acts as if it were an oblate grain again. In practice the
alignment vector \(\vec n_{\mathrm{align}}(\vec x)\) does not lie always in
the plane of the sky of the observer. Instead it will have an angle \(\theta\)
with the line\sphinxhyphen{}of\sphinxhyphen{}sight direction vector \(\vec n_{\mathrm{los}}\) (note that
this \(\theta\) angle is different from the scattering angle \(\theta\)),
defined as
\begin{equation*}
\begin{split}\cos\theta \equiv = \left|\vec n_{\mathrm{align}}\cdot
\vec n_{\mathrm{los}}\right|\end{split}
\end{equation*}
\sphinxAtStartPar
Here we assume that the grains have top/bottom symmetry so that we only have to
concern ourselves with the positive values of \(\cos\theta\), hence the
\(||\). If \(\cos\theta=1\) then we see the oblate grain from the top or
the bottom, so that we do not expect any polarized emission. The strongest
polarized emission is expected when \(\cos\theta=0\), which means that the
oblate grain is seen edge\sphinxhyphen{}on.

\sphinxAtStartPar
We can now define the ‘projected alignment vector’ \(\vec
n_{\mathrm{align,proj}}\), which is the alignment vector projected into
the image plane:
\begin{equation*}
\begin{split}\vec n_{\mathrm{align,proj}} = \vec n_{\mathrm{align}} - (\vec n_{\mathrm{align}}\cdot
\vec n_{\mathrm{los}})\;\vec n_{\mathrm{los}}\end{split}
\end{equation*}
\sphinxAtStartPar
To use the equations from Section {\hyperref[\detokenize{dustradtrans:sec-basic-equations}]{\sphinxcrossref{\DUrole{std,std-ref}{Basics}}}} we must first
rotate our image plane coordinates \((x,y)\) to new coordinates \((x',y')\) such
that the \(y'\) (vertical) direction points along the \(\vec
n_{\mathrm{align,proj}}\) vector while the \(x'\) (horizontal) direction points
perpendicular to it. Let us write the Stokes vector of the radiation along
the line of sight
\((I_{\mathrm{in}},Q_{\mathrm{in}},U_{\mathrm{in}},V_{\mathrm{in}})\), where
we implicitly know that these are also a function of frequency \(\nu\). This
Stokes vector is defined with respect to the vector \(\vec S\) which is
perpendicular to the line\sphinxhyphen{}of\sphinxhyphen{}sight direction vector \(\vec n_{\mathrm{los}}\)
and defines the direction in which the \(y\)\sphinxhyphen{}coordinate of the image plane
points. We must now express this incoming radiation (at the start of the
segment) in the new \((x',y')\) image plane coordinates, i.e. with respect to
the new vector \(\vec S'\) that points along \(\vec n_{\mathrm{align,proj}}\)
(i.e. \(\vec S'\) is the normalized version of \(\vec
n_{\mathrm{align,proj}}\)). This rotation is performed using

\phantomsection\label{\detokenize{dustradtrans:eq-rot-stokes-align}}\begin{equation*}
\begin{split}\left(\begin{matrix}
I'\\Q'\\U'\\V'
\end{matrix}\right)
=
\left(\begin{matrix}
1 & 0 & 0 & 0 \\
0 & \cos(2\alpha) & \sin(2\alpha) & 0 \\
0 & -\sin(2\alpha) & \cos(2\alpha) & 0 \\
0 & 0 & 0 & 1
\end{matrix}\right)
\left(\begin{matrix}
I_{\mathrm{in}}\\Q_{\mathrm{in}}\\U_{\mathrm{in}}\\V_{\mathrm{in}}
\end{matrix}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\alpha\) is the angle between \(\vec S'\) and \(\vec S\)
such that if (as seen by the observer) \(\vec S'\) lies counter\sphinxhyphen{}clockwise
from \(\vec S\), \(\alpha\) is positive (the usual definition). With
this new Stokes vector \((I',Q',U',V')\) we will now use the equations of
Section {\hyperref[\detokenize{dustradtrans:sec-basic-equations}]{\sphinxcrossref{\DUrole{std,std-ref}{Basics}}}}.

\sphinxAtStartPar
To be able to perform this rotation in a uniquely defined way, it is necessary
that along each segment along the line of sight this new \((x',y')\)
orientation stays fixed (but can vary from segment to segment). As the
line\sphinxhyphen{}of\sphinxhyphen{}sight ray enters a cell and leaves it again, this line element (segment)
will have its image\sphinxhyphen{}plane coordinates rotated according to the alignment vector
of that cell. As a result, the integration must be done first order (assuming
all source terms to be constant along the segment).  In principle second order
integration would also be possible, but then the trick with the rotation of the
image coordinate plane such that \(y'\) points along the orientation vector
does no longer work, and the integration of the formal transfer equation would
become much more complex, involving the full Müller matrix formulation. We will
not do this, so we will stick to first order integration of
Eq. \DUrole{xref,std,std-ref}{eq\sphinxhyphen{}formal\sphinxhyphen{}rt\sphinxhyphen{}emisabs\sphinxhyphen{}in\sphinxhyphen{}rotated\sphinxhyphen{}system}.

\sphinxAtStartPar
For convenience we will leave out the primes (’) from here on, so while we write
\((I,Q,U,V)\) we mean in fact \((I',Q',U',V')\). We now compute
\(I_{\mathrm{h}}\) and \(I_{\mathrm{v}}\) using
Eqs. (\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}modif\sphinxhyphen{}stokes\sphinxhyphen{}h}, \DUrole{xref,std,std-ref}{eq\sphinxhyphen{}modif\sphinxhyphen{}stokes\sphinxhyphen{}v}). Now, along this
segment of the ray, we can write
Eq. \DUrole{xref,std,std-ref}{eq\sphinxhyphen{}formal\sphinxhyphen{}rt\sphinxhyphen{}emisabs\sphinxhyphen{}in\sphinxhyphen{}rotated\sphinxhyphen{}system} in the following form:

\phantomsection\label{\detokenize{dustradtrans:eq-firstorder-int-emisabs}}\begin{equation*}
\begin{split}\frac{d}{ds}
\left(\begin{matrix}
I_{\mathrm{h}} \\
I_{\mathrm{v}} \\
U \\
V \\
\end{matrix}\right)
=
\left(\begin{matrix}
\alpha_{\mathrm{h}} & 0 & 0 & 0 \\
0 & \alpha_{\mathrm{v}} & 0 & 0  \\
0 & 0 & \alpha_{\mathrm{uv}} & 0 \\
0 & 0 & 0 & \alpha_{\mathrm{uv}} \\
\end{matrix}\right)
\left[
\left(\begin{matrix}
\tfrac{1}{2} B_\nu(T) \\
\tfrac{1}{2} B_\nu(T) \\
0 \\
0 \\
\end{matrix}\right)
-
\left(\begin{matrix}
I_{\mathrm{h}} \\
I_{\mathrm{v}} \\
U \\
V \\
\end{matrix}\right)\right]\end{split}
\end{equation*}
\sphinxAtStartPar
It becomes clear that it is easy to perform the first order integration of this
equation along this ray segment:
\begin{equation*}
\begin{split}\begin{split}
I_{\mathrm{h,end}} &=  e^{-\tau_h}I_{\mathrm{h,start}} + \tfrac{1}{2}e^{-\tau_h}B_\nu(T)\\
I_{\mathrm{v,end}} &=  e^{-\tau_v}I_{\mathrm{v,start}} + \tfrac{1}{2}e^{-\tau_v}B_\nu(T) \\
U_{\mathrm{end}} &=    e^{-\tau_{uv}}U_{\mathrm{start}}\\
V_{\mathrm{end}} &=    e^{-\tau_{uv}}V_{\mathrm{start}}
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
where ‘start’ stands for the start of the ray segment, and ‘end’ the end of the
ray segment (which becomes the start of the next ray segment), and
\(\tau_h=\alpha_{\mathrm{h}}\Delta s\),
\(\tau_v=\alpha_{\mathrm{v}}\Delta s\) and
\(\tau_{uv}=\alpha_{\mathrm{uv}}\Delta s\), with \(\Delta s\) being the
length of the segment.

\sphinxAtStartPar
We now compute \(I_{\mathrm{end}}\) and \(Q_{\mathrm{end}}\), and rotate
back to the \((x,y)\) image plane coordinate system (i.e. using \(\vec
S\) instead of \(\vec S'\) to define the Stokes parameters) by applying
Eq. \DUrole{xref,std,std-ref}{eq\sphinxhyphen{}rot\sphinxhyphen{}stokes\sphinxhyphen{}align} but now with \(\alpha\rightarrow -\alpha\),
and we have the values of the Stokes parameter at the end of the ray
segment. Now we repeat this whole procedure for the next ray segment.


\subsubsection{Polarized emission as source term in the Monte Carlo simulation}
\label{\detokenize{dustradtrans:polarized-emission-as-source-term-in-the-monte-carlo-simulation}}
\sphinxAtStartPar
The polarization effects and anisotropic emission by aligned grains will
also affect the Monte Carlo simulations.

\sphinxAtStartPar
For the \sphinxstyleemphasis{thermal Monte Carlo} (see Section {\hyperref[\detokenize{dustradtrans:sec-dust-thermal-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{The thermal Monte Carlo simulation: computing the dust temperature}}}})
this effect is \sphinxstyleemphasis{not included}. In principle it should be included, but it would
slow the code down, and it is unlikely to play a significant role for the dust
temperature, in particular since the anisotropy of thermal emission is not
expected to be so strong (and the polarization state is irrelevant for computing
the dust temperature). It is clear that we make a small error here, but we
believe that this is well within the much stronger uncertainties of the dust
opacities.

\sphinxAtStartPar
For the \sphinxstyleemphasis{scattering Monte Carlo} (see Section {\hyperref[\detokenize{dustradtrans:sec-scat-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Scattered light in images and spectra: The ‘Scattering Monte Carlo’ computation}}}}),
however, this effect may be important! The polarization caused by scattering of
light off dust grains yields of course different results if the incident light
is unpolarized or if it is already strongly polarized through, for instance,
polarized thermal emission. In RADMC\sphinxhyphen{}3D this is therefore built into the
scattering Monte Carlo. This will not slow down the code much because (in
contrast to the thermal Monte Carlo) the polarized thermal emission only has to
be computed at the start of each photon path, if the photon is emitted by the
dust.

\sphinxAtStartPar
The way this is included is that when a photon is emitted by the dust inside a
cell, RADMC\sphinxhyphen{}3D first randomly chooses which of the dust species emits the photon
(the probabilities are weighted by the contribution each dust species makes to
the emissivity at the given wavelength).  Then the emission direction is
randomly chosen, based on the \(\theta\)\sphinxhyphen{}dependent probability function
(where \(\theta\) is the angle with the alignment direction) given by the
average of the orthogonal (horizontal) and parallel (vertical) absorption
opacities. Once the emission direction is chosen, the polarization state of the
photon package is computed based on the orthogonal and parallel absorption
opacities. Then the photon package is sent on its way.

\sphinxAtStartPar
Note that if \sphinxcode{\sphinxupquote{alignment\_mode = \sphinxhyphen{}1}} then the polarized (and anisotropic)
thermal emission by aligned grains is only included in the ray\sphinxhyphen{}tracing for
images and spectra, while for \sphinxcode{\sphinxupquote{alignment\_mode = 1}} it is \sphinxstyleemphasis{also} included
in the scattering Monte Carlo computation.


\subsection{Consistency with other radiative processes}
\label{\detokenize{dustradtrans:consistency-with-other-radiative-processes}}
\sphinxAtStartPar
The above equations assume that the absorption/emission is the only radiative
process included. However, in practice we also have other processes involved,
such as line emission/absorption or the scattering source function. The way this
can be treated here is to simply add these additional opacities to all four
components of the extinction matrix of
Eq. (\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}formal\sphinxhyphen{}rt\sphinxhyphen{}emisabs\sphinxhyphen{}in\sphinxhyphen{}rotated\sphinxhyphen{}system}) and to add the additional
emissivities to the vector with the Planck functions in
Eq. (\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}formal\sphinxhyphen{}rt\sphinxhyphen{}emisabs\sphinxhyphen{}in\sphinxhyphen{}rotated\sphinxhyphen{}system}). For the scattered light
emissivity (which is a Stokes vector) we must also first perform a rotation from
\(\vec S\) to \(\vec S'\) using the Stokes rotation formula of
Eq. (\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}rot\sphinxhyphen{}stokes\sphinxhyphen{}align}) before we add this emissivity to the
equation. If we include the effect of alignment on the scattering (see Section
{\hyperref[\detokenize{dustradtrans:sec-align-scat}]{\sphinxcrossref{\DUrole{std,std-ref}{Effect of aligned grains on the scattering}}}}) then also the scattering extinction will be different for
the orthogonal (horizontal) and parallel (vertical) Stokes components. That is
easy to include in this formalism.


\subsection{Input files for RADMC\sphinxhyphen{}3D for aligned grains}
\label{\detokenize{dustradtrans:input-files-for-radmc-3d-for-aligned-grains}}
\sphinxAtStartPar
In RADMC\sphinxhyphen{}3D we implement the functions \(\kappa_{\mathrm{abs},\nu,h}\) and
\(\kappa_{\mathrm{abs},\nu,v}\) as a function of angle \(\theta\) which the
alignment axis makes with the light of sight. For \(\theta\) we see the oblate
grain from the top (face\sphinxhyphen{}on), so that there is no asymmetry between
horizontal (orthogonal to the alignment orientation vector) and vertical
(parallel to the alignment orientation vector). Then we will have
\(\kappa_{\mathrm{abs},\nu,h}=\kappa_{\mathrm{abs},\nu,v}\). For
\(\theta=90^{\circ}\) we will have the maximum difference between
\(\kappa_{\mathrm{abs},\nu,h}\) and \(\kappa_{\mathrm{abs},\nu,v}\). We write

\phantomsection\label{\detokenize{dustradtrans:eq-align-kappa-k-hv}}\begin{equation*}
\begin{split}\begin{split}
\kappa_{\mathrm{abs},\nu,h}(\theta) &= \kappa_{\mathrm{abs},\nu}\,k_{\nu,h}(\theta)\\
\kappa_{\mathrm{abs},\nu,v}(\theta) &= \kappa_{\mathrm{abs},\nu}\,k_{\nu,v}(\theta)
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(k_{\nu,h}(\theta)\) and \(k_{\nu,v}(\theta)\) are dimensionless
functions, and where we take \(\theta\in[0,90]\) (in degrees), or
equivalently \(\cos(\theta)\in [0,1]\). We impose the condition that if we
randomly orient this grain, the average opacity becomes the one we computed for
the randomly oriented grains:
\begin{equation*}
\begin{split}\int_0^\infty \frac{1}{2}\left[\kappa_{\mathrm{abs},\nu,h}(\theta)
+\kappa_{\mathrm{abs},\nu,v}(\theta)\right]d\mu = \kappa_{\mathrm{abs},\nu}\end{split}
\end{equation*}
\sphinxAtStartPar
This yields the following integration condition on the dimensionless
\(k_{\nu,h}\) and \(k_{\nu,v}\):
\begin{equation*}
\begin{split}\int_0^\infty \frac{1}{2}\left[k_{\nu,h}(\theta)+k_{\nu,v}(\theta)\right]d\mu = 1\end{split}
\end{equation*}
\sphinxAtStartPar
If we set, for all values of \(\theta\),
\(k_{\nu,h}(\theta)=k_{\nu,v}(\theta)=1\) then we retrieve the result for
spherical grains.

\sphinxAtStartPar
In RADMC\sphinxhyphen{}3D the functions \(k_{\nu,h}(\theta)\) and \(k_{\nu,v}(\theta)\)
are read in via the file \sphinxcode{\sphinxupquote{dustkapalignfact\_*.inp}}. This file
has the following structure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Any amount of arbitrary}
\PYG{c+c1}{\PYGZsh{} comment lines that tell which opacity this is.}
\PYG{c+c1}{\PYGZsh{} Each comment line must start with an \PYGZsh{} or ; or ! character}
\PYG{n}{iformat}                            \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{nlam}                               \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Nr} \PYG{n}{of} \PYG{n}{wavelengths}
\PYG{n}{nmu}                                \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Nr} \PYG{n}{of} \PYG{n}{angles} \PYG{n}{sampled}
\PYG{k}{lambda}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}                          \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Wavelength} \PYG{n}{grid} \PYG{o+ow}{in} \PYG{n}{micron}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{k}{lambda}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}
\PYG{n}{theta}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}                           \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Angle} \PYG{n}{grid} \PYG{o+ow}{in} \PYG{n}{degrees}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{theta}\PYG{p}{[}\PYG{n}{nmu}\PYG{p}{]}
\PYG{n}{k\PYGZus{}orth}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}       \PYG{n}{k\PYGZus{}para}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}      \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{The} \PYG{n}{arrays} \PYG{n}{k\PYGZus{}orth} \PYG{o+ow}{and} \PYG{n}{k\PYGZus{}para}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{k\PYGZus{}orth}\PYG{p}{[}\PYG{n}{nmu}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}     \PYG{n}{k\PYGZus{}para}\PYG{p}{[}\PYG{n}{nmu}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{k\PYGZus{}orth}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}       \PYG{n}{k\PYGZus{}para}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{k\PYGZus{}orth}\PYG{p}{[}\PYG{n}{nmu}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}     \PYG{n}{k\PYGZus{}para}\PYG{p}{[}\PYG{n}{nmu}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{k\PYGZus{}orth}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{nlam}\PYG{p}{]}    \PYG{n}{k\PYGZus{}para}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{nlam}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{k\PYGZus{}orth}\PYG{p}{[}\PYG{n}{nmu}\PYG{p}{,}\PYG{n}{nlam}\PYG{p}{]}  \PYG{n}{k\PYGZus{}para}\PYG{p}{[}\PYG{n}{nmu}\PYG{p}{,}\PYG{n}{nlam}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The angles \sphinxcode{\sphinxupquote{theta}} are in degrees and must start at 0 and end at 90, or vice
versa.  The \sphinxcode{\sphinxupquote{nmu}} does not have to be the same (and the angles do not have to
be the same) as those in the \sphinxcode{\sphinxupquote{dustkapscatmat\_*.inp}} file. But the wavelength
grid must be identical to the one in the \sphinxcode{\sphinxupquote{dustkapscatmat\_*.inp}} file.

\sphinxAtStartPar
In order to make RADMC\sphinxhyphen{}3D read this file \sphinxcode{\sphinxupquote{dustkapalignfact\_*.inp}} the
\sphinxcode{\sphinxupquote{dustopac.inp}} file should, for this particular dust species, have ‘20’ as the
way in which this dust species is read (instead of 10 which is used for
polarized scattering with the Z matrix).

\sphinxAtStartPar
In addition, RADMC\sphinxhyphen{}3D also needs to know the orientation direction of the
grains. This is a vector field \(\vec p_{\mathrm{align}}(\vec x)\). The
length of these vectors should be between 0 and 1, where 1 means that the grains
are perfectly aligned and 0 means they are not aligned at all. The efficiency
\(\epsilon_{\mathrm{align}}\) is thus given by
\begin{equation*}
\begin{split}\epsilon_{\mathrm{align}}(\vec x) =|\vec p_{\mathrm{align}}(\vec x)|\end{split}
\end{equation*}
\sphinxAtStartPar
The directional unit\sphinxhyphen{}vector of alignment \(\vec n_{\mathrm{align}}(\vec x)\)
is thus
\begin{equation*}
\begin{split}\vec n_{\mathrm{align}}(\vec x) = \big(\epsilon_{\mathrm{align}}(\vec x)\big)^{-1}\vec p_{\mathrm{align}}(\vec x)\end{split}
\end{equation*}
\sphinxAtStartPar
The \(\vec p_{\mathrm{align}}(\vec x)\) vector field is in
the file \sphinxcode{\sphinxupquote{grainalign\_dir.inp}} (or its binary formatted version
\sphinxcode{\sphinxupquote{grainalign\_dir.binp}}). The format of this file is exactly the
same as that of the gas velocity file \sphinxcode{\sphinxupquote{gas\_velocity.inp}}. The
ascii format looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{nrcells}
\PYG{n}{p\PYGZus{}x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}       \PYG{n}{p\PYGZus{}y}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}       \PYG{n}{p\PYGZus{}z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}
\PYG{n}{p\PYGZus{}x}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{]} \PYG{n}{p\PYGZus{}y}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{]} \PYG{n}{p\PYGZus{}z}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that \(|\vec p_{\mathrm{align}}(\vec x)|\) should never be
\(>1\). If it is found to be significantly \(>1\) at some point in the
grid, then an error occurs. If it is only a tiny bit above 1, due to rounding
errors, it will be normalized to 1.

\sphinxAtStartPar
The way in which partial alignment (\(0<\epsilon_{\mathrm{align}}<1\)) is
treated in RADMC\sphinxhyphen{}3D is to treat the opacities and emissivities as simple
linear sums of fully aligned and non aligned versions. For instance,
Eqs. (\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}align\sphinxhyphen{}kappa\sphinxhyphen{}k\sphinxhyphen{}h}, \DUrole{xref,std,std-ref}{eq\sphinxhyphen{}align\sphinxhyphen{}kappa\sphinxhyphen{}k\sphinxhyphen{}v}) then become
\begin{equation*}
\begin{split}\begin{split}
\kappa_{\mathrm{abs},\nu,h}(\theta) &= \kappa_{\mathrm{abs},\nu}\,[\epsilon_{\mathrm{align}}k_{\nu,h}(\theta)+1-\epsilon_{\mathrm{align}}] \\
\kappa_{\mathrm{abs},\nu,v}(\theta) &= \kappa_{\mathrm{abs},\nu}\,[\epsilon_{\mathrm{align}}k_{\nu,v}(\theta)+1-\epsilon_{\mathrm{align}}]
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
In order to tell RADMC\sphinxhyphen{}3D that it should include the effect of alignment on the
thermal emission of dust grains one must add a line in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file
with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{alignment\PYGZus{}mode} \PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
The example model in \sphinxcode{\sphinxupquote{examples/run\_simple\_1\_align/}} demonstrates how the input
files have to be made to have RADMC\sphinxhyphen{}3D treat the aligned dust grains for thermal
emission.


\subsection{Effect of aligned grains on the scattering}
\label{\detokenize{dustradtrans:effect-of-aligned-grains-on-the-scattering}}\label{\detokenize{dustradtrans:sec-align-scat}}
\sphinxAtStartPar
\sphinxstyleemphasis{This is, currently, not yet implemented.}


\section{Grain size distributions}
\label{\detokenize{dustradtrans:grain-size-distributions}}\label{\detokenize{dustradtrans:sec-grain-size-distributions}}

\subsection{Quick summary of how to implement grain sizes}
\label{\detokenize{dustradtrans:quick-summary-of-how-to-implement-grain-sizes}}\label{\detokenize{dustradtrans:sec-grain-size-distributions-overview}}
\sphinxAtStartPar
A common application of RADMC\sphinxhyphen{}3D is continuum radiative transfer in media with a
grain size distribution. RADMC\sphinxhyphen{}3D does not know the concept of “grain size
distribution”, and it does not care. You have to provide RADMC\sphinxhyphen{}3D will all the
information it needs, such that it will handle the dust size distribution you
want. All the responsibility lies with you, the user.

\sphinxAtStartPar
There are basically two ways by which you can make RADMC\sphinxhyphen{}3D treat a grain size
distribution:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Method 1: Mixing the dust opacities into a single opacity file, having
RADMC\sphinxhyphen{}3D think that there is only one dust species. Fast and simple.

\item {} 
\sphinxAtStartPar
Method 2: Computing \(N\) dust opacity files, having \(N\) independent
dust species. Slower but more realistic and flexible.

\end{itemize}

\sphinxAtStartPar
In the following subsections we will discuss both methods.


\subsection{Method 1: Size distribution in the opacity file (faster)}
\label{\detokenize{dustradtrans:method-1-size-distribution-in-the-opacity-file-faster}}\label{\detokenize{dustradtrans:sec-grain-size-distributions-method-1}}
\sphinxAtStartPar
The simplest way is to compute a single dust opacity table (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-opacities}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dustopac.inp and dustkappa\_*.inp or dustkapscatmat\_*.inp or dust\_optnk\_*.inp}}}}) for a single dust species. You compute the weighted dust
opacity and put that into the file \sphinxcode{\sphinxupquote{dustkappa\_XXX.inp}} (for instance let’s
call it \sphinxcode{\sphinxupquote{dustkappa\_sizedistrib.inp}}) or \sphinxcode{\sphinxupquote{dustkapscatmat\_XXX.inp}} (for
instance let’s call it \sphinxcode{\sphinxupquote{dustkapscatmat\_sizedistrib.inp}}).  All the information
about the size distribution shape is then encoded in this opacity file, and
RADMC\sphinxhyphen{}3D will never know that it is, in fact, a size distribution. The file
\sphinxcode{\sphinxupquote{dust\_density.inp}} will then only contain the spatial distribution of a single
grain species: that of the mixture of sizes. Advantage: it is the
easiest. Disadvantage: the size distribution will be identical
everywhere. Another disadvantage: each grain size will have the same temperature
(because RADMC\sphinxhyphen{}3D does not know that these are different dust sizes).

\sphinxAtStartPar
This method be useful to save computer time. You essentially do all the work of
computing the opacity of the size distribution beforehand (even before you start
RADMC\sphinxhyphen{}3D), so that you get a single opacity file that already contains the
size\sphinxhyphen{}distribution\sphinxhyphen{}weighted opacities. You must then be sure that you do the
weighting such that the opacity is “cross section per gram of dust”, where
“dust” is already the entire grain size distribution. The dust density in the
\sphinxcode{\sphinxupquote{dust\_density.inp}} file must then also be the density of the entire grain size
distribution. See Section {\hyperref[\detokenize{dustradtrans:sec-math-of-grain-size-distributions}]{\sphinxcrossref{\DUrole{std,std-ref}{The mathematics of grain size distributions}}}} for more
information about size distributions.


\subsection{Method 2: Size distribution in the density file (better)}
\label{\detokenize{dustradtrans:method-2-size-distribution-in-the-density-file-better}}\label{\detokenize{dustradtrans:sec-grain-size-distributions-method-2}}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D can handle multiple dust species simultaneously and co\sphinxhyphen{}spatially. So
you can have \(N\) grain sizes, each represented by its own opacity file and
its own spatial density distribution. So if we, for example, have two sizes, 1
micron and 1 millimeter (i.e. \(N=2\)) then we would have, for instance, two
opacity files, \sphinxcode{\sphinxupquote{dustkappa\_1micron.inp}} and \sphinxcode{\sphinxupquote{dustkappa\_1mm.inp}} (don’t forget
to mark them both in \sphinxcode{\sphinxupquote{dustopac.inp}} too), and within the \sphinxcode{\sphinxupquote{dust\_density.inp}}
file we have two density fields. This allows you, for instance, to have the
large grains near the midplane of a disk and the small grains vertically more
extended, because you can determine the density \(\rho\) of each dust
species completely independent from the others.

\sphinxAtStartPar
We have now two choices how to handle these species: (a) thermally coupled (set
\sphinxcode{\sphinxupquote{itempdecoup = 0}} in \sphinxcode{\sphinxupquote{radmc3d.inp}}, see section {\hyperref[\detokenize{inputoutputfiles:sec-radmc-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: radmc3d.inp}}}}, or (b)
thermally decoupled (default, but you can set \sphinxcode{\sphinxupquote{itempdecoup = 1}} in
\sphinxcode{\sphinxupquote{radmc3d.inp}} to make sure). The default is thermally decoupled, because that
is for most cases more realistic. If the grains are thermally decoupled, then,
in the optically thin regions exposed to hot stellar radiation, the small grains
tend to be hotter than the large ones. However, in optically thick regions the
small and large grains will tend to automatically acquire similar or the same
temperature(s).

\sphinxAtStartPar
Compared to the first method (with a single dust species), this method is more
flexible (allowing different spatial distributions for different grain sizes)
but also more costly (requiring the radiative transfer code to handle the
interaction of the radiation with \(N\) independent dust species). You must
then calculate each grain opacity file separately, and keep these normalized to
“cross section per gram of this particular dust species or size”. Here, the
weighting is not done in the opacity files, but in the fact that each grain size
(or species) \(i\) has its own density \(\rho_i\). You would then need
to make sure that these \(\rho_i\) are following the size distribution you
wish. See Section {\hyperref[\detokenize{dustradtrans:sec-math-of-grain-size-distributions}]{\sphinxcrossref{\DUrole{std,std-ref}{The mathematics of grain size distributions}}}} for more
information about size distributions.


\subsection{The mathematics of grain size distributions}
\label{\detokenize{dustradtrans:the-mathematics-of-grain-size-distributions}}\label{\detokenize{dustradtrans:sec-math-of-grain-size-distributions}}
\sphinxAtStartPar
Grain size distributions can be confusing, so here is a small tutorial.
Suppose we have the famous MRN (Mathis, Rumpl, Nordsieck) size distribution:
\begin{equation*}
\begin{split}n(a)da \propto a^{-7/2}da\end{split}
\end{equation*}
\sphinxAtStartPar
with \(a\) the radius of the grain, \(n(a)da\) the number of grains
between sizes \(a\) and \(a+da\) per volume. We say that this
powerlaw goes from \(a=a_{\mathrm{min}}\) to \(a=a_{\mathrm{max}}\),
and we keep in mind that \(a_{\mathrm{max}}\) can be (but does not
have to) orders of magnitude larger than \(a_{\mathrm{min}}\).
The total dust density \(\rho\) is:
\begin{equation*}
\begin{split}\rho = \int_{a_{\mathrm{min}}}^{a_{\mathrm{max}}} m(a)n(a)da\end{split}
\end{equation*}
\sphinxAtStartPar
where \(m(a)\) is the mass of the grain:
\begin{equation*}
\begin{split}m(a) = \rho_s \frac{4\pi}{3}a^3\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\rho_s\) is the material density of the grain material (typically
somewhere between 1 and 3.6 \(\mathrm{gram}/\mathrm{cm}^3\), dependent on the material).

\sphinxAtStartPar
For RADMC\sphinxhyphen{}3D we have to disretize this into \(N\) bins. Since we can have
\(a_{\mathrm{max}}\gg a_{\mathrm{min}}\), it is best to take a logarithmic
grid in \(a\), i.e. equal spacing in \(\ln(a)\).  So we divide the
interval \([\ln(a_{\mathrm{min}}),\ln(a_{\mathrm{max}})]\) up into \(N\)
equal size bins, numbering \(i=0\) to \(i=N-1\), with cell centers
denoted as \(\ln(a_i)\) and the cell walls are denoted as
\(\ln(a_{i-1/2})\) for the left\sphinxhyphen{} and \(\ln(a_{i+1/2})\) for the
right\sphinxhyphen{}hand cell wall. We have \(\ln(a_{-1/2})=\ln(a_{\mathrm{min}})\) and
\(\ln(a_{N-1/2})=\ln(a_{\mathrm{max}})\). For any \(i\) we have the same
cell width in log\sphinxhyphen{}space:
\(\Delta\ln(a)=\Delta\ln(a_i)=\ln(a_{i+1/2})-\ln(a_{i-1/2})\).
Now the density for each bin is:
\begin{equation*}
\begin{split}\rho_i = \int_{a_{i-1/2}}^{a_{i+1/2}} m(a)\,n(a)\,da = \int_{\ln(a_{i-1/2})}^{\ln(a_{i+1/2})} a\,m(a)\,n(a)\,d\ln(a)\end{split}
\end{equation*}
\sphinxAtStartPar
If the bin width \(\Delta\ln(a)\) is small enough, this can be approximated
as
\begin{equation*}
\begin{split}\rho_i \simeq a_i m(a_i)n(a_i)\Delta\ln(a)\end{split}
\end{equation*}
\sphinxAtStartPar
The total dust density is then
\begin{equation*}
\begin{split}\rho = \sum_{i=0}^{N-1} \rho_i\end{split}
\end{equation*}
\sphinxAtStartPar
The opacity for bin \(i\) at some frequency \(\nu\) is approximately \(\kappa_\nu(a_i)\)
if a small enough bin size is used. That means that the extinction coefficient
\begin{equation*}
\begin{split}\alpha_\nu = \sum_{i=0}^{N-1} \rho_i\kappa_\nu(a_i)\end{split}
\end{equation*}
\sphinxAtStartPar
In method 2 (Section {\hyperref[\detokenize{dustradtrans:sec-grain-size-distributions-method-2}]{\sphinxcrossref{\DUrole{std,std-ref}{Method 2: Size distribution in the density file (better)}}}}) this is exactly what happens:
you specify \(N\) tables of \(\kappa_\nu(a_i)\) (each table containing all frequencies
for which you want to use the opacity), and the “mixing” happens in each grid cell on\sphinxhyphen{}the\sphinxhyphen{}fly
depending on the local values of \(\rho_i\). The values of \(\rho_i\) in the file
\sphinxcode{\sphinxupquote{dust\_density.inp}} are exactly these \(\rho_i\).

\sphinxAtStartPar
On the contrary, in method 1 (Section {\hyperref[\detokenize{dustradtrans:sec-grain-size-distributions-method-1}]{\sphinxcrossref{\DUrole{std,std-ref}{Method 1: Size distribution in the opacity file (faster)}}}}), you compute
a nomalized \(\hat n(a_i)\) such that
\begin{equation*}
\begin{split}\sum_{i=0}^{N-1}  a_i m(a_i)\hat n(a_i)\Delta\ln(a) = 1\end{split}
\end{equation*}
\sphinxAtStartPar
so that with
\begin{equation*}
\begin{split}\hat\rho_i \simeq a_i m(a_i)\hat n(a_i)\Delta\ln(a)\end{split}
\end{equation*}
\sphinxAtStartPar
we get
\begin{equation*}
\begin{split}\sum_{i=0}^{N-1}  \hat\rho_i = 1\end{split}
\end{equation*}
\sphinxAtStartPar
Now we can compute a grain\sphinxhyphen{}size\sphinxhyphen{}mean opacity:
\begin{equation*}
\begin{split}\hat\kappa_\nu = \sum_{i=0}^{N-1} \hat\rho_i\kappa_\nu(a_i)\end{split}
\end{equation*}
\sphinxAtStartPar
which is computed before running RADMC\sphinxhyphen{}3D, and will be valid at all locations in the spatial grid.
At each cell we only have the total dust density \(\rho\). The extinction coefficient is
then
\begin{equation*}
\begin{split}\alpha_\nu = \rho\hat\kappa_\nu\end{split}
\end{equation*}
\sphinxstepscope


\chapter{Line radiative transfer}
\label{\detokenize{lineradtrans:line-radiative-transfer}}\label{\detokenize{lineradtrans:chap-line-transfer}}\label{\detokenize{lineradtrans::doc}}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D is capable of modeling radiative transfer in molecular and/or
atomic lines. Due to the complexity of line radiative transfer, and the huge
computational and memory requirements of full\sphinxhyphen{}scale non\sphinxhyphen{}LTE line transfer,
RADMC\sphinxhyphen{}3D has various different modes of line transfer. Some modes are very
memory efficient, but slower, while others are faster, but less memory
efficient, yet others are more accurate but much slower and memory
demanding. The default mode (and certainly recommended initially) is LTE
ray\sphinxhyphen{}tracing in the slow but memory efficient way: the \sphinxstyleemphasis{simple LTE mode}
(see Section {\hyperref[\detokenize{lineradtrans:sec-line-trans-modes}]{\sphinxcrossref{\DUrole{std,std-ref}{Line transfer modes and how to activate the line transfer}}}}). Since this is the default mode,
you do not need to specify anything to have this selected.


\section{Quick start for adding line transfer to images and spectra}
\label{\detokenize{lineradtrans:quick-start-for-adding-line-transfer-to-images-and-spectra}}
\sphinxAtStartPar
Do properly model line transfer requires dedication and experimentation.
This is \sphinxstyleemphasis{not} a simple task. See Section {\hyperref[\detokenize{lineradtrans:sec-lines-pitfalls}]{\sphinxcrossref{\DUrole{std,std-ref}{What can go wrong with line transfer?}}}} for an
analysis of several pitfalls one may encounter. However, nothing is better
than experimenting and thus gaining hands\sphinxhyphen{}on experience. So the easiest and
quickest way to start is to start with one of the simple line transfer test
models in the \sphinxcode{\sphinxupquote{examples/}} directory.

\sphinxAtStartPar
So simply visit \sphinxcode{\sphinxupquote{examples/run\_test\_lines\_1/}}, \sphinxcode{\sphinxupquote{examples/run\_test\_lines\_2/}}
or \sphinxcode{\sphinxupquote{examples/run\_test\_lines\_3/}} and follow the directions in the \sphinxcode{\sphinxupquote{README}} file.
The main features of adding line ray tracing to a model is
to add the following files into any previously constructed model with dust
radiative transfer:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lines.inp}}: A control file for line transfer.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{molecule\_co.inp}}: or any other molecular data file
containing properties of the molecule or atom.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{numberdens\_co.inp}} (or its binary version, see Chapter
{\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}}) or that of another molecule: The number density of
that molecule in units of \(\mathrm{cm}^{-3}\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gas\_temperature.inp}} (or its binary version, see Chapter
{\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}}): The gas temperature at each grid cell. You do not
need to specify this file if you add the keyword \sphinxcode{\sphinxupquote{tgas\_eq\_tdust = 1}}
into the \sphinxcode{\sphinxupquote{radmc3d.inp}} file.

\end{itemize}


\section{Some definitions for line transfer}
\label{\detokenize{lineradtrans:some-definitions-for-line-transfer}}\label{\detokenize{lineradtrans:sec-line-trans-definitions}}
\sphinxAtStartPar
The formal transfer equation is:
\begin{equation*}
\begin{split}\frac{dI_\nu(\omega)}{ds} = j_\nu(\omega) - \alpha_\nu(\omega)I_\nu(\omega)\end{split}
\end{equation*}
\sphinxAtStartPar
which is true also for the lines. Here \(\omega\) is the direction,
\(\nu\) the frequency, \(I\) the intensity.  The emissivity
\(j_\nu\) and extinction \(\alpha_\nu\) for each line (given by
\(i\) =upper level and \(j\) =lower level) is given by:

\phantomsection\label{\detokenize{lineradtrans:eq-molec-emis-def}}\phantomsection\label{\detokenize{lineradtrans:eq-molec-extinct-def}}\begin{equation*}
\begin{split}\begin{split}
j_{ij}(\Omega,\nu) &= \frac{h\nu}{4\pi}Nn_iA_{ij}
\varphi_{ij}(\omega,\nu) \\
\alpha_{ij}(\omega,\nu) &= \frac{h\nu}{4\pi}N(n_jB_{ji}-n_iB_{ij})
\varphi_{ij}(\omega,\nu)
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
Here \(N\) is the number density of the molecule, \(n_i\) is the \sphinxstyleemphasis{fraction} of the molecules that are in level \(i\), \(A_{ij}\) is the
Einstein coefficient for spontaneous emission from level \(i\) to level
\(j\), and \(B_{ij}\) and \(B_{ji}\) are the Einstein\sphinxhyphen{}B\sphinxhyphen{}coefficients which obey:
\begin{equation*}
\begin{split}A_{ij}     = \frac{2h\nu_{ij}^3}{c^2} B_{ij},
B_{ji}g_j  = B_{ij} g_i\end{split}
\end{equation*}
\sphinxAtStartPar
where \(g\) are the statistical weights of the levels, \(h\) the Planck constant
and \(c\) the light speed. The symbol \(\varphi_{ij}(\omega,\nu)\) is the line
profile function. For zero velocity field
\(\varphi_{ij}(\omega,\nu)=\tilde\varphi_{ij}(\nu)\), i.e. the line profile
function is independent of direction. The tilde is to say that this is
the comoving line profile. It is given by
\begin{equation*}
\begin{split}\tilde\varphi_{ij}(\nu) = \frac{c}{a_{\mathrm{tot}}\nu_{ij}\sqrt{\pi}}
\exp\left(-\frac{c^2(\nu-\nu_{ij})^2}{a_{\mathrm{tot}}^2\nu_{ij}^2}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\nu_{ij}\) is the line\sphinxhyphen{}center frequency for the line and
\(a_{\mathrm{tot}}\) is the line width in units of cm/s. For pure
thermal broadning we have
\begin{equation*}
\begin{split}a_{\mathrm{tot}}=a_{\mathrm{therm}}=\sqrt{\frac{2kT_{\mathrm{gas}}}{m_{\mathrm{mol}}}}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(m_{\mathrm{mol}}\) is the weight of the molecule in gram, \(k\) is the
Boltzmann constant, \(T_{\mathrm{gas}}\) the gas temperature in K. As we shall
discuss in Section {\hyperref[\detokenize{lineradtrans:sec-turb-broadening}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The local microturbulent broadening (optional)}}}}: we can also add
‘microturbulent line broadning’ \(a_{\mathrm{turb}}\), also in cm/s:
\begin{equation*}
\begin{split}a_{\mathrm{tot}}=\sqrt{a^2_{\mathrm{turb}}+a^2_{\mathrm{therm}}}=
\sqrt{a^2_{\mathrm{turb}}+\frac{2kT_{\mathrm{gas}}}{m_{\mathrm{mol}}}}\end{split}
\end{equation*}
\sphinxAtStartPar
When we have macroscopic velocities in our model, then the line profile
becomes angle\sphinxhyphen{}dependent (at a given lab\sphinxhyphen{}frame frequency):
\begin{equation*}
\begin{split}\varphi_{ij}(\omega,\nu) = \tilde\varphi_{ij}\big(\nu(1-\vec\omega\cdot \vec v/c)-\nu_{ij}\big)\end{split}
\end{equation*}
\sphinxAtStartPar
The radiative transfer equation for non overlapping lines is then

\phantomsection\label{\detokenize{lineradtrans:eq-molec-rad-trans-eq}}\begin{equation*}
\begin{split}\frac{dI_{ij}(\omega,\nu)}{ds} = j_{ij}(\omega,\nu) -
\alpha_{ij}(\omega,\nu) I_{ij}(\omega,\nu)\,.\end{split}
\end{equation*}
\sphinxAtStartPar
But RADMC\sphinxhyphen{}3D naturally includes overlapping lines, at least in the
ray\sphinxhyphen{}tracing (for spectra and images). For non\sphinxhyphen{}LTE modes the line
overlapping is not yet (as of December 2011) included.


\section{Line transfer modes and how to activate the line transfer}
\label{\detokenize{lineradtrans:line-transfer-modes-and-how-to-activate-the-line-transfer}}\label{\detokenize{lineradtrans:sec-line-trans-modes}}
\sphinxAtStartPar
Line transfer can be done in various different ways. This is controlled by the
global variable \sphinxcode{\sphinxupquote{lines\_mode}} (see below) and by the nature of the
molecular/atomic data (see discussion in Section {\hyperref[\detokenize{lineradtrans:sec-line-dot-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The line.inp file}}}}).


\subsection{Two different atomic/molecular data file types}
\label{\detokenize{lineradtrans:two-different-atomic-molecular-data-file-types}}
\sphinxAtStartPar
Let us start with the latter: RADMC\sphinxhyphen{}3D does not have any atomic or molecular
data hard\sphinxhyphen{}coded inside. It reads these data from data files that you provide.
There are two fundamentally different ways to feed atomic/molecular data into
RADMC\sphinxhyphen{}3D:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Files containing the full level and line information (named \sphinxcode{\sphinxupquote{molecule\_XXX.inp}}, where \sphinxcode{\sphinxupquote{XXX}} is the name of the molecule or
atom). Atoms or molecules for which this data is provided can be treated
in LTE as well as in non\sphinxhyphen{}LTE.

\item {} 
\sphinxAtStartPar
Files containing only a line list (named \sphinxcode{\sphinxupquote{linelist\_XXX.inp}}, where \sphinxcode{\sphinxupquote{XXX}} is the name of the molecule or
atom). Atoms or molecules for which this data is provided can only be
treated in LTE.

\end{itemize}


\subsection{The different line modes (the \sphinxstyleliteralintitle{\sphinxupquote{lines\_mode parameter}})}
\label{\detokenize{lineradtrans:the-different-line-modes-the-lines-mode-parameter}}\label{\detokenize{lineradtrans:sec-lines-mode}}
\sphinxAtStartPar
For the atoms or molecules for which the full data are specified (the
\sphinxcode{\sphinxupquote{molecule\_XXX.inp}} files) RADMC\sphinxhyphen{}3D has various different line
transfer modes, including different treatments of LTE or non\sphinxhyphen{}LTE. Which of
the modes you want RADMC\sphinxhyphen{}3D to use can be specified in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file by setting the variable \sphinxcode{\sphinxupquote{lines\_mode}}, for
instance, by adding the following line to \sphinxcode{\sphinxupquote{radmc3d.inp}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lines\PYGZus{}mode} \PYG{o}{=} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\sphinxAtStartPar
for LVG + Escape Probability populations. If no option is given, then the \sphinxstyleemphasis{LTE mode}
(\sphinxcode{\sphinxupquote{lines\_mode=1}}) is used.

\sphinxAtStartPar
The various line modes are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{LTE mode (=default mode):} {[}\sphinxcode{\sphinxupquote{lines\_mode=1}}{]}

\sphinxAtStartPar
In this mode the line radiative transfer is done under LTE assumptions.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{User\sphinxhyphen{}defined populations:} {[}\sphinxcode{\sphinxupquote{lines\_mode=2}}{]}

\sphinxAtStartPar
This calls the routine \sphinxcode{\sphinxupquote{userdef\_compute\_levelpop()}} to compute
the level populations. This allows the user to specify the populations of
the levels of the molecules freely.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Large Velocity Gradient (Sobolev) populations:} {[}\sphinxcode{\sphinxupquote{lines\_mode=3}}{]}

\sphinxAtStartPar
This is one of the non\sphinxhyphen{}LTE modes of RADMC\sphinxhyphen{}3D. This mode calculates the
angle\sphinxhyphen{}averaged velocity gradient, and uses this to compute the level
populations according to the Large Velocity Gradient method (also often
called Sobolev’s method). This method is like an escape probability
method, where the escape probability is calculated based on the velocity
gradient. For this mode to work, the velocity field has to be read in, as
well as at least one of the number densities of the collision partners of
the molecule. See Section {\hyperref[\detokenize{lineradtrans:sec-lvg}]{\sphinxcrossref{\DUrole{std,std-ref}{Non\sphinxhyphen{}LTE Transfer: The Large Velocity Gradient (LVG) + Escape Probability (EscProb) method}}}}.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Optically Thin non\sphinxhyphen{}LTE level populations method:} {[}\sphinxcode{\sphinxupquote{lines\_mode=4}}{]}

\sphinxAtStartPar
This is one of the non\sphinxhyphen{}LTE modes of RADMC\sphinxhyphen{}3D. This mode calculates the
non\sphinxhyphen{}LTE level populations under the assumption that all emitted line
radiation escapes and is not reabsorbed. For this mode to work, at least
one of the number densities of the collision partners of the molecule. See
Section {\hyperref[\detokenize{lineradtrans:sec-optthinpop}]{\sphinxcrossref{\DUrole{std,std-ref}{Non\sphinxhyphen{}LTE Transfer: The optically thin line assumption method}}}}.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{User\sphinxhyphen{}defined populations:} {[}\sphinxcode{\sphinxupquote{lines\_mode=\sphinxhyphen{}10}}{]}

\sphinxAtStartPar
This calls the routine \sphinxcode{\sphinxupquote{userdef\_general\_compute\_levelpop()}}
on\sphinxhyphen{}the\sphinxhyphen{}fly during the ray\sphinxhyphen{}tracing. This is very much like
\sphinxcode{\sphinxupquote{userdef\_compute\_levelpop()}}, except that it leaves the
entire line\sphinxhyphen{}related stuff to the user: It does not read the molecular
data from a file. NOTE: This is a rather tricky mode, to be used only
if you know very well what you are doing…

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Full non\sphinxhyphen{}LTE modes:} \{bf Not yet ready\}

\end{itemize}

\sphinxAtStartPar
The default of the \sphinxcode{\sphinxupquote{lines\_mode}} variable is \sphinxcode{\sphinxupquote{lines\_mode=1}}.

\sphinxAtStartPar
\sphinxstylestrong{NOTE 1:} Line emission is automatically included in the images and spectra if
RADMC\sphinxhyphen{}3D finds the file \sphinxcode{\sphinxupquote{lines.inp}} in the model directory. You can switch off
the lines with the command\sphinxhyphen{}line option \sphinxcode{\sphinxupquote{\textquotesingle{}noline\textquotesingle{}}}.

\sphinxAtStartPar
\sphinxstylestrong{NOTE 2:} If you are very limited by memory, and if you use LTE, LVG+EscProb
or optically thin populations, you can also ask RADMC\sphinxhyphen{}3D to \sphinxstyleemphasis{not} precalculate
the level populations before the rendering, but instead compute them
on\sphinxhyphen{}the\sphinxhyphen{}fly. This makes the code slower, but requires less memory.  You can do
this by choosing e.g. \sphinxcode{\sphinxupquote{lines\_mode=\sphinxhyphen{}3}} instead of \sphinxcode{\sphinxupquote{lines\_mode=3}} (for
LVG+EscProb).


\section{The various input files for line transfer}
\label{\detokenize{lineradtrans:the-various-input-files-for-line-transfer}}

\subsection{INPUT: The line transfer entries in the radmc3d.inp file}
\label{\detokenize{lineradtrans:input-the-line-transfer-entries-in-the-radmc3d-inp-file}}\label{\detokenize{lineradtrans:sec-line-radmc-inp}}
\sphinxAtStartPar
Like all other modules of \sphinxcode{\sphinxupquote{radmc3d}}, also the line module
can be steered through keywords in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file.
Here is a list:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tgas\_eq\_tdust}} (default: 0)

\sphinxAtStartPar
Normally you must specify the gas temperature at each grid cell using the
\sphinxcode{\sphinxupquote{gas\_temperature.inp}} file (or directly in the \sphinxcode{\sphinxupquote{userdef\_module.f90}}, see
Chapter {\hyperref[\detokenize{internalsetup:chap-internal-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Modifying RADMC\sphinxhyphen{}3D: Internal setup and user\sphinxhyphen{}specified radiative processes}}}}). But sometimes you may want to compute
first the dust temperature and then set the gas temperature equal to the dust
temperature. You can do this obviously by hand: read the output dust
temperature and create the equivalent gas temperature input file from it. But
that is cumbersome.  By setting \sphinxcode{\sphinxupquote{tgas\_eq\_tdust=1}} you tell \sphinxcode{\sphinxupquote{radmc3d}} to
simply read the \sphinxcode{\sphinxupquote{dust\_temperature.dat}} file and then equate the gas
temperature to the dust temperature. If multiple dust species are present,
only the first species will be used.

\end{itemize}


\subsection{INPUT: The line.inp file}
\label{\detokenize{lineradtrans:input-the-line-inp-file}}\label{\detokenize{lineradtrans:sec-line-dot-inp}}
\sphinxAtStartPar
Like with the dust (which has this \sphinxcode{\sphinxupquote{dustopac.inp}} master file,
also the line module has a master file: \sphinxcode{\sphinxupquote{lines.inp}}. It specifies
which molecules/atoms are to be modeled and in which file the
molecular/atomic data (such as the energy levels and the Einstein \(A\)
coefficients) are to be found

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Put} \PYG{n}{this} \PYG{n}{to} \PYG{l+m+mi}{2}
\PYG{n}{N}                                        \PYG{n}{Nr} \PYG{n}{of} \PYG{n}{molecular} \PYG{o+ow}{or} \PYG{n}{atomic} \PYG{n}{species} \PYG{n}{to} \PYG{n}{be} \PYG{n}{modeled}
\PYG{n}{molname1} \PYG{n}{inpstyle1} \PYG{n}{iduma1} \PYG{n}{idumb1} \PYG{n}{ncol1}   \PYG{n}{Which} \PYG{n}{molecule} \PYG{n}{used} \PYG{k}{as} \PYG{n}{species} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{other} \PYG{n}{info}
\PYG{o}{.}
\PYG{o}{.}
\PYG{o}{.}
\PYG{n}{molnameN} \PYG{n}{inpstyleN} \PYG{n}{idumaN} \PYG{n}{idumbN} \PYG{n}{ncolN}   \PYG{n}{Which} \PYG{n}{molecule} \PYG{n}{used} \PYG{k}{as} \PYG{n}{species} \PYG{n}{N} \PYG{o}{+} \PYG{n}{other} \PYG{n}{info}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{N}} is the number of molecular or atomic species you wish to
model. Typically this is 1. But if you want to \sphinxstyleemphasis{simultaneously} model for
instance the ortho\sphinxhyphen{}H$_{\text{2}}$O and para\sphinxhyphen{}H$_{\text{2}}$O infrared lines, you would
need to set this to 2.

\sphinxAtStartPar
The N lines following N (i.e. lines 3 to N+2) specify the molecule or atom, the
kind of input file format (explained below), and two integers which, at least
for now, can be simply set to 0 (see Section {\hyperref[\detokenize{lineradtrans:sec-line-selection}]{\sphinxcrossref{\DUrole{std,std-ref}{For experts: Selecting a subset of lines and levels ‘manually’}}}} for the
meaning of these integers \sphinxhyphen{} for experts only), plus finally third integer, which
has to do with non\sphinxhyphen{}LTE transfer: the number of collision partners (set to 0 if
you only intend to do LTE transfer).

\sphinxAtStartPar
The molecule name can be e.g. \sphinxcode{\sphinxupquote{co}} for carbon monoxide. The file
containing the data should then be called \sphinxcode{\sphinxupquote{molecule\_co.inp}} (even
if it is an atom rather than a molecule; I could not find a good name which
means both molecule or atom). This file should be either generated by the
user, or (which is obviously the preferred option) taken from one of the
databases of molecular/atomic radiative properties. Since there are a number
of such databases and I want the code to be able to read those files without
the need of casting them into some special RADMC\sphinxhyphen{}3D format, \sphinxcode{\sphinxupquote{radmc3d}} allows the user to select which \sphinxstyleemphasis{kind} of file
the \sphinxcode{\sphinxupquote{molecule\_co.inp}} (for CO) file is. At present only one
format is supported: the Leiden database. But more will follow. To
specify to \sphinxcode{\sphinxupquote{radmc3d}} to use the Leiden style, you put the
\sphinxcode{\sphinxupquote{inpstyle}} to ‘leiden’. So here is a typical example of a
\sphinxcode{\sphinxupquote{lines.inp}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{1}
\PYG{n}{co}   \PYG{n}{leiden}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
This means: one molecule will be modeled, namely CO (and thus read from the file
\sphinxcode{\sphinxupquote{molecule\_co.inp}}), and the data format is the Leiden database format.

\sphinxAtStartPar
NOTE: Since version 0.26 the file format number of this file \sphinxcode{\sphinxupquote{lines.inp}}
has increased. It is now 2, because in each line an extra integer is added.

\sphinxAtStartPar
NOTE: The files from the Leiden LAMDA database (see Section
{\hyperref[\detokenize{lineradtrans:sec-leiden-format}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}}) are usually called something like \sphinxcode{\sphinxupquote{co.dat}}. You will
have to simply rename to \sphinxcode{\sphinxupquote{molecule\_co.inp}}.

\sphinxAtStartPar
Most molecular data files have, in addition to the levels and radiative
rates, also the collision rates listed. See Section {\hyperref[\detokenize{lineradtrans:sec-leiden-format}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}}.
For non\sphinxhyphen{}LTE radiative transfer this is essential information. The number
densities of the collision partners (the particles with which the molecule
can collide and which can collisionally excited or de\sphinxhyphen{}excite the molecule)
are given in number density files with the same format as those of the
molecule itself (see Section {\hyperref[\detokenize{lineradtrans:sec-collpartner}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The number density of collision partners (for non\sphinxhyphen{}LTE transfer)}}}}). However, we must tell
RADMC\sphinxhyphen{}3D to which collision partner particle the rate tables listed in the
\sphinxcode{\sphinxupquote{molecule\_co.inp}} are associated (see Section
{\hyperref[\detokenize{lineradtrans:sec-collpartner}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The number density of collision partners (for non\sphinxhyphen{}LTE transfer)}}}} for a better explanation of the issue here). This can
be done with the last of the integers in each line. Example: if the
\sphinxcode{\sphinxupquote{lines.inp}} file reads:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{1}
\PYG{n}{co}   \PYG{n}{leiden}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{2}
\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{n}{h2}
\PYG{n}{o}\PYG{o}{\PYGZhy{}}\PYG{n}{h2}
\end{sphinxVerbatim}

\sphinxAtStartPar
this means that the first collision rate table (starting with the number
\sphinxcode{\sphinxupquote{3.2e\sphinxhyphen{}11}} in the example of Section {\hyperref[\detokenize{lineradtrans:sec-leiden-format}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}}) is for
collisions with particles for which the number density is given in the file
\sphinxcode{\sphinxupquote{numberdens\_p\sphinxhyphen{}h2.inp}} and the second collision rate table (starting with the
number \sphinxcode{\sphinxupquote{4.1e\sphinxhyphen{}11}} in the example of Section {\hyperref[\detokenize{lineradtrans:sec-leiden-format}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}}) is for
collisions with particles for which the number density is given in the file
\sphinxcode{\sphinxupquote{numberdens\_o\sphinxhyphen{}h2.inp}}.

\sphinxAtStartPar
We could also decide to ignore the difference between para\sphinxhyphen{}H\(_2\) and
ortho\sphinxhyphen{}H\(_2\), and simply use the first table (starting with the number
\sphinxcode{\sphinxupquote{3.2e\sphinxhyphen{}11}} in the example of Section {\hyperref[\detokenize{lineradtrans:sec-leiden-format}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}}),
which is actually for para\sphinxhyphen{}H\(_2\) only, as a proxy for the overall mixture
of H\(_2\) molecules. After all: The collision rate for para\sphinxhyphen{}H\(_2\) and
ortho\sphinxhyphen{}H\(_2\) are not so very different. In that case we may simply ignore
this difference and only provide a file \sphinxcode{\sphinxupquote{numberdens\_h2.inp}},
and link that to the first of the two collision rate tables:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{1}
\PYG{n}{co}   \PYG{n}{leiden}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{1}
\PYG{n}{h2}
\end{sphinxVerbatim}

\sphinxAtStartPar
(Note: we cannot, in this way, link this to the second of the two tables,
only to the first). But if we would do this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{1}
\PYG{n}{co}   \PYG{n}{leiden}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{3}
\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{n}{h2}
\PYG{n}{o}\PYG{o}{\PYGZhy{}}\PYG{n}{h2}
\PYG{n}{h}
\end{sphinxVerbatim}

\sphinxAtStartPar
we would get an error, because only two collision rate tables are
provided in \sphinxcode{\sphinxupquote{molecule\_co.inp}}.

\sphinxAtStartPar
Finally, as we will explain in Section {\hyperref[\detokenize{lineradtrans:sec-linelist-xxx-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The linelist\_XXX.inp file(s)}}}}, there
is an alternative way to feed atomic/molecular data into RADMC\sphinxhyphen{}3D: By using
linelists. To tell RADMC\sphinxhyphen{}3D to read a linelist file instead of a Leiden\sphinxhyphen{}style
molecular/atomic data file, just write the following in the \sphinxcode{\sphinxupquote{lines.inp}}
file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{1}
\PYG{n}{h2o}  \PYG{n}{linelist} \PYG{l+m+mi}{0}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
(example here is for water). This will make RADMC\sphinxhyphen{}3D read the
\sphinxcode{\sphinxupquote{linelist\_h2o.inp}} file as a linelist file (see Section
{\hyperref[\detokenize{lineradtrans:sec-linelist-xxx-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The linelist\_XXX.inp file(s)}}}}). Note that lines from a linelist will always be in
LTE.

\sphinxAtStartPar
You can also have multiple species, for which some are of Leiden\sphinxhyphen{}style and some
are linelist style. For instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{2}
\PYG{n}{co}   \PYG{n}{leiden}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{2}
\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{n}{h2}
\PYG{n}{o}\PYG{o}{\PYGZhy{}}\PYG{n}{h2}
\PYG{n}{h2o}  \PYG{n}{linelist} \PYG{l+m+mi}{0}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here the CO lines can be treated in a non\sphinxhyphen{}LTE manner (depending on what you put
for \sphinxcode{\sphinxupquote{lines\_mode}}, see Section {\hyperref[\detokenize{lineradtrans:sec-line-trans-modes}]{\sphinxcrossref{\DUrole{std,std-ref}{Line transfer modes and how to activate the line transfer}}}}), and the
H$_{\text{2}}$O is treated in LTE.


\subsection{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}
\label{\detokenize{lineradtrans:input-molecular-atomic-data-the-molecule-xxx-inp-file-s}}\label{\detokenize{lineradtrans:sec-leiden-format}}\label{\detokenize{lineradtrans:sec-molecule-xxx-inp}}
\sphinxAtStartPar
As mentioned in Section {\hyperref[\detokenize{lineradtrans:sec-line-dot-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The line.inp file}}}} the atomic or molecular
fundamental data such as the level diagram and the radiative decay rates
(Einstein A coefficients) are read from a file (or more than one files) named
\sphinxcode{\sphinxupquote{molecule\_XXX.inp}}, where the \sphinxcode{\sphinxupquote{XXX}} is to be replaced by the name of the
molecule or atom in question. For these files RADMC\sphinxhyphen{}3D uses the Leiden LAMDA
database format. Note that, instead of a \sphinxcode{\sphinxupquote{molecule\_XXX.inp}} file you can also
give a linelist file, but this will be discussed in Section
{\hyperref[\detokenize{lineradtrans:sec-linelist-xxx-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The linelist\_XXX.inp file(s)}}}}.

\sphinxAtStartPar
The precise format of the Leiden database data files is of course described
in detail on their web
page \sphinxurl{http://www.strw.leidenuniv.nl/~moldata/} . Here we only
give a very brief overview, based on an example of CO in which only the
first few levels are specified (taken from the LAMDA database):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
!MOLECULE (Data from the LAMDA database)
CO
!MOLECULAR WEIGHT
28.0
!NUMBER OF ENERGY LEVELS
5
!LEVEL + ENERGIES(cm\PYGZca{}\PYGZhy{}1) + WEIGHT + J
    1     0.000000000  1.0     0
    2     3.845033413  3.0     1
    3    11.534919938  5.0     2
    4    23.069512649  7.0     3
    5    38.448164669  9.0     4
!NUMBER OF RADIATIVE TRANSITIONS
4
!TRANS + UP + LOW + EINSTEINA(s\PYGZca{}\PYGZhy{}1) + FREQ(GHz) + E\PYGZus{}u(K)
    1     2     1   7.203e\PYGZhy{}08     115.2712018      5.53
    2     3     2   6.910e\PYGZhy{}07     230.5380000     16.60
    3     4     3   2.497e\PYGZhy{}06     345.7959899     33.19
    4     5     4   6.126e\PYGZhy{}06     461.0407682     55.32
\end{sphinxVerbatim}

\sphinxAtStartPar
The first few lines are self\sphinxhyphen{}explanatory. The first of the two tables is about
the levels. Column one is simply a numbering. Column 2 is the energy of the
level \(E_k\), specified in units of \(1/\mathrm{cm}\). To get the energy in erg
you multiply this number with \(hc/k\) where \(h\) is the Planck
constant, \(c\) the light speed and \(k\) the Boltzmann constant. Column
3 is the degeneration number, i.e. the the \(g\) parameter of the
level. Column 4 is redundant information, not used by the code.

\sphinxAtStartPar
The second table is the line list. Column 1 is again a simple counter.  Column 2
and 3 specify which two levels the line connects. Column 4 is the radiative
decay rate in units of \(1/\mathrm{s}\), i.e. the Einstein \(A\)
coefficient. The last two columns are redundant information that can be easily
derived from the other information.

\sphinxAtStartPar
If you are interested in LTE line transfer, this is enough information.
However, if you want to use one of the non\sphinxhyphen{}LTE modes of RADMC\sphinxhyphen{}3D, you must
also have the collisional rate data. An example of a \sphinxcode{\sphinxupquote{molecule\_XXX.inp}}
file that also contains these data is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
!MOLECULE (Data from the LAMDA database)
CO
!MOLECULAR WEIGHT
28.0
!NUMBER OF ENERGY LEVELS
10
!LEVEL + ENERGIES(cm\PYGZca{}\PYGZhy{}1) + WEIGHT + J
    1     0.000000000  1.0     0
    2     3.845033413  3.0     1
    3    11.534919938  5.0     2
    4    23.069512649  7.0     3
    5    38.448164669  9.0     4
!NUMBER OF RADIATIVE TRANSITIONS
9
!TRANS + UP + LOW + EINSTEINA(s\PYGZca{}\PYGZhy{}1) + FREQ(GHz) + E\PYGZus{}u(K)
    1     2     1   7.203e\PYGZhy{}08     115.2712018      5.53
    2     3     2   6.910e\PYGZhy{}07     230.5380000     16.60
    3     4     3   2.497e\PYGZhy{}06     345.7959899     33.19
    4     5     4   6.126e\PYGZhy{}06     461.0407682     55.32
!NUMBER OF COLL PARTNERS
2
!COLLISIONS BETWEEN
2 CO\PYGZhy{}pH2 from Flower (2001) \PYGZam{} Wernli et al. (2006) + extrapolation
!NUMBER OF COLL TRANS
10
!NUMBER OF COLL TEMPS
7
!COLL TEMPS
    5.0   10.0   20.0   30.0   50.0   70.0  100.0
!TRANS + UP + LOW + COLLRATES(cm\PYGZca{}3 s\PYGZca{}\PYGZhy{}1)
    1     2     1  3.2e\PYGZhy{}11 3.3e\PYGZhy{}11 3.3e\PYGZhy{}11 3.3e\PYGZhy{}11 3.4e\PYGZhy{}11 3.4e\PYGZhy{}11 3.4e\PYGZhy{}11
    2     3     1  2.9e\PYGZhy{}11 3.0e\PYGZhy{}11 3.1e\PYGZhy{}11 3.2e\PYGZhy{}11 3.2e\PYGZhy{}11 3.2e\PYGZhy{}11 3.2e\PYGZhy{}11
    3     3     2  7.9e\PYGZhy{}11 7.2e\PYGZhy{}11 6.5e\PYGZhy{}11 6.1e\PYGZhy{}11 5.9e\PYGZhy{}11 6.0e\PYGZhy{}11 6.5e\PYGZhy{}11
    4     4     1  4.8e\PYGZhy{}12 5.2e\PYGZhy{}12 5.6e\PYGZhy{}12 6.0e\PYGZhy{}12 7.1e\PYGZhy{}12 8.4e\PYGZhy{}12 1.2e\PYGZhy{}11
    5     4     2  4.7e\PYGZhy{}11 5.0e\PYGZhy{}11 5.1e\PYGZhy{}11 5.1e\PYGZhy{}11 5.1e\PYGZhy{}11 5.1e\PYGZhy{}11 5.1e\PYGZhy{}11
    6     4     3  9.0e\PYGZhy{}11 7.9e\PYGZhy{}11 7.1e\PYGZhy{}11 6.7e\PYGZhy{}11 6.5e\PYGZhy{}11 6.6e\PYGZhy{}11 7.2e\PYGZhy{}11
    7     5     1  2.8e\PYGZhy{}12 3.1e\PYGZhy{}12 3.4e\PYGZhy{}12 3.7e\PYGZhy{}12 4.0e\PYGZhy{}12 4.4e\PYGZhy{}12 4.0e\PYGZhy{}12
    8     5     2  8.0e\PYGZhy{}12 9.6e\PYGZhy{}12 1.1e\PYGZhy{}11 1.2e\PYGZhy{}11 1.4e\PYGZhy{}11 1.6e\PYGZhy{}11 2.2e\PYGZhy{}11
    9     5     3  5.9e\PYGZhy{}11 6.2e\PYGZhy{}11 6.2e\PYGZhy{}11 6.1e\PYGZhy{}11 6.0e\PYGZhy{}11 5.9e\PYGZhy{}11 5.8e\PYGZhy{}11
   10     5     4  8.5e\PYGZhy{}11 8.2e\PYGZhy{}11 7.5e\PYGZhy{}11 7.1e\PYGZhy{}11 6.9e\PYGZhy{}11 6.9e\PYGZhy{}11 7.3e\PYGZhy{}11
!COLLISIONS BETWEEN
3 CO\PYGZhy{}oH2 from Flower (2001) \PYGZam{} Wernli et al. (2006) + extrapolation
!NUMBER OF COLL TRANS
10
!NUMBER OF COLL TEMPS
7
!COLL TEMPS
    5.0   10.0   20.0   30.0   50.0   70.0  100.0
!TRANS + UP + LOW + COLLRATES(cm\PYGZca{}3 s\PYGZca{}\PYGZhy{}1)
    1     2     1  4.1e\PYGZhy{}11 3.8e\PYGZhy{}11 3.4e\PYGZhy{}11 3.3e\PYGZhy{}11 3.4e\PYGZhy{}11 3.5e\PYGZhy{}11 3.9e\PYGZhy{}11
    2     3     1  5.8e\PYGZhy{}11 5.6e\PYGZhy{}11 5.2e\PYGZhy{}11 5.0e\PYGZhy{}11 4.7e\PYGZhy{}11 4.7e\PYGZhy{}11 6.2e\PYGZhy{}11
    3     3     2  7.5e\PYGZhy{}11 7.1e\PYGZhy{}11 6.6e\PYGZhy{}11 6.2e\PYGZhy{}11 6.1e\PYGZhy{}11 6.2e\PYGZhy{}11 7.1e\PYGZhy{}11
    4     4     1  6.6e\PYGZhy{}12 7.1e\PYGZhy{}12 7.3e\PYGZhy{}12 7.5e\PYGZhy{}12 8.1e\PYGZhy{}12 9.0e\PYGZhy{}12 1.3e\PYGZhy{}11
    5     4     2  7.9e\PYGZhy{}11 8.3e\PYGZhy{}11 8.1e\PYGZhy{}11 7.8e\PYGZhy{}11 7.4e\PYGZhy{}11 7.3e\PYGZhy{}11 8.5e\PYGZhy{}11
    6     4     3  8.0e\PYGZhy{}11 7.5e\PYGZhy{}11 7.0e\PYGZhy{}11 6.8e\PYGZhy{}11 6.7e\PYGZhy{}11 6.9e\PYGZhy{}11 7.7e\PYGZhy{}11
    7     5     1  5.8e\PYGZhy{}12 6.1e\PYGZhy{}12 6.1e\PYGZhy{}12 6.1e\PYGZhy{}12 6.2e\PYGZhy{}12 6.3e\PYGZhy{}12 7.8e\PYGZhy{}12
    8     5     2  1.0e\PYGZhy{}11 1.2e\PYGZhy{}11 1.4e\PYGZhy{}11 1.4e\PYGZhy{}11 1.6e\PYGZhy{}11 1.8e\PYGZhy{}11 2.2e\PYGZhy{}11
    9     5     3  8.3e\PYGZhy{}11 8.9e\PYGZhy{}11 9.0e\PYGZhy{}11 8.8e\PYGZhy{}11 8.3e\PYGZhy{}11 8.1e\PYGZhy{}11 8.7e\PYGZhy{}11
   10     5     4  8.0e\PYGZhy{}11 7.9e\PYGZhy{}11 7.5e\PYGZhy{}11 7.2e\PYGZhy{}11 7.1e\PYGZhy{}11 7.1e\PYGZhy{}11 7.6e\PYGZhy{}11
\end{sphinxVerbatim}

\sphinxAtStartPar
As you see, the first part is the same. Now, however, there is extra
information.  First, the number of collision partners, for which these
collisional rate data is specified, is given. Then follows the reference to the
paper containing these data (this is not used by RADMC\sphinxhyphen{}3D; it is just for
information). Then the number of collisional transitions that are tabulated
(since collisions can relate any level to any other level, this number should
ideally be \sphinxcode{\sphinxupquote{nlevels*(nlevels\sphinxhyphen{}1)/2}}, but this is not strictly enforced). Then
the number of temperature points at which these collisional rates are
tabulated. Then follows this list of temperatures.  Finally we have the table of
collisional transitions. Each line consists of, first, the ID of the transition
(dummy), then the upper level, then the lower level, and then the
\(K_{\mathrm{up,low}}\) collisional rates in units of {[}\(\mathrm{cm}^3/s\){]}. The
same is again repeated (because in this example we have two collision partners:
the para\sphinxhyphen{}H\(_2\) molecule and the ortho\sphinxhyphen{}H\(_2\) molecule).

\sphinxAtStartPar
To get the collision rate \(C_{\mathrm{up,low}}\) per molecule (in units of
{[}1/s{]}) for the molecule of interest, we must multiply
\(K_{\mathrm{up,low}}\) with the number density of the collision partner
(see Section {\hyperref[\detokenize{lineradtrans:sec-collpartner}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The number density of collision partners (for non\sphinxhyphen{}LTE transfer)}}}}).  So in this example, the
\(C_{\mathrm{up,low}}\) becomes:
\begin{equation*}
\begin{split}C_{\mathrm{up,low}} = N_{\mathrm{p-H}_2}K^{\mathrm{p-H}_2}_{\mathrm{up,low}}
+ N_{\mathrm{o-H}_2}K^{\mathrm{o-H}_2}_{\mathrm{up,low}}\end{split}
\end{equation*}
\sphinxAtStartPar
The rates tabulated in this file are always the \sphinxstyleemphasis{downward} collision rate. The
upward rate is internally computed by RADMC\sphinxhyphen{}3D using the following formula:
\begin{equation*}
\begin{split}C_{\mathrm{low,up}} = C_{\mathrm{up,low}} \frac{g_{\mathrm{up}}}{g_{\mathrm{low}}}
\exp\left(-\frac{\Delta E}{kT}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
where the \(g\) factors are the statistical weights of the levels,
\(\Delta E\) is the energy difference between the levels, \(k\) is the
Boltzmann constant and \(T\) the gas temperature.

\sphinxAtStartPar
Some notes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
When doing LTE transfer \sphinxstyleemphasis{and} you make RADMC\sphinxhyphen{}3D read a separate
file with the partition function (Section {\hyperref[\detokenize{lineradtrans:sec-partition-function}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT for LTE line transfer: The partition function (optional)}}}}),
you can limit the \sphinxcode{\sphinxupquote{molecule\_XXX.inp}} files to just the levels
and lines you are interested in. But again: You \sphinxstyleemphasis{must} then read the
partition function separately, and not let RADMC\sphinxhyphen{}3D compute it internally
based on the \sphinxcode{\sphinxupquote{molecule\_XXX.inp}} file.

\item {} 
\sphinxAtStartPar
When doing non\sphinxhyphen{}LTE transfer and/or when you let RADMC\sphinxhyphen{}3D compute the
partition function internally you \sphinxstyleemphasis{must} make sure to include all
possible levels that might get populated, otherwise you may overpredict
the strength of the lines you are interested in.

\item {} 
\sphinxAtStartPar
The association of each of the collision partners in this file to
files that contain their spatial distribution is a bit complicated. See
Section {\hyperref[\detokenize{lineradtrans:sec-collpartner}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The number density of collision partners (for non\sphinxhyphen{}LTE transfer)}}}}.

\end{itemize}


\subsection{INPUT: Molecular/atomic data: The linelist\_XXX.inp file(s)}
\label{\detokenize{lineradtrans:input-molecular-atomic-data-the-linelist-xxx-inp-file-s}}\label{\detokenize{lineradtrans:sec-linelist-xxx-inp}}
\sphinxAtStartPar
In many cases molecular data are merely given as lists of lines (e.g. the
HITRAN database, the Kurucz database, the Jorgensen et al. databases
etc.). These line lists contain information about the line wavelength
\(\lambda_0\), the line strength \(A_{\mathrm{ud}}\), the statistical
weights of the lower and upper level and the energy of the lower or upper
level. Sometimes also the name or set of quantum numbers of the levels, or
additional information about the line profile shapes are specified. These line
lists contain no \sphinxstyleemphasis{direct} information about the level diagram, although this
information can be extracted from the line list (if it is complete). These lines
lists also do not contain any information about collisional (de\sphinxhyphen{})excitation, so
they cannot be used for non\sphinxhyphen{}LTE line transfer of any kind. They only work for
LTE line transfer. But such line lists are nevertheless used often (and thus LTE
is then assumed).

\sphinxAtStartPar
RADMC\sphinxhyphen{}3D can read the molecular data in line\sphinxhyphen{}list\sphinxhyphen{}form (files named
\sphinxcode{\sphinxupquote{linelist\_XXX.inp}}). RADMC\sphinxhyphen{}3D can in fact use both formats mixed (the line
list one and the ‘normal’ one of Section {\hyperref[\detokenize{lineradtrans:sec-molecule-xxx-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}}). Some
molecules may be specified as line lists (\sphinxcode{\sphinxupquote{linelist\_XXX.inp}}) while
simultaneously others as full molecular files (\sphinxcode{\sphinxupquote{molecule\_XXX.inp}}, see Section
{\hyperref[\detokenize{lineradtrans:sec-molecule-xxx-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}}).  For the ‘linelist molecules’ RADMC\sphinxhyphen{}3D will then
automatically use LTE, while for the other molecules RADMC\sphinxhyphen{}3D will use the mode
according to the \sphinxcode{\sphinxupquote{lines\_mode}} value. This means that you can use this to have
mixed LTE and non\sphinxhyphen{}LTE species of molecules/atoms within the same model, as long
as the LTE ones have their molecular/atomic data given in a line list form. This
can be useful to model situations where most of the lines are in LTE, but one
(or a few) are non\sphinxhyphen{}LTE.

\sphinxAtStartPar
Now coming back to the linelist data. Here is an example of such a file
(created from data from the HITRAN database):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
! RADMC\PYGZhy{}3D Standard line list
! Format number:
1
! Molecule name:
h2o
! Reference: From the HITRAN Database (see below for more info)
! Molecular weight (in atomic units)
  18.010565
! Include table of partition sum? (0=no, 1=yes)
  1
! Include additional information? (0=no, 1=yes)
  0
! Nr of temperature points for the partition sum
    2931
!  Temp [K]      PartSum
 7.000000E+01  2.100000E+01
 7.100000E+01  2.143247E+01
 7.200000E+01  2.186765E+01
 7.300000E+01  2.230553E+01
....
....
....
 2.997000E+03  1.594216E+04
 2.998000E+03  1.595784E+04
 2.999000E+03  1.597353E+04
 3.000000E+03  1.598924E+04
! Nr of lines
  37432
! ID    Lambda [mic]  Aud [sec\PYGZca{}\PYGZhy{}1]  E\PYGZus{}lo [cm\PYGZca{}\PYGZhy{}1]  E\PYGZus{}up [cm\PYGZca{}\PYGZhy{}1]  g\PYGZus{}lo  g\PYGZus{}up
     1  1.387752E+05  5.088000E\PYGZhy{}12  1.922829E+03  1.922901E+03   11.    9.
     2  2.496430E+04  1.009000E\PYGZhy{}09  1.907616E+03  1.908016E+03   21.   27.
     3  1.348270E+04  1.991000E\PYGZhy{}09  4.465107E+02  4.472524E+02   33.   39.
     4  1.117204E+04  8.314000E\PYGZhy{}09  2.129599E+03  2.130494E+03   27.   33.
     5  4.421465E+03  1.953000E\PYGZhy{}07  1.819335E+03  1.821597E+03   21.   27.
....
....
....
 37429  3.965831E\PYGZhy{}01  3.427000E\PYGZhy{}05  7.949640E+01  2.529490E+04   15.   21.
 37430  3.965250E\PYGZhy{}01  1.508000E\PYGZhy{}04  2.121564E+02  2.543125E+04   21.   27.
 37431  3.964335E\PYGZhy{}01  5.341000E\PYGZhy{}05  2.854186E+02  2.551033E+04   21.   27.
 37432  3.963221E\PYGZhy{}01  1.036000E\PYGZhy{}04  3.825169E+02  2.561452E+04   27.   33.
\end{sphinxVerbatim}

\sphinxAtStartPar
The file is pretty self\sphinxhyphen{}explanatory. It contains a table for the partition
function (necessary for LTE transfer) and a table with all the lines (or any
subset you wish to select). The lines table columns are as follows: first column
is just a dummy index. Second column is the wavelength in micron. Third is the
Einstein\sphinxhyphen{}A\sphinxhyphen{}coefficient (spontaneous downward rate) in units of
\(\mathrm{s}^{-1}\). Fourth and fifth are the energies above the ground state of
the lower and upper levels belonging to this line in units of
\(\mathrm{cm}^{-1}\). Sixth and seventh are the statistical weights (degenracies) of
the lower and upper levels belonging to this line.

\sphinxAtStartPar
Note that you can tell RADMC\sphinxhyphen{}3D to read \sphinxcode{\sphinxupquote{linelist\_h2o.inp}} (instead of search
for \sphinxcode{\sphinxupquote{molecule\_h2o.inp}}) by specifying \sphinxcode{\sphinxupquote{linelist}} instead of \sphinxcode{\sphinxupquote{leiden}} in
the \sphinxcode{\sphinxupquote{lines.inp}} file (see Section {\hyperref[\detokenize{lineradtrans:sec-line-dot-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The line.inp file}}}}).


\subsection{INPUT: The number density of each molecular species}
\label{\detokenize{lineradtrans:input-the-number-density-of-each-molecular-species}}\label{\detokenize{lineradtrans:sec-mol-numdensity}}
\sphinxAtStartPar
For the line radiative transfer we need to know how many molecules of each
species are there per cubic centimeter. For molecular/atom species \sphinxcode{\sphinxupquote{XXX}} this
is given in the file \sphinxcode{\sphinxupquote{numberdens\_XXX.inp}} (see Chapter {\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}}
for the binary version of this file, which is more compact, and which you can
use instead of the ascii version). For each molecular/atomic species listed in
the \sphinxcode{\sphinxupquote{lines.inp}} file there must be a corresponding \sphinxcode{\sphinxupquote{numberdens\_XXX.inp}}
file. The structure of the file is very similar (though not identical) to the
structure of the dust density input file \sphinxcode{\sphinxupquote{dust\_density.inp}} (Section
{\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}). For the precise way to address the various cells in the
different AMR modes, we refer to Section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}, where this is
described in detail.

\sphinxAtStartPar
For formatted style (\sphinxcode{\sphinxupquote{numberdens\_XXX.inp}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{nrcells}
\PYG{n}{numberdensity}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}
\PYG{n}{numberdensity}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The number densities are to be specified in units of molecule per cubic
centimeter.


\subsection{INPUT: The gas temperature}
\label{\detokenize{lineradtrans:input-the-gas-temperature}}\label{\detokenize{lineradtrans:sec-gas-temperature}}
\sphinxAtStartPar
For line transfer we need to know the gas temperature. You specify this in the
file \sphinxcode{\sphinxupquote{gas\_temperature.inp}} (see Chapter {\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}} for the binary
version of these files, which are more compact, and which you can use instead of
the ascii versions). The structure of this file is identical to that described
in Section {\hyperref[\detokenize{lineradtrans:sec-mol-numdensity}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The number density of each molecular species}}}}, but of course with number density replaced
by gas temperature in Kelvin. For the precise way to address the various cells
in the different AMR modes, we refer to Section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}, where this
is described in detail.

\sphinxAtStartPar
Note: Instead of literally specifying the gas temperature you can also tell
\sphinxcode{\sphinxupquote{radmc3d}} to copy the dust temperature (if it know it) into the gas
temperature. See the keyword \sphinxcode{\sphinxupquote{tgas\_eq\_tdust}} described in Section
{\hyperref[\detokenize{lineradtrans:sec-line-radmc-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The line transfer entries in the radmc3d.inp file}}}}.


\subsection{INPUT: The velocity field}
\label{\detokenize{lineradtrans:input-the-velocity-field}}\label{\detokenize{lineradtrans:sec-velo-field}}
\sphinxAtStartPar
Since gas motions are usually the main source of Doppler shift or broadening in
astrophysical settings, it is obligatory to specify the gas velocity.  This can
be done with the file \sphinxcode{\sphinxupquote{gas\_velocity.inp}} (see Chapter {\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}}
for the binary version of these files, which are more compact, and which you can
use instead of the ascii versions). The structure is again similar to that
described in Section {\hyperref[\detokenize{lineradtrans:sec-mol-numdensity}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The number density of each molecular species}}}}, but now with three numbers at
each grid point instead of just one. The three numbers are the velocity in
\(x\), \(y\) and \(z\) direction for Cartesian coordinates, or in
\(r\), \(\theta\) and \(\phi\) direction for spherical
coordinates. Note that both in cartesian coordinates and in spherical
coordinates \sphinxstyleemphasis{all} velocity components have the same dimension of cm/s. For
spherical coordinates the conventions are: positive \(v_r\) points outwards,
positive \(v_\theta\) points downward (toward larger \(\theta\)) for
\(0<\theta<\pi\) (where ‘downward’ is toward smaller \(z\)), and
positive \(v_\phi\) means velocity in counter\sphinxhyphen{}clockwise direction in the
\(x,y\)\sphinxhyphen{}plane.

\sphinxAtStartPar
For the precise way to address the various cells in the different AMR modes,
we refer to Section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}, where this is described in detail.


\subsection{INPUT: The local microturbulent broadening (optional)}
\label{\detokenize{lineradtrans:input-the-local-microturbulent-broadening-optional}}\label{\detokenize{lineradtrans:sec-turb-broadening}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{radmc3d}} code automatically includes thermal broadening of the line. But
sometimes it is also useful to specify a local (spatially unresolved) turbulent
width. This is not obligatory (if it is not specified, only the thermal
broadening is used) but if you want to specify it, you can do so in the file
\sphinxcode{\sphinxupquote{microturbulence.inp}} (see Chapter {\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}} for the binary
version of these files, which are more compact, and which you can use instead of
the ascii versions). The file format is the same structure as described in
Section {\hyperref[\detokenize{lineradtrans:sec-mol-numdensity}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The number density of each molecular species}}}}. For the precise way to address the various
cells in the different AMR modes, we refer to Section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}, where
this is described in detail.

\sphinxAtStartPar
Here is the way it is included into the line profile:
\begin{equation*}
\begin{split}a_{\mathrm{linewidth}}^2 = a^2_{\mathrm{turb}} + \frac{2kT_{\mathrm{gas}}}{\mu}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(T_{\mathrm{gas}}\) is the temperature of the gas, \(\mu\) the
molecular weight, \(k\) the Boltzmann constant and \(a_{\mathrm{turb}}\)
the microturbulent line width in units of cm/s. The
\(a_{\mathrm{linewidth}}\) is then the total (thermal plus microturbulent)
line width.


\subsection{INPUT for LTE line transfer: The partition function (optional)}
\label{\detokenize{lineradtrans:input-for-lte-line-transfer-the-partition-function-optional}}\label{\detokenize{lineradtrans:sec-partition-function}}
\sphinxAtStartPar
If you use the LTE mode (either \sphinxcode{\sphinxupquote{lines\_mode=\sphinxhyphen{}1}} or \sphinxcode{\sphinxupquote{lines\_mode=1}}), then the partition function is required to calculate, for
a given temperature the populations of the various levels. Since this
involves a summation over \sphinxstyleemphasis{all} levels of all kinds that can possibly be
populated, and since the molecular/atomic data file may not include all
these possible levels, it may be useful to look the partition function up in
some literature and give this to \sphinxcode{\sphinxupquote{radmc3d}}. This can be done with
the file \sphinxcode{\sphinxupquote{partitionfunction\_XXX.inp}}, where again \sphinxcode{\sphinxupquote{XXX}}
is here a placeholder for the actual name of the molecule at hand. If you do
not have this file in the present model directory, then \sphinxcode{\sphinxupquote{radmc3d}}
will compute the partition function itself, but based on the (maybe limited)
set of levels given in the molecular data file. The structure of the
\sphinxcode{\sphinxupquote{partitionfunction\_XXX.inp}} file is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                    \PYG{p}{;} \PYG{n}{The} \PYG{n}{usual} \PYG{n+nb}{format} \PYG{n}{number}\PYG{p}{,} \PYG{n}{currently} \PYG{l+m+mi}{1}
\PYG{n}{ntemp}                      \PYG{p}{;} \PYG{n}{The} \PYG{n}{number} \PYG{n}{of} \PYG{n}{temperatures} \PYG{n}{at} \PYG{n}{which} \PYG{n}{it} \PYG{o+ow}{is} \PYG{n}{specified}
\PYG{n}{temp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}       \PYG{n}{pfunc}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{temp}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}       \PYG{n}{pfunc}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
  \PYG{o}{.}             \PYG{o}{.}
  \PYG{o}{.}             \PYG{o}{.}
  \PYG{o}{.}             \PYG{o}{.}
\PYG{n}{temp}\PYG{p}{(}\PYG{n}{ntemp}\PYG{p}{)}   \PYG{n}{pfunc}\PYG{p}{(}\PYG{n}{ntemp}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{NOTE:} RADMC\sphinxhyphen{}3D assumes the partition function to be defined in the following
way:
\begin{equation*}
\begin{split}Z(T) = \sum_{i=1} g_ie^{-(E_i-E_1)/kT}\end{split}
\end{equation*}
\sphinxAtStartPar
In other words: the first level is assumed to be the ground state. This is done
so that one can also use an energy definition in which the ground state energy
is non\sphinxhyphen{}zero (example: Hydrogen \(E_1=-13.6\) eV). If you use molecular line
datafiles that contain only a subset of levels (which is in principle no problem
for LTE calculations) then it is essential that the ground state is included in
this list, and that it is the first level (\sphinxcode{\sphinxupquote{ilevel=1}}).


\subsection{INPUT: The number density of collision partners (for non\sphinxhyphen{}LTE transfer)}
\label{\detokenize{lineradtrans:input-the-number-density-of-collision-partners-for-non-lte-transfer}}\label{\detokenize{lineradtrans:sec-collpartner}}
\sphinxAtStartPar
For non\sphinxhyphen{}LTE line transfer (see e.g. Sections {\hyperref[\detokenize{lineradtrans:sec-lvg}]{\sphinxcrossref{\DUrole{std,std-ref}{Non\sphinxhyphen{}LTE Transfer: The Large Velocity Gradient (LVG) + Escape Probability (EscProb) method}}}},
{\hyperref[\detokenize{lineradtrans:sec-optthinpop}]{\sphinxcrossref{\DUrole{std,std-ref}{Non\sphinxhyphen{}LTE Transfer: The optically thin line assumption method}}}}) the molecules can be collisionally excited. The collision
rates for each pair of molecule + collision partner are given in the molecular
input data files (Section {\hyperref[\detokenize{lineradtrans:sec-molecule-xxx-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}}). To find how often a
molecular level of a single molecule is collisionally excited to another level
we also need to know the number density of the collision partner molecules. In
the example in Section {\hyperref[\detokenize{lineradtrans:sec-molecule-xxx-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}} these were para\sphinxhyphen{}H\(_2\)
and ortho\sphinxhyphen{}H\(_2\). We must therefore somehow tell RADMC\sphinxhyphen{}3D what the number
densities of these molecules are. This is done by reading in the number
densities for this(these) collision partner(s).  The file for this has exactly
the same format as that for the number density of any molecule (see Section
{\hyperref[\detokenize{lineradtrans:sec-mol-numdensity}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The number density of each molecular species}}}}). So for our example we would thus have two files,
which could be named \sphinxcode{\sphinxupquote{numberdens\_p\sphinxhyphen{}h2.inp}} and \sphinxcode{\sphinxupquote{numberdens\_o\sphinxhyphen{}h2.inp}}
respectively.  See Section {\hyperref[\detokenize{lineradtrans:sec-mol-numdensity}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The number density of each molecular species}}}} for details.

\sphinxAtStartPar
However, how does RADMC\sphinxhyphen{}3D know that the first collision partner of CO is called
\sphinxcode{\sphinxupquote{p\sphinxhyphen{}h2}} and the second \sphinxcode{\sphinxupquote{o\sphinxhyphen{}h2}}?  In principle the file \sphinxcode{\sphinxupquote{molecule\_co.inp}}
give some information about the name of the collision partners. But this is
often not machine\sphinxhyphen{}readable.  Example, in \sphinxcode{\sphinxupquote{molecule\_co.inp}} of Section
{\hyperref[\detokenize{lineradtrans:sec-molecule-xxx-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}} the line that should tell this reads:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{n}{CO}\PYG{o}{\PYGZhy{}}\PYG{n}{pH2} \PYG{k+kn}{from} \PYG{n+nn}{Flower} \PYG{p}{(}\PYG{l+m+mi}{2001}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{n}{Wernli} \PYG{n}{et} \PYG{n}{al}\PYG{o}{.} \PYG{p}{(}\PYG{l+m+mi}{2006}\PYG{p}{)} \PYG{o}{+} \PYG{n}{extrapolation}
\end{sphinxVerbatim}

\sphinxAtStartPar
for the first of the two
(which is directly from the LAMDA database).  This is hard to decipher for
RADMC\sphinxhyphen{}3D. Therefore you have to tell this explicitly in the file \sphinxcode{\sphinxupquote{lines.inp}},
and we refer to Section {\hyperref[\detokenize{lineradtrans:sec-line-dot-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The line.inp file}}}} for how to do this.


\section{Making images and spectra with line transfer}
\label{\detokenize{lineradtrans:making-images-and-spectra-with-line-transfer}}
\sphinxAtStartPar
Making images and spectra with/of lines works in the same way as for the
continuum. RADMC\sphinxhyphen{}3D will check if the file \sphinxcode{\sphinxupquote{lines.inp}} is present in your
directory, and if so, it will automatically switch on the line transfer. If you
insist on \sphinxstyleemphasis{not} having the lines switched on, in spite of the presence of the
\sphinxcode{\sphinxupquote{lines.inp}} file, you can add the option \sphinxcode{\sphinxupquote{noline}} to \sphinxcode{\sphinxupquote{radmc3d}} on the
command line. If you don’t, then lines are normally automatically switched on,
except in situations where it is obviously not required.

\sphinxAtStartPar
You can just make an image at some wavelength and you’ll get the image with
any line emission included if it is there. For instance, if you have
the molecular data of CO included, then:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mf}{2600.757}
\end{sphinxVerbatim}

\sphinxAtStartPar
will give an image right at the CO 1\sphinxhyphen{}0 line center. The code will automatically
check if (and if yes, which) line(s) are contributing to the wavelength of
interest. Also it will include all the continuum emission (and absorption) that
you would usually obtain.

\sphinxAtStartPar
There is, however, an exception to this automatic line inclusion: If you make a
spectral energy distribution (with the command \sphinxcode{\sphinxupquote{sed}}, see Section
{\hyperref[\detokenize{imagesspectra:sec-making-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making spectra}}}}), then lines are not included. The same is true if you
use the \sphinxcode{\sphinxupquote{loadcolor}} command.  But for normal spectra or images the line
emission will automatically be included.  So if you make a spectrum at
wavelength around some line, you will get a spectrum including the line profile
from the object, as well as the dust continuum.

\sphinxAtStartPar
It is not always convenient to have to know by heart the exact wavelengths
of the lines you are interested in. So RADMC\sphinxhyphen{}3D allows you to specify the
wavelength by specifying which line of which molecule, and at which velocity
you want to render:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{n}{iline} \PYG{l+m+mi}{2} \PYG{n}{vkms} \PYG{l+m+mf}{2.4}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you have CO as your molecule, then iline 2 means CO 2\sphinxhyphen{}1 (the second
line in the rotational ladder).

\sphinxAtStartPar
By default the first molecule is used (if you have more than one molecule),
but you can also specify another one:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{n}{imolspec} \PYG{l+m+mi}{2} \PYG{n}{iline} \PYG{l+m+mi}{2} \PYG{n}{vkms} \PYG{l+m+mf}{2.4}
\end{sphinxVerbatim}

\sphinxAtStartPar
which would select the second molecule instead of the first one.

\sphinxAtStartPar
If you wish to make an entire spectrum of the line, you can do for instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{spectrum} \PYG{n}{iline} \PYG{l+m+mi}{1} \PYG{n}{widthkms} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxAtStartPar
which produces a spectrum of the line with a passband going from \sphinxhyphen{}10 km/s to
+10 km/s. By default 40 wavelength points are used, and they are evenly
spaced. You can set this number of wavelengths:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{spectrum} \PYG{n}{iline} \PYG{l+m+mi}{1} \PYG{n}{widthkms} \PYG{l+m+mi}{10} \PYG{n}{linenlam} \PYG{l+m+mi}{100}
\end{sphinxVerbatim}

\sphinxAtStartPar
which would make a spectrum with 100 wavelength points, evenly spaced around
the line center. You can also shift the passband center:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{spectrum} \PYG{n}{iline} \PYG{l+m+mi}{1} \PYG{n}{widthkms} \PYG{l+m+mi}{10} \PYG{n}{linenlam} \PYG{l+m+mi}{100} \PYG{n}{vkms} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxAtStartPar
which would make the wavelength grid 10 kms shifted in short direction.

\sphinxAtStartPar
Note that you can use the \sphinxcode{\sphinxupquote{widthkms}} and \sphinxcode{\sphinxupquote{linenlam}} keywords also for
images:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{n}{iline} \PYG{l+m+mi}{1} \PYG{n}{widthkms} \PYG{l+m+mi}{10} \PYG{n}{linenlam} \PYG{l+m+mi}{100}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will make a multi\sphinxhyphen{}color image, i.e. it will make images at 100 wavelenths
points evenly spaced around the line center. In this way you can make channel
maps.

\sphinxAtStartPar
For more details on how to specify the spectral sampling, please read Section
{\hyperref[\detokenize{imagesspectra:sec-set-camera-frequencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}}}}. Note that keywords such as \sphinxcode{\sphinxupquote{incl}}, \sphinxcode{\sphinxupquote{phi}},
and any other keywords specifying the camera position, zooming factor etc, can
all be used in addition to the above keywords.


\subsection{Speed versus realism of rendering of line images/spectra}
\label{\detokenize{lineradtrans:speed-versus-realism-of-rendering-of-line-images-spectra}}\label{\detokenize{lineradtrans:sec-line-render-speed-realism}}
\sphinxAtStartPar
As usual with numerical modeling: including realism to the modeling goes at
the cost of rendering speed. A ‘fully realistic’ rendering of a model
spectrum or image of a gas line involves (assuming the level populations
are already known):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Doppler\sphinxhyphen{}shifted emission and absorption.

\item {} 
\sphinxAtStartPar
Inclusion of dust thermal emission and dust extinction while rendering
the lines.

\item {} 
\sphinxAtStartPar
Continuum emission scattered by dust into the line\sphinxhyphen{}of\sphinxhyphen{}sight

\item {} 
\sphinxAtStartPar
Line emission from (possibly obscured) other regions is allowed to
scatter into the line\sphinxhyphen{}of\sphinxhyphen{}sight by dust grains (see Section
{\hyperref[\detokenize{lineradtrans:sec-line-scat-off-dust}]{\sphinxcrossref{\DUrole{std,std-ref}{Line emission scattered off dust grains}}}}).

\end{enumerate}

\sphinxAtStartPar
RADMC\sphinxhyphen{}3D always includes the Doppler shifts. By default, RADMC\sphinxhyphen{}3D also
includes dust thermal emission and extinction, as well as the scattered
continuum radiation.

\sphinxAtStartPar
\sphinxstyleemphasis{For many lines, however, dust continuum scattering is a negligible
portion of the flux, so you can speed things up by not including dust
scattering!} This can be easily done by adding the \sphinxcode{\sphinxupquote{noscat}}
option on the command\sphinxhyphen{}line when you issue the command for a line spectrum or
multi\sphinxhyphen{}frequency image. This way, the scattering source function is not
computed (is assumed to be zero), and no scattering Monte Carlo runs are
necessary. This means that the ray\sphinxhyphen{}tracer can now render all wavelength
simultaneously (each ray doing all wavelength at the same time), and the
local level populations along each ray can now be computed once, and be used
for all wavelengths. \sphinxstyleemphasis{This may speed up things drastically, and for most
purposes virtually perfectly correct}. Just beware that when you render
short\sphinxhyphen{}wavelength lines (optical) or you use large grains, i.e. when the
scattering albedo at the wavelength of the line is not negligible, this may
result in a mis\sphinxhyphen{}estimation of the continuum around the line.


\subsection{Line emission scattered off dust grains}
\label{\detokenize{lineradtrans:line-emission-scattered-off-dust-grains}}\label{\detokenize{lineradtrans:sec-line-scat-off-dust}}
\sphinxAtStartPar
\sphinxstyleemphasis{NOTE: The contents of this subsection may not be 100\% implemented yet.}

\sphinxAtStartPar
Also any line emission from obscured regions that get scattered into the
line of sight by the dust (if dust scattering is included) will be
included. Note, however, that any possible Doppler shift \sphinxstyleemphasis{induced} by
this scattering is \sphinxstyleemphasis{not} included. This means that if line emission is
scattered by a dust cloud moving at a very large speed, then this line
emission will be scattered by the dust, but no Doppler shift at the
projected velocity of the dust will be added. Only the Doppler shift of the
line\sphinxhyphen{}emitting region is accounted for. This is rarely a problem, because
typically the dust that may scatter line emission is located far away from
the source of line emission and moves at substantially lower speed.


\section{Non\sphinxhyphen{}LTE Transfer: The Large Velocity Gradient (LVG) + Escape Probability (EscProb) method}
\label{\detokenize{lineradtrans:non-lte-transfer-the-large-velocity-gradient-lvg-escape-probability-escprob-method}}\label{\detokenize{lineradtrans:sec-lvg}}
\sphinxAtStartPar
The assumption that the energy levels of a molecule or atom are always
populated according to a thermal distribution (the so\sphinxhyphen{}called ‘local
thermodynamic equilibrium’, or LTE, assumption) is valid under certain
circumstances. For instance for planetary atmospheres in most cases.  But in
the dilute interstellar medium this assumption is very often invalid.  One
must then compute the level populations consistent with the local density
and temperature, and often also consistent with the local radiation
field. Part of this radiation field might even be the emission from the
lines themselves, meaning that the molecules radiatively influence their
neighbors. Solving the level populations self\sphinxhyphen{}consistently is called
‘non\sphinxhyphen{}LTE radiative transfer’. A full non\sphinxhyphen{}LTE radiative transfer
calculation is, however, in most cases (a) too numerically demanding and
sometimes (b) unnecessary. Sometimes a simple approximation of the non\sphinxhyphen{}LTE
effects is sufficient.

\sphinxAtStartPar
One such approximation method is the ‘Large Velocity Gradient’ (LVG)
method, also called the ‘Sobolev approximation’.  Please read for instance
the paper by Ossenkopf (1997) ‘The Sobolev approximation in molecular
clouds’, New Astronomy, 2, 365 for more explanation, and a study how it
works in the context of molecular clouds. The LVG mode of RADMC\sphinxhyphen{}3D has been
used for the first time by Shetty et al. (2011, MNRAS 412, 1686), and a
description of the method is included in that paper.  The nice aspect of
this method is that it is, for most part, local. The only slightly non\sphinxhyphen{}local
aspect is that a velocity gradient has to be computed by comparing the gas
velocity in one cell with the gas velocity in neighboring cells.

\sphinxAtStartPar
As of RADMC\sphinxhyphen{}3D Version 0.33 the LVG method is combined with an escape
probability (EscProb) method. In fact, LVG \sphinxstyleemphasis{is} a kind of escape probability
method itself. It is just that for the classic EscProb method the photons can
escape due to the finite size of the object, and thus the finite optical
depth in the lines. In the LVG the object size is not the issue, but the
gradient of the velocity. The line width combined with the velocity gradient
give a length scale over which a photon can escape.

\sphinxAtStartPar
In the LVG + EscProb method the line\sphinxhyphen{}integrated mean intensity \(J_{ij}\) is
given by

\phantomsection\label{\detokenize{lineradtrans:eq-linemeanint-escp}}\begin{equation*}
\begin{split}J_{ij} = (1-\beta_{ij})S_{ij} + \beta_{ij}J_{ij}^{\mathrm{bg}}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(J_{ij}^{\mathrm{bg}}\) is the mean intensity of the background
radiation field at frequency \(\nu=\nu_{ij}\) (default is blackbody at 2.73 K,
but this temperature can be varied with the \sphinxcode{\sphinxupquote{lines\_tbg}} variable
in \sphinxcode{\sphinxupquote{radmc3d.inp}}), while \(\beta_{ij}\) is the escape probability
for line \(i\rightarrow j\). This is given by

\phantomsection\label{\detokenize{lineradtrans:eq-escprob-beta-formula}}\begin{equation*}
\begin{split}\beta_{ij} = \frac{1-\exp(-\tau_{ij})}{\tau_{ij}}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\tau_{ij}\) is the line\sphinxhyphen{}center optical depth in the line.

\sphinxAtStartPar
For the LVG method this optical depth is given by the velocity gradient:
\begin{equation*}
\begin{split}\begin{split}
\tau_{ij}^{\mathrm{LVG}} & = \frac{ch}{4\pi}\frac{N_{\mathrm{molec}}}
{1.064\,|\nabla \vec v|}\left[n_jB_{ji}-n_iB_{ij}\right]\\
&= \frac{c^3}{8\pi \nu_{ij}^3}\frac{A_{ij}N_{\mathrm{molec}}}
{1.064\,|\nabla \vec v|}\left[\frac{g_i}{g_j}n_j-n_i\right]
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
(see e.g. van der Tak et al. 2007, A\&A 468, 627), where \(n_i\) is the
fractional level population of level \(i\), \(N_{\mathrm{molec}}\) the
total number density of the molecule, \(|\nabla \vec v|\) the absolute value
of the velocity gradient, \(g_i\) the statistical weight of level \(i\)
and \(\nu_{ij}\) the line frequency for transition \(i\rightarrow
j\). In comparing to Eq. 21 of van der Tak’s paper, note that their
\(N_{\mathrm{mol}}\) is a column density (cm\(^{-2}\)) and their
\(\Delta V\) is the line width (cm/s), while our \(N_{\mathrm{molec}}\)
is the number density (cm\(^{-3}\)) and \(|\nabla \vec v|\) is the
velocity gradient (s\(^{-1}\)). Their formula is thus in fact EscProb while
ours is LVG.

\sphinxAtStartPar
For the EscProb method \sphinxstyleemphasis{without} velocity gradients, we need to be able to
compute the total column depth \(\Sigma_{\mathrm{molec}}\) in the direction
where this \(\Sigma_{\mathrm{molec}}\) is minimal. This is something that,
at the moment, RADMC\sphinxhyphen{}3D cannot yet do. But this is something that can be
estimated based on a ‘typical length scale’ \(L\), such that
\begin{equation*}
\begin{split}\Sigma_{\mathrm{molec}} \simeq N_{\mathrm{molec}}\, L\end{split}
\end{equation*}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D allows you to specify \(L\) separately for each cell (in the file
\sphinxcode{\sphinxupquote{escprob\_lengthscale.inp}} or its binary version). The simplest would be to set
it to a global value equal to the typical size of the object we are interested
in. Then the line\sphinxhyphen{}center optical depth, assuming a Gaussian line profile with
width \(a_{\mathrm{linewidth}}\), is
\begin{equation*}
\begin{split}\tau_{ij}^{\mathrm{EscProb}} = \frac{hc \Sigma_{\mathrm{molec}}}{4\pi\sqrt{\pi}\,a_{\mathrm{linewidth}}}\left[n_jB_{ji}-n_iB_{ij}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
because \(\phi(\nu=\nu_{ij})=c/(a\nu_{ij}\sqrt{\pi})\).

\sphinxAtStartPar
The optical depth of the combined LVG + EscProb method is then:
\begin{equation*}
\begin{split}\tau_{ij} = \mathrm{min}\left(\tau_{ij}^{\mathrm{LVG}},\tau_{ij}^{\mathrm{EscProb}}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
This is then the \(\tau_{ij}\) that needs to be inserted into
Eq. (\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}escprob\sphinxhyphen{}beta\sphinxhyphen{}formula}) for obtaining the escape probability
\(\beta_{ij}\) (which includes escape due to LVG as well as the finite
length scale \(L\)).

\sphinxAtStartPar
The LVG+EscProb method solves at each location the following statistical
equilibrium equation:
\begin{equation*}
\begin{split}\begin{split}
& \sum_{j>i} \Big[ n_jA_{ji} + (n_jB_{ji}-n_iB_{ij})J_{ji}\Big]\\
& - \sum_{j<i} \Big[ n_iA_{ij} + (n_iB_{ij}-n_jB_{ji})J_{ij}\Big]\\
& + \sum_{j\neq i}\big[n_jC_{ji}-n_iC_{ij}\big]=0
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
Replacing \(J_{ij}\) (and similarly \(J_{ji}\)) with the expression of
Eq. (\DUrole{xref,std,std-ref}{eq\sphinxhyphen{}linemeanint\sphinxhyphen{}escp}) and subsequently replacing \(S_{ij}\) with
the well\sphinxhyphen{}known expression for the line source function
\begin{equation*}
\begin{split}S_{ij} = \frac{n_iA_{ij}}{n_jB_{ji}-n_iB_{ij}}\end{split}
\end{equation*}
\sphinxAtStartPar
leads to
\begin{equation*}
\begin{split}\begin{split}
& \sum_{j>i} \Big[ n_jA_{ji}\beta_{ji} + (n_jB_{ji}-n_iB_{ij})\beta_{ji}J^{\mathrm{bg}}_{ji}\Big]\\
& - \sum_{j<i} \Big[ n_iA_{ij}\beta_{ij} + (n_iB_{ij}-n_jB_{ji})\beta_{ij}J^{\mathrm{bg}}_{ij}\Big]\\
& + \sum_{j\neq i}\big[n_jC_{ji}-n_iC_{ij}\big]=0
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
A few iteration steps are necessary, because the \(\beta_{ij}\) depends on the
optical depths, which depend on the populations. But since this is only a
weak dependence, the iteration should converge rapidly.

\sphinxAtStartPar
To use the LVG+EscProb method, the following has to be done:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Make sure that you use a molecular data file that contains
collision rate tables (see Section {\hyperref[\detokenize{lineradtrans:sec-molecule-xxx-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}}).

\item {} 
\sphinxAtStartPar
Make sure to provide file(s) containing the number densities
of the collision partners, e.g. \sphinxcode{\sphinxupquote{numberdens\_p\sphinxhyphen{}h2.inp}}
(see Section {\hyperref[\detokenize{lineradtrans:sec-collpartner}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The number density of collision partners (for non\sphinxhyphen{}LTE transfer)}}}}).

\item {} 
\sphinxAtStartPar
Make sure to link the rate tables to the number density
files in \sphinxcode{\sphinxupquote{lines.inp}} (see Section {\hyperref[\detokenize{lineradtrans:sec-line-dot-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The line.inp file}}}}).

\item {} 
\sphinxAtStartPar
Set the \sphinxcode{\sphinxupquote{lines\_mode=3}} in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file.

\item {} 
\sphinxAtStartPar
You may want to also specify the maximum number of iterations for
non\sphinxhyphen{}LTE iterations, by setting \sphinxcode{\sphinxupquote{lines\_nonlte\_maxiter}} in the
\sphinxcode{\sphinxupquote{radmc3d.inp}} file. The default is 100 (as of version 0.36). If
convergence is not reached within \sphinxcode{\sphinxupquote{lines\_nonlte\_maxiter}}
iterations, RADMC\sphinxhyphen{}3D stops.

\item {} 
\sphinxAtStartPar
You may want to also specify the convergence criterion
for non\sphinxhyphen{}LTE iterations, by setting \sphinxcode{\sphinxupquote{lines\_nonlte\_convcrit}}
in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file. The default is 1d\sphinxhyphen{}2 (which is
not very strict! Smaller values may be necessary).

\item {} 
\sphinxAtStartPar
Specify the gas velocity vector field in the file \sphinxcode{\sphinxupquote{gas\_velocity.inp}}
(or \sphinxcode{\sphinxupquote{.binp}}), see Section
{\hyperref[\detokenize{lineradtrans:sec-velo-field}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The velocity field}}}}. If this file is not present, the gas velocity will
be assumed to be 0 everywhere, meaning that you have pure escape
probability.

\item {} 
\sphinxAtStartPar
Specify the ‘typical length scale’ \(L\) at each cell in the file
\sphinxcode{\sphinxupquote{escprob\_lengthscale.inp}} (or \sphinxcode{\sphinxupquote{.binp}}). If
this file is not present, then the length scale is assumed to be infinite,
meaning that you are back at pure LVG. The format of this file is
identical to that of the gas density.

\end{itemize}

\sphinxAtStartPar
Note that having no \sphinxcode{\sphinxupquote{escprob\_lengthscale.inp}} \sphinxstyleemphasis{nor} \sphinxcode{\sphinxupquote{gas\_velocity.inp}} file
in your model directory means that the photons cannot escape at all, and you
should find LTE populations (always a good test of the code).

\sphinxAtStartPar
Note that it is essential, when using the Large Velocity Gradient method without
specifying a length scale, that the gradients in the velocity field (given in
the file \sphinxcode{\sphinxupquote{gas\_velocity.inp}}, see Section {\hyperref[\detokenize{lineradtrans:sec-velo-field}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The velocity field}}}}) are indeed
sufficiently large. If they are zero, then this effectively means that the
optical depth in all the lines is assumed to be infinite, which means that the
populations are LTE again. If you use LVG but \sphinxstyleemphasis{also} specify a length scale in
the \sphinxcode{\sphinxupquote{escprob\_lengthscale.inp}} file, then this danger of unphysically LTE
populations is avoided.

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE: Currently this method does not yet include radiative exchange
with the dust continuum radiation field.}

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE: Currently this method does not yet include radiative pumping
by stellar radiation. Will be included soon.}


\section{Non\sphinxhyphen{}LTE Transfer: The optically thin line assumption method}
\label{\detokenize{lineradtrans:non-lte-transfer-the-optically-thin-line-assumption-method}}\label{\detokenize{lineradtrans:sec-optthinpop}}
\sphinxAtStartPar
An even simpler non\sphinxhyphen{}LTE method is applicable in \sphinxstyleemphasis{very} dilute
media, in which the lines are all optically thin. This means that
a photon that is emitted by the gas will never be reabsorbed.
If this condition is satisfied, then the non\sphinxhyphen{}LTE level populations
can be computed even easier than in the case of LVG (Section
{\hyperref[\detokenize{lineradtrans:sec-lvg}]{\sphinxcrossref{\DUrole{std,std-ref}{Non\sphinxhyphen{}LTE Transfer: The Large Velocity Gradient (LVG) + Escape Probability (EscProb) method}}}}). No iteration is then required. So to activate
this, the following has to be done:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Make sure that you use a molecular data file that contains
collision rate tables (see Section {\hyperref[\detokenize{lineradtrans:sec-molecule-xxx-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}}).

\item {} 
\sphinxAtStartPar
Make sure to provide file(s) containing the number densities
of the collision partners, e.g. \sphinxcode{\sphinxupquote{numberdens\_p\sphinxhyphen{}h2.inp}}
(see Section {\hyperref[\detokenize{lineradtrans:sec-collpartner}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The number density of collision partners (for non\sphinxhyphen{}LTE transfer)}}}}).

\item {} 
\sphinxAtStartPar
Make sure to link the rate tables to the number density
files in \sphinxcode{\sphinxupquote{lines.inp}} (see Section {\hyperref[\detokenize{lineradtrans:sec-line-dot-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The line.inp file}}}}).

\item {} 
\sphinxAtStartPar
Set the \sphinxcode{\sphinxupquote{lines\_mode=4}} in the \sphinxcode{\sphinxupquote{radmc3d.inp}}
file (see Section {\hyperref[\detokenize{inputoutputfiles:sec-radmc-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: radmc3d.inp}}}}).

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE: Currently this method does not yet include radiative pumping
by stellar radiation.}

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE: This mode does not *make} a model optically thin. Only
the populations of the levels are computed under the \{bf assumption\}
that the lines are optically thin. If you subsequently make a spectrum
or image of your model, all absorption effects are again included.*


\section{Non\sphinxhyphen{}LTE Transfer: Full non\sphinxhyphen{}local modes (FUTURE)}
\label{\detokenize{lineradtrans:non-lte-transfer-full-non-local-modes-future}}\label{\detokenize{lineradtrans:sec-nonlte-nonlocal}}
\sphinxAtStartPar
In the near future RADMC\sphinxhyphen{}3D will hopefully also feature full non\sphinxhyphen{}LTE transfer,
in which the level populations are coupled to the full non\sphinxhyphen{}local radiation
field. Methods such as \sphinxstyleemphasis{lambda iteration} and \sphinxstyleemphasis{accelerated lambda iteration}
will be implemented. For nomenclature we will call these ‘non\sphinxhyphen{}local non\sphinxhyphen{}LTE
modes’.

\sphinxAtStartPar
For these non\sphinxhyphen{}local non\sphinxhyphen{}LTE modes the level population calculation is done
separately from the image/spectrum ray\sphinxhyphen{}tracing: You will run RADMC\sphinxhyphen{}3D first
for computing the non\sphinxhyphen{}LTE populations. RADMC\sphinxhyphen{}3D will then write these to
file. Then you will call RADMC\sphinxhyphen{}3D for making images/spectra. This is very
similar to the dust transfer, in which you first call RADMC\sphinxhyphen{}3D for the Monte
Carlo dust temperature computation, and after that for the ray\sphinxhyphen{}tracing.  It
is, however, different from the \sphinxstyleemphasis{local non\sphinxhyphen{}LTE} modes, where the
populations are calculated automatically before any image/spectrum
ray\sphinxhyphen{}tracing, and the populations do not have to be written to file (only if
you want to inspect them: Section {\hyperref[\detokenize{lineradtrans:sec-nonlte-write-levelpop}]{\sphinxcrossref{\DUrole{std,std-ref}{Non\sphinxhyphen{}LTE Transfer: Inspecting the level populations}}}}).

\sphinxAtStartPar
For now, however, RADMC\sphinxhyphen{}3D still does not have the non\sphinxhyphen{}local non\sphinxhyphen{}LTE
modes.


\section{Non\sphinxhyphen{}LTE Transfer: Inspecting the level populations}
\label{\detokenize{lineradtrans:non-lte-transfer-inspecting-the-level-populations}}\label{\detokenize{lineradtrans:sec-nonlte-write-levelpop}}
\sphinxAtStartPar
When doing line radiative transfer it is often useful to inspect the level
populations. For instance, you may want to inspect how far from LTE your
populations are, or just check if the results are reasonable.  There are two
ways to do this:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
When making an image or spectrum, add the command\sphinxhyphen{}line option
\sphinxcode{\sphinxupquote{writepop}}, which will make RADMC\sphinxhyphen{}3D create output files
containing the level population values. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{2300} \PYG{n}{writepop}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Just calling \sphinxcode{\sphinxupquote{radmc3d}} with the command\sphinxhyphen{}line
option \sphinxcode{\sphinxupquote{calcpop}}, which will ask RADMC\sphinxhyphen{}3D to compute the
populations and write them to file, even without making any images
or spectra. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{calcpop}
\end{sphinxVerbatim}

\end{enumerate}

\sphinxAtStartPar
NOTE: For (future) non\sphinxhyphen{}local non\sphinxhyphen{}LTE modes (Section {\hyperref[\detokenize{lineradtrans:sec-nonlte-nonlocal}]{\sphinxcrossref{\DUrole{std,std-ref}{Non\sphinxhyphen{}LTE Transfer: Full non\sphinxhyphen{}local modes (FUTURE)}}}})
these level populations will anyway be written to a file, irrespective of the
\sphinxcode{\sphinxupquote{writepop}} command.

\sphinxAtStartPar
The resulting files will have names such as \sphinxcode{\sphinxupquote{levelpop\_co.dat}}
(for the CO molecule). The structure is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{nrcells}
\PYG{n}{nrlevels\PYGZus{}subset}
\PYG{n}{level1}  \PYG{n}{level2} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}                     \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{The} \PYG{n}{level} \PYG{n}{subset} \PYG{n}{selection}
\PYG{n}{popul}\PYG{p}{[}\PYG{n}{level1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{n}{popul}\PYG{p}{[}\PYG{n}{level2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Populations} \PYG{p}{(}\PYG{k}{for} \PYG{n}{subset}\PYG{p}{)} \PYG{n}{at} \PYG{n}{cell} \PYG{l+m+mi}{1}
\PYG{n}{popul}\PYG{p}{[}\PYG{n}{level1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{n}{popul}\PYG{p}{[}\PYG{n}{level2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Populations} \PYG{p}{(}\PYG{k}{for} \PYG{n}{subset}\PYG{p}{)} \PYG{n}{at} \PYG{n}{cell} \PYG{l+m+mi}{2}
\PYG{o}{.}
\PYG{o}{.}
\PYG{n}{popul}\PYG{p}{[}\PYG{n}{level1}\PYG{p}{,}\PYG{n}{nrcells}\PYG{p}{]}   \PYG{n}{popul}\PYG{p}{[}\PYG{n}{level2}\PYG{p}{,}\PYG{n}{nrcells}\PYG{p}{]} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first number is the format number, which is simply for RADMC\sphinxhyphen{}3D to be
backward compatible in the future, in case we decide to change/improve the
file format. The nrcells is the number of cells.

\sphinxAtStartPar
Then follows the number of levels (written as \sphinxcode{\sphinxupquote{nrlevels\_subset}} above). Note
that this is \sphinxstyleemphasis{not necessarily} equal to the number of levels found in the
\sphinxcode{\sphinxupquote{molecule\_co.inp}} file (for our CO example). It will only be equal to that if
the file has been produced by the command \sphinxcode{\sphinxupquote{radmc3d calcpop}}. If, however, the
file was produced after making an image or spectrum (e.g. through the command
\sphinxcode{\sphinxupquote{radmc3d image lambda 2300 writepop}}), then RADMC\sphinxhyphen{}3D will only write out those
levels that have been used to make the image or spectrum. See Section
{\hyperref[\detokenize{lineradtrans:sec-calcstore-levpop}]{\sphinxcrossref{\DUrole{std,std-ref}{Background information: Calculation and storage of level populations}}}} for more information about this. It is for this
reason that the file in fact contains a list of levels that are included (the
\sphinxcode{\sphinxupquote{level1 level 2 ...}} in the above file format example).

\sphinxAtStartPar
After these header lines follows the actual data. Each line contains the
populations at a spatial cell in units of \(\mathrm{cm}^{-3}\).

\sphinxAtStartPar
This file format is a generalization of the standard format which is
described for the example of dust density in Section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}.
Please read that section for more details, and also on how the format
changes if you use ‘layers’.

\sphinxAtStartPar
Also the unformatted style is described in Section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}. We
have, however, here the extra complication that at each cell we have more
than one number. Essentially this simply means that the length of the data
per cell is larger, so that fewer cells fit into a single record.


\section{Non\sphinxhyphen{}LTE Transfer: Reading the level populations from file}
\label{\detokenize{lineradtrans:non-lte-transfer-reading-the-level-populations-from-file}}\label{\detokenize{lineradtrans:sec-nonlte-read-levelpop}}
\sphinxAtStartPar
Sometimes you may want to make images and/or spectra of lines based on level
populations that you calculated using another program (or calculated using
RADMC\sphinxhyphen{}3D at some earlier time). You can ask RADMC\sphinxhyphen{}3D to read these
populations from files with the same name and same format as, for example,
\sphinxcode{\sphinxupquote{levelpop\_co.dat}} (for CO) as described in Section
{\hyperref[\detokenize{lineradtrans:sec-nonlte-write-levelpop}]{\sphinxcrossref{\DUrole{std,std-ref}{Non\sphinxhyphen{}LTE Transfer: Inspecting the level populations}}}}. The way to do this is to add a line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lines\PYGZus{}mode} \PYG{o}{=} \PYG{l+m+mi}{50}
\end{sphinxVerbatim}

\sphinxAtStartPar
to the \sphinxcode{\sphinxupquote{radmc3d.inp}} file.

\sphinxAtStartPar
You can test that it works by calculating the populations using another
\sphinxcode{\sphinxupquote{lines\_mode}} and calling \sphinxcode{\sphinxupquote{radmc3d calcpop writepop}} (which will produce the
\sphinxcode{\sphinxupquote{levelpop\_xxx.dat}} file); then change \sphinxcode{\sphinxupquote{lines\_mode}} to 50, and call \sphinxcode{\sphinxupquote{radmc3d
image iline 1}}. You should see a message that RAMDC\sphinxhyphen{}3D is actually reading the
populations (and it may, for 3\sphinxhyphen{}D models, take a bit of time to read the large
file).

\sphinxAtStartPar
Because of the rather lage size of these files for 3\sphinxhyphen{}D models, it might be
worthwhile to make sure to reduce the number of levels of the
\sphinxcode{\sphinxupquote{molecule\_xx.inp}} files to only those you actually need.


\section{What can go wrong with line transfer?}
\label{\detokenize{lineradtrans:what-can-go-wrong-with-line-transfer}}\label{\detokenize{lineradtrans:sec-lines-pitfalls}}
\sphinxAtStartPar
Even the simple task of performing a ray\sphinxhyphen{}tracing line transfer calculation
with given level populations (i.e. the so\sphinxhyphen{}called \sphinxstyleemphasis{formal transfer
equation}) is a non\sphinxhyphen{}trivial task in complex 3\sphinxhyphen{}D AMR models with possibly
highly supersonic motions. I recommend the user to do extensive and critical
experimentation with the code and make many simple tests to check if the
results are as they are expected to be. In the end a result must be
understandable in terms of simple argumentation. If weird effects show up,
please do some detective work until you understand why they show up, i.e.
that they are either a \sphinxstyleemphasis{real} effect or a numerical issue. There are
many numerical artifacts that can show up that are \sphinxstyleemphasis{not} a bug in the
code. The code simply does a numerical integration of the equations on some
spatial\sphinxhyphen{} and wavelength\sphinxhyphen{}grid. If the user chooses these grids unwisely, the
results may be completely wrong even if the code is formally OK. These
possible pitfalls is what this section is about.

\sphinxAtStartPar
So here is a list of things to check:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Make sure that the line(s) you want to model are indeed in the
molecular data file you use. Also make sure that it/they are included in
the line selection (if you are using this option; by default all lines and
levels from the molecular/atomic data files are included; see Section
{\hyperref[\detokenize{lineradtrans:sec-calcstore-levpop}]{\sphinxcrossref{\DUrole{std,std-ref}{Background information: Calculation and storage of level populations}}}}).

\item {} 
\sphinxAtStartPar
If you do LTE line transfer, and you do not let \sphinxcode{\sphinxupquote{radmc3d}}
read in a special file for the partition function, then the partition
function will be computed internally by \sphinxcode{\sphinxupquote{radmc3d}}. The code will
do so based on the levels specified in the \sphinxcode{\sphinxupquote{molecule\_XXX.inp}}
file for molecule \sphinxcode{\sphinxupquote{XXX}}. This requires of course that all levels
that may be excited at the temperatures found in the model are in fact
present in the \sphinxcode{\sphinxupquote{molecule\_XXX.inp}} file. If, for instance, you
model 1.3 mm and 2.6 mm rotational lines of CO gas of up to 300 K, and
your file \sphinxcode{\sphinxupquote{molecule\_co.inp}} only contains the first three
levels because you think you only need those for your 1.3 and 2.6 mm
lines, and you \sphinxstyleemphasis{don’t} specify the partition function explicitly, then
\sphinxcode{\sphinxupquote{radmc3d}} will compute the partition function for all
temperatures including 300 K based on only the first three levels. This is
evidently wrong. The nasty thing is: the resulting lines won’t be totally
absurd. They will just be too bright. But this can easily go undetected by
you as the user. So please keep this always in mind.  Note that if you
make a \sphinxstyleemphasis{selection} of the first three levels (see Section
{\hyperref[\detokenize{lineradtrans:sec-line-selection}]{\sphinxcrossref{\DUrole{std,std-ref}{For experts: Selecting a subset of lines and levels ‘manually’}}}}) but the file \sphinxcode{\sphinxupquote{molecule\_XXX.inp}}
contains many more levels, then this problem will not appear, because the
partition function will be calculated on the original data from the
\sphinxcode{\sphinxupquote{molecule\_XXX.inp}} file, not from the selected levels.  Of
course it is safer to specify the true partition function directly through
the file \sphinxcode{\sphinxupquote{partitionfunction\_XXX.inp}} (see Section
{\hyperref[\detokenize{lineradtrans:sec-partition-function}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT for LTE line transfer: The partition function (optional)}}}}).

\item {} 
\sphinxAtStartPar
If you have a model with non\sphinxhyphen{}zero gas velocities, and if these gas
velocities have cell\sphinxhyphen{}to\sphinxhyphen{}cell differences that are larger than or equal to
the intrinsic (thermal+microturbulent) line width, then the ray\sphinxhyphen{}tracing
will not be able to pick up signals from intermediate velocities. In other
words, because of the discrete gridding of the model, only discrete
velocities are present, which can cause numerical problems. See
Fig. \hyperref[\detokenize{lineradtrans:fig-doppler-catch}]{Fig.\@ \ref{\detokenize{lineradtrans:fig-doppler-catch}}}\sphinxhyphen{}Left for a pictographic representation of
this problem. There are two possible solutions. One is the wavelength band
method described in Section {\hyperref[\detokenize{imagesspectra:sec-wavelength-bands}]{\sphinxcrossref{\DUrole{std,std-ref}{Heads\sphinxhyphen{}up: In reality wavelength are actually wavelength bands}}}}.  But a more
systematic method is the ‘doppler catching’ method described in Section
{\hyperref[\detokenize{lineradtrans:sec-doppler-catching}]{\sphinxcrossref{\DUrole{std,std-ref}{Preventing doppler jumps: The ‘doppler catching method’}}}} (which can be combined with the wavelength band
method of Section {\hyperref[\detokenize{imagesspectra:sec-wavelength-bands}]{\sphinxcrossref{\DUrole{std,std-ref}{Heads\sphinxhyphen{}up: In reality wavelength are actually wavelength bands}}}} to make it even more
perfect).

\end{enumerate}


\section{Preventing doppler jumps: The ‘doppler catching method’}
\label{\detokenize{lineradtrans:preventing-doppler-jumps-the-doppler-catching-method}}\label{\detokenize{lineradtrans:sec-doppler-catching}}
\sphinxAtStartPar
If the local co\sphinxhyphen{}moving line width of a line (due to thermal/fundamental
broadning and/or local subgrid ‘microturbulence’) is much smaller than the
typical velocity fields in the model, then a dangerous situation can
occur. This can happen if the co\sphinxhyphen{}moving line width is narrower than the
doppler shift between two adjacent cells. When a ray is traced, in one cell
the line can then have a doppler shift substantially to the blue of the
wavelength\sphinxhyphen{}of\sphinxhyphen{}sight, while in the next cell the line suddenly shifted to the
red side. If the intrinsic (= thermal + microturbulent) line width is
smaller than these shifts, neither cell gives a contribution to the emission
in the ray. See Fig. \hyperref[\detokenize{lineradtrans:fig-doppler-jump}]{Fig.\@ \ref{\detokenize{lineradtrans:fig-doppler-jump}}} for a pictographic
representation of this problem. In reality the doppler shift between these
two cells would be smooth, and thus the line would smoothly pass over the
wavelength\sphinxhyphen{}of\sphinxhyphen{}sight, and thus make a contribution. Therefore the numerical
integration may thus go wrong.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{line_doppjump}.pdf}
\caption{Pictographic representation of the doppler jumping problem with
ray\sphinxhyphen{}tracing through a model with strong cell\sphinxhyphen{}to\sphinxhyphen{}cell velocity differences.}\label{\detokenize{lineradtrans:id1}}\label{\detokenize{lineradtrans:fig-doppler-jump}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{line_doppcatch}.pdf}
\caption{Right: Pictographic representation of the doppler catching method to
prevent this problem: First of all, second order integration is done
instead of first order. Secondly, the method automatically detects a
possibly dangerous doppler jump and makes sub\sphinxhyphen{}steps to neatly integrate
over the line that shifts in\sphinxhyphen{} and out of the wavelength channel of
interest.}\label{\detokenize{lineradtrans:id2}}\label{\detokenize{lineradtrans:fig-doppler-catch}}\end{figure}

\sphinxAtStartPar
The problem is described in more detail in Section {\hyperref[\detokenize{imagesspectra:sec-wavelength-bands}]{\sphinxcrossref{\DUrole{std,std-ref}{Heads\sphinxhyphen{}up: In reality wavelength are actually wavelength bands}}}},
and one possible solution is proposed there.  But that solution does not always
solve the problem.

\sphinxAtStartPar
RADMC\sphinxhyphen{}3D has a special method to catch situations like the above, and when
it detects one, to make sub\sphinxhyphen{}steps in the integration of the formal transfer
equation so that the smooth passing of the line through the
wavelength\sphinxhyphen{}of\sphinxhyphen{}sight can be properly accounted for. Here this is called
‘doppler catching’, for lack of a better name. The technique was discussed
in great detail in Pontoppidan et al. (2009, ApJ 704, 1482). The idea is
that the method automatically tests if a line might ‘doppler jump’ over
the current wavelength channel. If so, it will insert substeps in the
integration at the location where this danger is present. See
Fig. \hyperref[\detokenize{lineradtrans:fig-doppler-catch}]{Fig.\@ \ref{\detokenize{lineradtrans:fig-doppler-catch}}} for a pictographic representation of this
method. Note that this method can only be used with the second order
ray\sphinxhyphen{}tracing (see Section {\hyperref[\detokenize{imagesspectra:sec-second-order}]{\sphinxcrossref{\DUrole{std,std-ref}{Second order ray\sphinxhyphen{}tracing (Important information!)}}}}); in fact, as soon as you
switch the doppler catching on, RADMC\sphinxhyphen{}3D will automatically also switch on
the second order ray\sphinxhyphen{}tracing.

\sphinxAtStartPar
To switch on doppler catching, you simply add the command\sphinxhyphen{}line option
\sphinxcode{\sphinxupquote{doppcatch}} to the image or spectrum command. For instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{spectrum} \PYG{n}{iline} \PYG{l+m+mi}{1} \PYG{n}{widthkms} \PYG{l+m+mi}{10} \PYG{n}{doppcatch}
\end{sphinxVerbatim}

\sphinxAtStartPar
(again: you do not need to add \sphinxcode{\sphinxupquote{secondorder}}, because it is automatic when
\sphinxcode{\sphinxupquote{doppcatch}} is used).

\sphinxAtStartPar
The Doppler catching method will assure that the line is integrated over with
small enough steps that it cannot accidently get jumped over. How fine these
steps will be can be adjusted with the \sphinxcode{\sphinxupquote{catch\_doppler\_resolution}} keyword in
the \sphinxcode{\sphinxupquote{radmc3d.inp}} file. The default value is 0.2, meaning that it will make
the integration steps small enough that the doppler shift over each step is not
more than 0.2 times the local intrinsic (thermal+microturbulent) line
width. That is usually enough, but for some problems it might be important to
ensure that smaller steps are taken. By adding a line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{catch\PYGZus{}doppler\PYGZus{}resolution} \PYG{o}{=} \PYG{l+m+mf}{0.05}
\end{sphinxVerbatim}

\sphinxAtStartPar
to the \sphinxcode{\sphinxupquote{radmc3d.inp}} file you will ensure that steps are small
enough that the doppler shift is at most 0.05 times the local line width.

\sphinxAtStartPar
So why is doppler catching an \sphinxstyleemphasis{option}, i.e. why would this not be standard?
The reason is that doppler catching requires second order integration, which
requires RADMC\sphinxhyphen{}3D to first map all the cell\sphinxhyphen{}based quantities to the
cell\sphinxhyphen{}corners. This requires extra memory, which for very large models can be
problematic. It also requires more CPU time to calculate images/spectra with
second order integration. So if you do not need it, i.e. if your velocity
gradients are not very steep compared to the intrinsic line width, then it saves
time and memory to not use doppler catching.

\sphinxAtStartPar
It is, however, important to realize that doppler catching is not the golden
bullet. Even with doppler catching it might happen that some line flux is lost,
but this time as a result of too low \sphinxstyleemphasis{image resolution}. This is less likely to
happen in problems like ISM turbulence, but it is pretty likely to happen in
models of rotating disks. Suppose we have a very thin local line width (i.e.
low gas temperature and no microturbulence) in a rotating thin disk around a
star. In a given velocity channel (i.e. at a given observer\sphinxhyphen{}frame frequency) a
molecular line in the disk emits only in a very thin ‘ear\sphinxhyphen{}shaped’ ring or band
in the image. The thinner the intrinsic line width, the thinner the band on the
image. See Pontoppidan et al. (2009, ApJ 704, 1482) and Pavlyuchenkov et
al. (2007, ApJ 669, 1262) for example. If the pixel\sphinxhyphen{}resolution of the image is
smaller than that of this band, the image is simply underresolved.  This has
nothing to do with the doppler jumping problem, but can be equally devastating
for the results if the user is unaware of this. There appears to be only one
proper solution: assure that the pixel\sphinxhyphen{}resolution of the image is sufficiently
fine for the problem at hand. This is easy to find out: The image would simply
look terribly noisy if the resolution is insufficient. However, if you are not
interested in the images, but only in the spectra, then some amount of noisiness
in the image (i.e. marginally sufficient resolution) is OK, since the total
flux is an integral over the entire image, smearing out much of the noise.  It
requires some experimentation, though.

\sphinxAtStartPar
Here are some additional issues to keep in mind:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The doppler catching method uses second order integration (see Section
{\hyperref[\detokenize{imagesspectra:sec-second-order}]{\sphinxcrossref{\DUrole{std,std-ref}{Second order ray\sphinxhyphen{}tracing (Important information!)}}}}), and therefore all the relevant quantities first
have to be interpolated from the cell centers to the cell corners. Well
inside the computational domain this amounts to linear interpolation. But
at the edges of the domain it would require \sphinxstyleemphasis{extra} polation.
In 1\sphinxhyphen{}D this is more easily illustrated, because
there the cell corners are in fact cell interfaces. Cells \(i\) and \(i+1\)
share cell interface \(i+1/2\). If we have \(N\) cells, i.e. cells
\(i=1,\cdots,N\), then we have \(N+1\) interfaces, i.e. interfaces
\(i=\tfrac{1}{2},\cdots,N+\tfrac{1}{2}\). To get physical quantities from
the cell centers to cell interfaces
\(i=\tfrac{3}{2},\cdots,N-\tfrac{1}{2}\) requires just interpolation. But
to find the physical quantities at cell interfaces \(i=\tfrac{1}{2}\) and
\(i=N+\tfrac{1}{2}\) one has to extrapolate or simply take the values at
the cell centers \(i=1\) and \(i=N\). RADMC\sphinxhyphen{}3D does not do
extrapolation but simply takes the average values of the nearest
cells. Also the gas velocity is treated like this. This means that over
the edge cells the gradient in the gas velocity tends to be (near)
0. Since for the doppler catching it is the gradient of the velocity that
matters, this might yield some artifacts in the spectrum if the density in
the border cells is high enough to produce substantial line
emission. Avoiding this numerical artifact is relatively easy: One should
then simply put the number density of the molecule in question to zero in
the boundary cells.

\item {} 
\sphinxAtStartPar
If you are using RADMC\sphinxhyphen{}3D on a 3\sphinxhyphen{}D (M)HD model which has strong shocks
in its domain, then one must be careful that (magneto\sphinxhyphen{})hydrodynamic codes
tend to smear out the shock a bit. This means that there will be some
cells that have intermediate density and velocity in the smeared out
region of the shock. This is unphysical, but an intrinsic numerical
artifact of numerical hydrodynamics codes. This might, under some
conditions, lead to unphysical signal in the spectrum, because there would
be cells at densities, temperatures and velocities that would be in
between the values at both sides of the shock and would, in reality, not
be there. It is very difficult to avoid this problem, and even to find out
if this problem is occurring and by how much. One must simply be very
careful of models containing strong shocks and do lots of testing.  One
way to test is to use the doppler catching method and vary the doppler
catching resolution (using the \sphinxcode{\sphinxupquote{catch\_doppler\_resolution}}
keyword in \sphinxcode{\sphinxupquote{radmc3d.inp}}).

\item {} 
\sphinxAtStartPar
If using line transfer in spherical coordinates using doppler
catching, the linear interpolation of the line shift between the beginning
and the end of a segment may not always be enough to accurately prevent
doppler jumps. This is because in addition to the physical gradient of gas
velocity, the projected gas velocity along a ray changes also along the
ray due to the geometry (the use of spherical coordinates). Example: a
spherically symmetric radially outflowing wind with constant outward
velocity \(v_r=`const. Although :math:`v_r\) is constant, the 3\sphinxhyphen{}D \sphinxstyleemphasis{vector}
\(\vec v\) is not constant, since it always points outward. A ray through
this wind will thus have a varying \(\vec n\cdot \vec v\) along the ray.  In
the cell where the ray reaches its closest approach to the origin of the
coordinate system the \(\vec n\cdot \vec v\) will vary the strongest.  This
may be such a strong effect that it could affect the reliability of the
code. \sphinxstyleemphasis{As of version 0.41 of this code a method is in place to prevent
this}. It is switched on by default, but it can be switched off manually
for testing purposes. See Section {\hyperref[\detokenize{imagesspectra:sec-secord-spher}]{\sphinxcrossref{\DUrole{std,std-ref}{Second order integration in spherical coordinates: a subtle issue}}}} for details.

\end{itemize}


\section{Background information: Calculation and storage of level populations}
\label{\detokenize{lineradtrans:background-information-calculation-and-storage-of-level-populations}}\label{\detokenize{lineradtrans:sec-calcstore-levpop}}
\sphinxAtStartPar
If RADMC\sphinxhyphen{}3D makes an image or a spectrum with molecular (or atomic) lines
included, then the level populations of the molecules/atoms have to be
computed. In the standard method of ray\sphinxhyphen{}tracing of images or spectra, these
level populations are first calculated in each grid cell and stored in a global
array. Then the raytracer will render the image or spectrum.

\sphinxAtStartPar
The storage of the level populations is a tricky matter, because if this is done
in the obvious manner, it might require a huge amount of memory. This would then
prevent us from making large scale models. For instance: if you have a molecule
with 100 levels in a model with 256x256x256 \(\simeq 1.7\times 10^7\) cells,
the global storage for the populations alone (with each number in double
precision) would be roughly 100x8x256x256x256 \(\simeq\) 13 Gigabyte.

\sphinxAtStartPar
However, if you intend to make a spectrum in just 1 line, you do not need all
these level populations. To stick to the above example, let us take the CO 1\sphinxhyphen{}0
line, which is then line 1 and which connects levels \(J=1\) and
\(J=0\), which are levels 2 and 1 in the code (if you use the Leiden
database CO data file).  Once the populations have been computed, we only need
to store the levels 1 and 2. This would then require 2x8x256x256x256
\(\simeq\) 0.26 Gigabyte, which would be \sphinxstyleemphasis{much} less memory\sphinxhyphen{}costly.

\sphinxAtStartPar
As of version 0.29 RADMC\sphinxhyphen{}3D automatically figures out which levels have to
be stored in a global array, in order to be able to render the images or the
spectrum properly. RADMC\sphinxhyphen{}3D will go through all the lines of all molecules
and checks if they contribute to the wavelength(s), of the image(s) or the
spectrum. Once it has assembled a list of ‘active’ lines, it will make a
list of ‘active’ levels that belong to these lines. It will then declare
this to be the ‘subset’ of levels for which the populations will be stored
globally.

\sphinxAtStartPar
In other words: RADMC\sphinxhyphen{}3D now takes care of the memory\sphinxhyphen{}saving storage of
the populations automatically.

\sphinxAtStartPar
\sphinxstyleemphasis{How does RADMC\sphinxhyphen{}3D decide whether a line contributes to some wavelength}
\(\lambda\)? A line \(i\) with line center \(\lambda_i\) is
considered to contribute to an image at wavelength \(\lambda\) if
\begin{equation*}
\begin{split}| \lambda_i-\lambda | \le C_{\mathrm{margin}}\Delta\lambda_i\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Delta\lambda_i\) is the line width (including all contributions)
and \(C_{\mathrm{margin}}\) is a constant. By default
\begin{equation*}
\begin{split}C_{\mathrm{margin}} = 12\end{split}
\end{equation*}
\sphinxAtStartPar
But you can change this to another value, say 24, by adding in the
\sphinxcode{\sphinxupquote{radmc3d.inp}} file a line containing, e.g. \sphinxcode{\sphinxupquote{lines\_widthmargin = 24}}.

\sphinxAtStartPar
You can in fact get a dump of the level populations that have been computed and
used for the image(s)/spectrum you created, by adding \sphinxcode{\sphinxupquote{writepop}} on the
command line. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{spectrum} \PYG{n}{iline} \PYG{l+m+mi}{1} \PYG{n}{widthkms} \PYG{l+m+mi}{10} \PYG{n}{writepop}
\end{sphinxVerbatim}

\sphinxAtStartPar
This then creates (in addition to the spectrum) a file called (for our
example of the CO molecule) \sphinxcode{\sphinxupquote{levelpop\_co.dat}}. Here is how you can read
this data in Python:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{radmc3d\PYGZus{}tools} \PYG{k+kn}{import} \PYG{n}{simpleread}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{simpleread}\PYG{o}{.}\PYG{n}{read\PYGZus{}levelpop}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{data}} object then contains \sphinxcode{\sphinxupquote{data.pop}} and \sphinxcode{\sphinxupquote{data.relpop}}, which are
the level populations in \(1/cm^3\) and in normalized form.

\sphinxAtStartPar
If, for some reason, you want always \sphinxstyleemphasis{all} levels to be stored (and you can
afford to do so with the size of your computer’s memory), you can make RADMC\sphinxhyphen{}3D
do so by adding \sphinxcode{\sphinxupquote{noautosubset}} as a keyword to the command line, or by adding
\sphinxcode{\sphinxupquote{lines\_autosubset = 0}} to the \sphinxcode{\sphinxupquote{radmc3d.inp}} file. However, for other than
code testing purposes, it seems unlikely you will wish to do this.


\section{In case it is necessary: On\sphinxhyphen{}the\sphinxhyphen{}fly calculation of populations}
\label{\detokenize{lineradtrans:in-case-it-is-necessary-on-the-fly-calculation-of-populations}}\label{\detokenize{lineradtrans:sec-onthefly}}
\sphinxAtStartPar
There might be rare circumstances in which you do not want to have to store
the level populations in a global array. For example: you are making a spectrum
of the CO bandhead, in which case you have many tens of lines in a single
spectrum. If your model contains 256x256x256 cells (see example in Section
{\hyperref[\detokenize{lineradtrans:sec-calcstore-levpop}]{\sphinxcrossref{\DUrole{std,std-ref}{Background information: Calculation and storage of level populations}}}}) then this might easily require many Gigabytes of
memory just to store the populations.

\sphinxAtStartPar
For the LTE, LVG and optically thin level population modes there is a way out:
You can force RADMC\sphinxhyphen{}3D to compute the populations \sphinxstyleemphasis{on\sphinxhyphen{}the\sphinxhyphen{}fly} during the
ray\sphinxhyphen{}tracing, which does not require a global storage of the level populations.

\sphinxAtStartPar
The way to do this is simple: Just make the \sphinxcode{\sphinxupquote{lines\_mode}} negative. So for
on\sphinxhyphen{}the\sphinxhyphen{}fly LTE mode use \sphinxcode{\sphinxupquote{lines\_mode=\sphinxhyphen{}1}}, for on\sphinxhyphen{}the\sphinxhyphen{}fly user\sphinxhyphen{}defined
populations mode use \sphinxcode{\sphinxupquote{lines\_mode=\sphinxhyphen{}2}}, for on\sphinxhyphen{}the\sphinxhyphen{}fly LVG mode use
\sphinxcode{\sphinxupquote{lines\_mode=\sphinxhyphen{}3}} and for on\sphinxhyphen{}the\sphinxhyphen{}fly optically thin populations use
\sphinxcode{\sphinxupquote{lines\_mode=\sphinxhyphen{}4}}.

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE: The drawback of this method is that, under certain circumstances, it can
slow down the code dramatically.} This slow\sphinxhyphen{}down happens if you use e.g.
second\sphinxhyphen{}order integration (Section {\hyperref[\detokenize{imagesspectra:sec-second-order}]{\sphinxcrossref{\DUrole{std,std-ref}{Second order ray\sphinxhyphen{}tracing (Important information!)}}}}) and/or doppler
catching (Section {\hyperref[\detokenize{lineradtrans:sec-doppler-catching}]{\sphinxcrossref{\DUrole{std,std-ref}{Preventing doppler jumps: The ‘doppler catching method’}}}}) together with non\sphinxhyphen{}trivial
population solving methods like LVG. So please use the on\sphinxhyphen{}the\sphinxhyphen{}fly method only
when you are forced to do so (for memory reasons).


\section{For experts: Selecting a subset of lines and levels ‘manually’}
\label{\detokenize{lineradtrans:for-experts-selecting-a-subset-of-lines-and-levels-manually}}\label{\detokenize{lineradtrans:sec-line-selection}}
\sphinxAtStartPar
As explained in Section {\hyperref[\detokenize{lineradtrans:sec-calcstore-levpop}]{\sphinxcrossref{\DUrole{std,std-ref}{Background information: Calculation and storage of level populations}}}}, RADMC\sphinxhyphen{}3D automatically
makes a selection of levels for which it will allocate memory for the global
level population storage.

\sphinxAtStartPar
If, for some reason, you wish to make this selection yourself ‘by hand’, this
can also be done. However, please be informed that there are very few
circumstances under which you may want to do this. The automatic subset
selection of RADMC\sphinxhyphen{}3D is usually sufficient!

\sphinxAtStartPar
\sphinxstyleemphasis{If} you decided to really want to do this, here is how:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Switch off the automatic subset selection by adding \sphinxcode{\sphinxupquote{noautosubset}} as
a keyword to the command line, or by adding \sphinxcode{\sphinxupquote{lines\_autosubset = 0}} to
the \sphinxcode{\sphinxupquote{radmc3d.inp}} file.

\item {} 
\sphinxAtStartPar
In the \sphinxcode{\sphinxupquote{lines.inp}} file, for each molecule, modify the
‘0 0’ (the first two zeroes after ‘leiden’) in the way described below.

\end{enumerate}

\sphinxAtStartPar
In Section {\hyperref[\detokenize{lineradtrans:sec-line-dot-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The line.inp file}}}} you can see that each molecule has a line
like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{co}   \PYG{n}{leiden}   \PYG{l+m+mi}{0}  \PYG{l+m+mi}{0}  \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
or so (here for the example of CO). In Section {\hyperref[\detokenize{lineradtrans:sec-line-dot-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: The line.inp file}}}} we
explained the meaning of the third number, but we did not explain the meaning of
the first and second ones. These are meant for this subset selection. If we want
to store only the first 10 levels of the CO molecule, then replace the above
line with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{co}   \PYG{n}{leiden}   \PYG{l+m+mi}{0}  \PYG{l+m+mi}{10}  \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you want to select specific levels (let us choose the \sphinxcode{\sphinxupquote{ilevel=3}} and
\sphinxcode{\sphinxupquote{ilevel=4}} levels of the above example), then write:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{co}   \PYG{n}{leiden}   \PYG{l+m+mi}{1}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{0}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\sphinxAtStartPar
The ‘1’ says that a list of levels follows, the ‘2’ says that two levels will be
selected and the next line with ‘3’ and ‘4’ say that levels 3 and 4 should be
selected.

\sphinxstepscope


\chapter{Making images and spectra}
\label{\detokenize{imagesspectra:making-images-and-spectra}}\label{\detokenize{imagesspectra:chap-images-spectra}}\label{\detokenize{imagesspectra::doc}}
\sphinxAtStartPar
Much has already been said about images and spectra in the chapters on
dust radiative transfer and line radiative transfer. But here we will
combine all this and go deeper into this material. So presumably you
do not need to read this chapter if you are a beginning user. But for
more sophisticated users (or as a reference manual) this chapter may
be useful and presents many new features and more in\sphinxhyphen{}depth insight.


\section{Basics of image making with RADMC\sphinxhyphen{}3D}
\label{\detokenize{imagesspectra:basics-of-image-making-with-radmc-3d}}\label{\detokenize{imagesspectra:sec-images}}
\sphinxAtStartPar
Images and spectra are typically made after the dust temperature has been
determined using the thermal Monte Carlo run (see Chapter {\hyperref[\detokenize{dustradtrans:chap-dust-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Dust continuum radiative transfer}}}}).
An image can now be made with a simple call to
\sphinxcode{\sphinxupquote{radmc3d}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxAtStartPar
This makes an image of the model at wavelength \(\lambda=10\mu`m and writes
this to the file ``image.out`\). We refer to Section
{\hyperref[\detokenize{inputoutputfiles:sec-image-out}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT: image.out or image\_****.out}}}} for details of this file and how to interpret the
content. See Chapter {\hyperref[\detokenize{pythontools:chap-python-analysis-tools}]{\sphinxcrossref{\DUrole{std,std-ref}{Python analysis tool set}}}} for an extensive Python tools
that make it easy to read and handle these files. The vantage point is
at infinity at a default inclination of 0, i.e. pole\sphinxhyphen{}on view. You can
change the vantage point:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{80} \PYG{n}{phi} \PYG{l+m+mi}{30}
\end{sphinxVerbatim}

\sphinxAtStartPar
which now makes the image at inclination 80 degrees away from the z\sphinxhyphen{}axis
(i.e. almost edge\sphinxhyphen{}on with respect to the x\sphinxhyphen{}y plane), and rotates the
location of the observer by 30 degrees clockwise around the
z\sphinxhyphen{}axis (Here clockwise is defined with the z\sphinxhyphen{}axis pointing toward
you, i.e. with respect to the observer the model is rotated
counter\sphinxhyphen{}clockwise around the z\sphinxhyphen{}axis by 30 degrees).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{camera_orient}.pdf}
\caption{Figure depicting how the angles ‘incl’ and ‘phi’ place the camera for images
and spectra made with RADMC\sphinxhyphen{}3D. The code uses a right\sphinxhyphen{}handed coordinate
system. The figure shows from which direction the observer is looking at the
system, where \(i_{\mathrm{obs}}\) is the ‘incl’ keyword and
\(\phi_{\mathrm{obs}}\) is the ‘phi’ keyword. The
\(x_{\mathrm{image}}\) and \(y_{\mathrm{image}}\) are the horizontal
(left\sphinxhyphen{}to\sphinxhyphen{}right) and vertical (bottom\sphinxhyphen{}to\sphinxhyphen{}top) coordinates of the image. For
\(i_{\mathrm{obs}}=0\) and \(\phi_{\mathrm{obs}}=0\) the
\(x_{\mathrm{image}}\) aligns with the 3\sphinxhyphen{}D \(x\)\sphinxhyphen{}coordinate and
\(y_{\mathrm{image}}\) aligns with the 3\sphinxhyphen{}D \(y\)\sphinxhyphen{}coordinate.}\label{\detokenize{imagesspectra:id3}}\label{\detokenize{imagesspectra:fig-cameraorient}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{posang}.pdf}
\caption{This figure shows the way the camera can be rotated in the image plane using
‘posang’. Positive ‘posang’ means that the camera is rotated clockwise, so
the object shown is rotated counter\sphinxhyphen{}clockwise with respect to the image
coordinates.}\label{\detokenize{imagesspectra:id4}}\label{\detokenize{imagesspectra:fig-posang}}\end{figure}

\sphinxAtStartPar
You can also rotate the camera in the image plane with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{posang} \PYG{l+m+mi}{20}
\end{sphinxVerbatim}

\sphinxAtStartPar
which rotates the camera by 20 degrees clockwise (i.e. the image rotates
counter\sphinxhyphen{}clockwise). Figures \hyperref[\detokenize{imagesspectra:fig-cameraorient}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-cameraorient}}} and \hyperref[\detokenize{imagesspectra:fig-posang}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-posang}}} show
the definitions of all three angles. Up to now the camera always pointed to one
single point in space: the point (0,0,0). You can change this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{posang} \PYG{l+m+mi}{20} \PYG{n}{pointau} \PYG{l+m+mf}{3.2} \PYG{l+m+mf}{0.1} \PYG{l+m+mf}{0.4}
\end{sphinxVerbatim}

\sphinxAtStartPar
which now points the camera at the point (3.2,0.1,0.4), where the numbers are in
units of AU. The same can be done in units of parsec:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{posang} \PYG{l+m+mi}{20} \PYG{n}{pointpc} \PYG{l+m+mf}{3.2} \PYG{l+m+mf}{0.1} \PYG{l+m+mf}{0.4}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{pointau}} and \sphinxcode{\sphinxupquote{pointpc}} are always 3\sphinxhyphen{}D positions specified in
cartesian coordinates. This remains also true when the model\sphinxhyphen{}grid is in
spherical coordinates and/or when the model is 2\sphinxhyphen{}D (axisymmetric) or 1\sphinxhyphen{}D
(spherically symmetric): 3\sphinxhyphen{}D positions are always specified in x,y,z.

\sphinxAtStartPar
Let’s now drop the pointing again, and also forget about the \sphinxcode{\sphinxupquote{posang}}, and try
to change the number of pixels used:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{npix} \PYG{l+m+mi}{100}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will make an image of 100x100. You can also specify the x\sphinxhyphen{} and y\sphinxhyphen{} direction
number of pixels separately:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{npixx} \PYG{l+m+mi}{100} \PYG{n}{npixy} \PYG{l+m+mi}{30}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now let’s forget again about the number of pixels and change the size of the
image, i.e. which zooming factor we have:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{sizeau} \PYG{l+m+mi}{30}
\end{sphinxVerbatim}

\sphinxAtStartPar
This makes an image which has 30 AU width and 30 AU height (i.e. 15 AU from the
center in both directions). Same can be done in units of parsec

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{sizepc} \PYG{l+m+mi}{30}
\end{sphinxVerbatim}

\sphinxAtStartPar
Although strictly speaking redundant is the possibility to zoom\sphinxhyphen{}in right into a
selected box in this image:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{zoomau} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.} \PYG{l+m+mi}{0} \PYG{l+m+mi}{6}
\end{sphinxVerbatim}

\sphinxAtStartPar
which means that we zoom in to the box given by \(-10\le x\le-4\) AU and
\(0\le y\le 6\) AU on the original image (note that \sphinxcode{\sphinxupquote{zoomau \sphinxhyphen{}15 15 \sphinxhyphen{}15 15}}
gives the identical result as \sphinxcode{\sphinxupquote{sizeau 30}}). This possibility is strictly
speaking redundant, because you could also change the \sphinxcode{\sphinxupquote{pointau}} and \sphinxcode{\sphinxupquote{sizeau}}
to achieve the same effect (unless you want to make a non\sphinxhyphen{}square image, in which
case this is the only way). But it is just more convenient to do any zooming\sphinxhyphen{}in
this way. Please note that when you make non\sphinxhyphen{}square images with \sphinxcode{\sphinxupquote{zoomau}} or
\sphinxcode{\sphinxupquote{zoompc}}, the code will automatically try to keep the pixels square in shape
by adapting the number of pixels in x\sphinxhyphen{} or y\sphinxhyphen{} direction in the image and
adjusting one of the sizes a tiny bit to assure that both x\sphinxhyphen{} and y\sphinxhyphen{} size are an
integer times the pixel size. These are very small adjustments (and only take
place for non\sphinxhyphen{}square zoom\sphinxhyphen{}ins).  If you want to force the code to take \sphinxstyleemphasis{exactly}
the zoom area, and you don’t care that the pixels then become slightly
non\sphinxhyphen{}square, you can force it with \sphinxcode{\sphinxupquote{truezoom}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{sizeau} \PYG{l+m+mi}{30} \PYG{n}{zoomau} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.} \PYG{l+m+mi}{0} \PYG{l+m+mf}{3.1415} \PYG{n}{truezoom}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you do not want the code to adjust the number of pixels in x\sphinxhyphen{} and y\sphinxhyphen{}
direction in its attempt to keep the pixels square:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{sizeau} \PYG{l+m+mi}{30} \PYG{n}{zoomau} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.} \PYG{l+m+mi}{0} \PYG{l+m+mf}{3.1415} \PYG{n}{npixx} \PYG{l+m+mi}{100} \PYG{n}{npixy} \PYG{l+m+mi}{4} \PYG{n}{truepix}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now here are some special things. Sometimes you would like to see an image of
just the dust, not including stars (for stars in the image: see Section
{\hyperref[\detokenize{imagesspectra:sec-image-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{Stars in the images and spectra}}}}). So blend out the stars in the image, you use the
\sphinxcode{\sphinxupquote{nostar}} option:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{nostar}
\end{sphinxVerbatim}

\sphinxAtStartPar
Another special option is to get a ‘quick image’, in which the code does not
attempt assure flux conservation in the image (see Section
{\hyperref[\detokenize{imagesspectra:sec-image-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{The issue of flux conservation: recursive sub\sphinxhyphen{}pixeling}}}} for the issue of flux conservation). Doing the image
with flux conservation is slower than if you make it without flux
conservation. Making an image without flux conservation can be useful if you
want to have a ‘quick look’, but is strongly discouraged for actual scientific
use. But for a quick look you can do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{nofluxcons}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you want to produce images with a smoother look (and which also are more
accurate), you can ask RADMC\sphinxhyphen{}3D to use second order integration for the images:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{secondorder}
\end{sphinxVerbatim}

\sphinxAtStartPar
NOTE: The resulting intensities may be slightly different from the case when
first order integration (default) is used, in particular if the grid is somewhat
course and the objects of interest are optically thick.  Please consult Section
{\hyperref[\detokenize{imagesspectra:sec-second-order}]{\sphinxcrossref{\DUrole{std,std-ref}{Second order ray\sphinxhyphen{}tracing (Important information!)}}}} for more information.

\sphinxAtStartPar
\sphinxstyleemphasis{Important for polarized radiative transfer:} If you use polarized scattering,
then you may want to creat images with polarization information in them. You
have to tell RADMC\sphinxhyphen{}3D to do this by adding \sphinxcode{\sphinxupquote{stokes}} to the command line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{stokes}
\end{sphinxVerbatim}

\sphinxAtStartPar
The definitions of the Stokes parameters (orientation etc) can be found in
Section {\hyperref[\detokenize{dustradtrans:sec-definitions-stokes}]{\sphinxcrossref{\DUrole{std,std-ref}{Definitions and conventions for Stokes vectors}}}} and the format of \sphinxcode{\sphinxupquote{image.out}} in this
case can be found in Section {\hyperref[\detokenize{inputoutputfiles:sec-image-out}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT: image.out or image\_****.out}}}}.

\sphinxAtStartPar
Note: All the above commands call \sphinxcode{\sphinxupquote{radmc3d}} separately. If it needs to load a
large model (i.e. a model with many cells), then the loading may take a long
time. If you want to make many images in a row, this may take too much
time. Then it is better to call \sphinxcode{\sphinxupquote{radmc3d}} as a child process and pass the
above commands through the biway pipe (see Chapter \DUrole{xref,std,std-ref}{chap\sphinxhyphen{}child\sphinxhyphen{}mode}).


\section{Making multi\sphinxhyphen{}wavelength images}
\label{\detokenize{imagesspectra:making-multi-wavelength-images}}\label{\detokenize{imagesspectra:sec-multi-wavelength-images}}
\sphinxAtStartPar
Sometimes you want to have an image of an object at multiple wavelength
simultaneously. Rather than calling RADMC\sphinxhyphen{}3D separately to make an image for
each wavelength, you can make all images in one command. The only thing you have
to do is to tell RADMC\sphinxhyphen{}3D which wavelengths it should take. There are various
different ways you can tell RADMC\sphinxhyphen{}3D what wavelengths to take. This is described
in detail in Section {\hyperref[\detokenize{imagesspectra:sec-set-camera-frequencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}}}}. Here we will focus as an
example on just one of these methods. Type, for instance,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{lambdarange} \PYG{l+m+mf}{5.} \PYG{l+m+mf}{20.} \PYG{n}{nlam} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will create 10 images at once, all with the same viewing perspective, but
at 10 wavelengths regularly distributed between 5 \(\mu`m and 20
:math:\)mu\textasciigrave{}m.  All images are written into a single file, \sphinxcode{\sphinxupquote{image.out}} (See
Section {\hyperref[\detokenize{inputoutputfiles:sec-image-out}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT: image.out or image\_****.out}}}} for its format).

\sphinxAtStartPar
In Python you simply type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{radmc3dPy} \PYG{k+kn}{import} \PYG{n}{image}
\PYG{n}{a}\PYG{o}{=}\PYG{n}{image}\PYG{o}{.}\PYG{n}{readImage}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
and you will get all images at once. To plot one of them:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{image}\PYG{o}{.}\PYG{n}{plotImage}\PYG{p}{(}\PYG{n}{image}\PYG{o}{=}\PYG{n}{a}\PYG{p}{,}\PYG{n}{ifreq}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
which will plot image number 3 (out of images number 0 to 9). To find out which
wavelength this image is at:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{wav}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
which will return 7.9370053 in this example.

\sphinxAtStartPar
Note that all of the commands in Section {\hyperref[\detokenize{imagesspectra:sec-images}]{\sphinxcrossref{\DUrole{std,std-ref}{Basics of image making with RADMC\sphinxhyphen{}3D}}}} are of course also
applicable to multi\sphinxhyphen{}wavelength images, except for the \sphinxcode{\sphinxupquote{lambda}} keyword, as
this conflicts with the other method(s) of specifying the wavlengths of the
images. Now please turn to Section {\hyperref[\detokenize{imagesspectra:sec-set-camera-frequencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}}}} for more
information on how to specify the wavelengths for the multiple wavelength
images.


\section{Making spectra}
\label{\detokenize{imagesspectra:making-spectra}}\label{\detokenize{imagesspectra:sec-making-spectra}}
\sphinxAtStartPar
The standard way of making a spectrum with \sphinxcode{\sphinxupquote{radmc3d}} is in fact identical to
making 100x100 pixel images with flux conservation (i.e. recursive sub\sphinxhyphen{}pixeling,
see Section {\hyperref[\detokenize{imagesspectra:sec-image-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{The issue of flux conservation: recursive sub\sphinxhyphen{}pixeling}}}}) at multiple frequencies. You can ask
\sphinxcode{\sphinxupquote{radmc3d}} to make a \sphinxstyleemphasis{spectral energy distribution (SED)} with the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{sed} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will put the observer at inclination 45 degrees and angle phi 30 degrees,
and make a spectrum with wavelength points equal to those listed in the
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}} file.

\sphinxAtStartPar
The output will be a file called \sphinxcode{\sphinxupquote{spectrum.out}} (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-output-spectrum-out}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT: spectrum.out}}}}).

\sphinxAtStartPar
You can also make a spectrum on a set of wavelength points of your own
choice. There are multiple ways by which you can specify the set of
frequencies/wavelength points for which to make the spectrum: they are described
in Section {\hyperref[\detokenize{imagesspectra:sec-set-camera-frequencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}}}}. If you have made your selection in
such a way, you can make the spectrum at this wavelength grid by

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{spectrum} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{o}{\PYGZlt{}}\PYG{n}{COMMANDS} \PYG{n}{FOR} \PYG{n}{WAVELENGTH} \PYG{n}{SELECTION}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
where the last stuff is telling \sphinxcode{\sphinxupquote{radmc3d}} how to select the wavelengths
(Section {\hyperref[\detokenize{imagesspectra:sec-set-camera-frequencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}}}}). An example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{spectrum} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{lambdarange} \PYG{l+m+mf}{5.} \PYG{l+m+mf}{20.} \PYG{n}{nlam} \PYG{l+m+mi}{100}
\end{sphinxVerbatim}

\sphinxAtStartPar
will make a spectrum with a regular wavelength grid between 5 and 20
\(\mu\mathrm{m}\) and 100 wavelength points. But see Section
{\hyperref[\detokenize{imagesspectra:sec-set-camera-frequencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}}}} for more details and options.

\sphinxAtStartPar
The output file \sphinxcode{\sphinxupquote{spectrum.out}} will have the same format as for the \sphinxcode{\sphinxupquote{sed}}
command.

\sphinxAtStartPar
Making a spectrum can take RADMC\sphinxhyphen{}3D some time, especially in the default mode,
because it will do its best to shoot its rays to pick up all cells of the model
(see Section {\hyperref[\detokenize{imagesspectra:sec-recursive-subpixeling}]{\sphinxcrossref{\DUrole{std,std-ref}{The solution: recursive sub\sphinxhyphen{}pixeling}}}}). In particularly in spherical
coordinates RADMC\sphinxhyphen{}3D can be perhaps \sphinxstyleemphasis{too} conservative (and thus slow). For
spherical coordinates there are ways to tell RADMC\sphinxhyphen{}3D to be somewhat less
careful (and thereby faster): see Section {\hyperref[\detokenize{imagesspectra:sec-rec-subpixel-spher-coord}]{\sphinxcrossref{\DUrole{std,std-ref}{Recursive sub\sphinxhyphen{}pixeling in spherical coordinates}}}}.

\sphinxAtStartPar
Note that you can adjust the fine\sphinxhyphen{}ness of the images from which the spectrum is
calculated using \sphinxcode{\sphinxupquote{npix}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{sed} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{npix} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
What this does is use a 2x2 pixel image instead of a 100x100 pixel image as the
starting resolution. Of course, if it would really be just a 2x2 pixel image,
the flux would be entirely unreliable and useless. However, using the above
mentioned ‘sub\sphinxhyphen{}pixeling’ (see Section {\hyperref[\detokenize{imagesspectra:sec-recursive-subpixeling}]{\sphinxcrossref{\DUrole{std,std-ref}{The solution: recursive sub\sphinxhyphen{}pixeling}}}}) it will
automatically try to recursively refine these pixels until the required level of
refinement is reached. So under normal circumstances even npix=2 is enough, and
in earlier versions of RADMC\sphinxhyphen{}3D this 2x2 top\sphinxhyphen{}level image resolution was in fact
used as a starting point. But for safety reasons this has now been changed to
the standard 100x100 resolution which is also the default for normal images. If
100x100 is not enough, try e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{sed} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{npix} \PYG{l+m+mi}{400}
\end{sphinxVerbatim}

\sphinxAtStartPar
which may require some patience.


\subsection{What is ‘in the beam’ when the spectrum is made?}
\label{\detokenize{imagesspectra:what-is-in-the-beam-when-the-spectrum-is-made}}
\sphinxAtStartPar
As mentioned above, a spectrum is simply made by making a rectangular image at
all the wavelengths points, and integrating over these images. The resulting
fluxes at each wavelength point is then the spectral flux at that wavelength
point. This means that the integration area of flux for the spectrum is (a)
rectangular and (b) of the same size at all wavelengths.

\sphinxAtStartPar
So, what \sphinxstyleemphasis{is} the size of the image that is integrated over? The answer is: it
is the same size as the default size of an image. In fact, if you make a
spectrum with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{spectrum} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{lambdarange} \PYG{l+m+mf}{5.} \PYG{l+m+mf}{20.} \PYG{n}{nlam} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxAtStartPar
then this is the same as if you would type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{lambdarange} \PYG{l+m+mf}{5.} \PYG{l+m+mf}{20.} \PYG{n}{nlam} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxAtStartPar
and read in the file \sphinxcode{\sphinxupquote{image.out}} in into Python (see Section
{\hyperref[\detokenize{imagesspectra:sec-multi-wavelength-images}]{\sphinxcrossref{\DUrole{std,std-ref}{Making multi\sphinxhyphen{}wavelength images}}}}) or your favorite other data language, and
integrate the images to obtain fluxes. In other words: the command \sphinxcode{\sphinxupquote{spectrum}}
is effectively the same as the command \sphinxcode{\sphinxupquote{image}} but then instead of writing out
an \sphinxcode{\sphinxupquote{image.out}} file, it will integrate over all images and write a
\sphinxcode{\sphinxupquote{spectrum.out}} file.

\sphinxAtStartPar
If you want to have a quick look at the area over which the spectrum is to be
computed, but you don’t want to compute all the images, just type e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30}
\end{sphinxVerbatim}

\sphinxAtStartPar
then you see an image of your source at \(\lambda=10\mu\)m, and the
integration area is precisely this area \sphinxhyphen{} at all wavelengths. Like with the
images, you can specify your viewing area, and thus your integration area. For
instance, by typing

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{zoomau} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5} \PYG{l+m+mf}{0.5}
\end{sphinxVerbatim}

\sphinxAtStartPar
makes an image of your source at \(\lambda=10\mu\)m at inclination 45
degrees, and orientation 30 degrees, and zooms in at an are from \sphinxhyphen{}2 AU to \sphinxhyphen{}1 AU
in x\sphinxhyphen{}direction (in the image) and from \sphinxhyphen{}0.5 AU to 0.5 AU in y\sphinxhyphen{}direction (in the
image). To make an SED within the same integration area:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{sed} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{zoomau} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5} \PYG{l+m+mf}{0.5}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case we have an SED with a ‘beam size’ of 1 AU diameter, but keep in
mind that the ‘beam’ is square, not circular.


\subsection{Can one specify more realistic ‘beams’?}
\label{\detokenize{imagesspectra:can-one-specify-more-realistic-beams}}\label{\detokenize{imagesspectra:sec-aperture}}
\sphinxAtStartPar
Clearly, a wavelength\sphinxhyphen{}independent beam size is unrealistic, and also the square
beam is unrealistic. So is there a way to do this better? In reality one should
really know exactly how the object is observed and how the flux is measured. If
you use an interferometer, for instance, maybe your flux is meant to be the flux
in a single synthesized beam.  For a spectrum obtained with a slit, the precise
flux is dependent on the slit width: the wider the slit, the more signal you
pick up, but it is a signal from a larger area.

\sphinxAtStartPar
So if you really want to be sure that you know exactly what you are doing, then
the best method is to do this youself by hand. You make multi\sphinxhyphen{}wavelength images:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{lambdarange} \PYG{l+m+mf}{5.} \PYG{l+m+mf}{20.} \PYG{n}{nlam} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxAtStartPar
and integrate over the images in the way you think best mimics the actual
observing procedure. You can do so, for instance, in Python.  See Section
{\hyperref[\detokenize{imagesspectra:sec-multi-wavelength-images}]{\sphinxcrossref{\DUrole{std,std-ref}{Making multi\sphinxhyphen{}wavelength images}}}} for more information about multi\sphinxhyphen{}wavelength
images.

\sphinxAtStartPar
But to get some reasonable estimate of the effect of the wavelength\sphinxhyphen{}dependent
size and circular geometry of a ‘beam’, RADMC\sphinxhyphen{}3D allows you to make spectra with
a simplistic circular mask, the radius of which can be specified as a function
of wavelength in the file \sphinxcode{\sphinxupquote{aperture\_info.inp}} (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-aperture-info-file}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: aperture\_info.inp}}}}).  This file should contain a table of mask radii
at various wavelengths, and when making a spectrum with the command\sphinxhyphen{}line keyword
\sphinxcode{\sphinxupquote{useapert}} the mask radii will be found from this table by interpolation. In
other words: the wavelength points of the \sphinxcode{\sphinxupquote{aperture\_info.inp}} file do not have
to be the same as those used for the spectrum. But their range \sphinxstyleemphasis{must} be larger
or equal than the range of the wavelengths used for the spectrum, because
otherwise interpolation does not work. In the most extreme simplistic case the
\sphinxcode{\sphinxupquote{aperture\_info.inp}} file contains merely two values: one for a very short
wavelength (shorter than used in the spectrum) and one for a very long
wavelength (longer than used in the spectrum). The interpolation is then done
double\sphinxhyphen{}logarithmically, so that a powerlaw is used between sampling points. So
if you use a telescope with a given diameter for the entire range of the
spectrum, two sampling points would indeed suffice.

\sphinxAtStartPar
You can now make the spectrum with the aperture in the following way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{sed} \PYG{n}{useapert} \PYG{n}{dpc} \PYG{l+m+mi}{100}
\end{sphinxVerbatim}

\sphinxAtStartPar
The keyword \sphinxcode{\sphinxupquote{dpc 100}} is the distance of the observer in units of
parsec, here assumed to be 100. This distance is necessary
because the aperture information is given in arcseconds, and the distance is
used to convert this is image size.

\sphinxAtStartPar
\sphinxstyleemphasis{Important note:} Although you specify the distance of the observer
here, the \sphinxcode{\sphinxupquote{spectrum.out}} file that is produced is still normalized
to a distance of 1 parsec.

\sphinxAtStartPar
Note also that in the above example you can add any other keywords as shown
in the examples before, as long as you add the \sphinxcode{\sphinxupquote{useapert}} keyword
and specify \sphinxcode{\sphinxupquote{dpc}}.

\sphinxAtStartPar
A final note: the default behavior of RADMC\sphinxhyphen{}3D is to use the square field
approach described before. You can explicitly turn off the use of apertures
(which may be useful in the child mode of RADMC\sphinxhyphen{}3D) with the keyword
\sphinxcode{\sphinxupquote{noapert}}, but normally this is not necessary as it is the default.


\section{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}
\label{\detokenize{imagesspectra:specifying-custom-made-sets-of-wavelength-points-for-the-camera}}\label{\detokenize{imagesspectra:sec-set-camera-frequencies}}
\sphinxAtStartPar
If you want to make a spectrum at a special grid of wavelengths/frequencies,
with the \sphinxcode{\sphinxupquote{spectrum}} command (see Section {\hyperref[\detokenize{imagesspectra:sec-making-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making spectra}}}}), you must
tell \sphinxcode{\sphinxupquote{radmc3d}} which wavelengths you want to use. Here is described how to do
this in various ways.


\subsection{Using \sphinxstyleliteralintitle{\sphinxupquote{lambdarange}} and (optionally) \sphinxstyleliteralintitle{\sphinxupquote{nlam}}}
\label{\detokenize{imagesspectra:using-lambdarange-and-optionally-nlam}}
\sphinxAtStartPar
The simplest way to choose a set of wavelength for a spectrum is with the
\sphinxcode{\sphinxupquote{lambdarange}} and (optionally) \sphinxcode{\sphinxupquote{nlam}} command line options. Here is how to
do this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{spectrum} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{lambdarange} \PYG{l+m+mf}{5.} \PYG{l+m+mf}{20.}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will make a spectrum between 5 and 20 \(\mu`m. It will use by default
100 wavelength points logarithmically spaced between 5 and 20 :math:\)mu\textasciigrave{}m. You
can change the number of wavelength points as well:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{spectrum} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{lambdarange} \PYG{l+m+mf}{5.} \PYG{l+m+mf}{20.} \PYG{n}{nlam} \PYG{l+m+mi}{1000}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will do the same, but creates a spectrum of 1000 wavelength points.

\sphinxAtStartPar
You can use the \sphinxcode{\sphinxupquote{lambdarange}} and \sphinxcode{\sphinxupquote{nlam}} options also for multi\sphinxhyphen{}wavelength
images:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{lambdarange} \PYG{l+m+mf}{5.} \PYG{l+m+mf}{20.} \PYG{n}{nlam} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxAtStartPar
but it is wise to choose \sphinxcode{\sphinxupquote{nlam}} small, because otherwise the output file,
containing all the images, would become too large.


\subsection{Using \sphinxstyleliteralintitle{\sphinxupquote{allwl}}}
\label{\detokenize{imagesspectra:using-allwl}}
\sphinxAtStartPar
You can also tell RADMC\sphinxhyphen{}3D to simply make an image at all of the wavelengths in
the \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{allwl}
\end{sphinxVerbatim}

\sphinxAtStartPar
The keyword \sphinxcode{\sphinxupquote{allwl}} stands for ‘all wavelengths’.


\subsection{Using \sphinxstyleliteralintitle{\sphinxupquote{loadcolor}}}
\label{\detokenize{imagesspectra:using-loadcolor}}
\sphinxAtStartPar
By giving the command \sphinxcode{\sphinxupquote{loadcolor}} on the command line, \sphinxcode{\sphinxupquote{radmc3d}} will search
for the file \sphinxcode{\sphinxupquote{color\_inus.inp}}. This file contains integers selecting the
wavelengths from the file \sphinxcode{\sphinxupquote{wavelength\_micron.inp}}. The file is described in
Section {\hyperref[\detokenize{inputoutputfiles:sec-color-inus}]{\sphinxcrossref{\DUrole{std,std-ref}{The color\_inus.inp file (required with comm\sphinxhyphen{}line option ‘loadcolor’)}}}}.


\subsection{Using \sphinxstyleliteralintitle{\sphinxupquote{loadlambda}}}
\label{\detokenize{imagesspectra:using-loadlambda}}
\sphinxAtStartPar
By giving the command \sphinxcode{\sphinxupquote{loadlambda}} on the command line, \sphinxcode{\sphinxupquote{radmc3d}} will
search for the file \sphinxcode{\sphinxupquote{camera\_wavelength\_micron.inp}}. This file contains a list
of wavelengths in micron which constitute the grid in wavelength. This file is
described in Section {\hyperref[\detokenize{inputoutputfiles:sec-camera-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (optional): camera\_wavelength\_micron.inp}}}}.


\subsection{Using \sphinxstyleliteralintitle{\sphinxupquote{iline}}, \sphinxstyleliteralintitle{\sphinxupquote{imolspec}} etc (for when lines are included)}
\label{\detokenize{imagesspectra:using-iline-imolspec-etc-for-when-lines-are-included}}
\sphinxAtStartPar
By adding for instance \sphinxcode{\sphinxupquote{iline 3}} to the command line you specify a window
around line number 3 (by default of molecule 1). By also specifying for instance
\sphinxcode{\sphinxupquote{imolspec 2}} you select line 3 of molecule 2. By adding \sphinxcode{\sphinxupquote{widthkms 3}} you
specify how wide the window around the line should be (3 km/s in this
example). With \sphinxcode{\sphinxupquote{vkms 2}} you set the window offset from line center by 2 km/s
in this example. By adding \sphinxcode{\sphinxupquote{linenlam 30}} you set the number of wavelength
points for this spectrum to be 30 in this example. So a complete (though
different) example is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{spectrum} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{iline} \PYG{l+m+mi}{2} \PYG{n}{imolspec} \PYG{l+m+mi}{1} \PYG{n}{widthkms} \PYG{l+m+mf}{6.0} \PYG{n}{vkms} \PYG{l+m+mf}{0.0} \PYG{n}{linenlam} \PYG{l+m+mi}{40}
\end{sphinxVerbatim}


\section{Heads\sphinxhyphen{}up: In reality wavelength are actually wavelength bands}
\label{\detokenize{imagesspectra:heads-up-in-reality-wavelength-are-actually-wavelength-bands}}\label{\detokenize{imagesspectra:sec-wavelength-bands}}
\sphinxAtStartPar
In a radiative transfer program like \sphinxcode{\sphinxupquote{RADMC\sphinxhyphen{}3D}} the images or
spectral fluxes are calculated at \sphinxstyleemphasis{exact} wavelengths. This would
correspond to making observations with infinitely narrow filters, i.e.
filters with \(\Delta\lambda=0\). This is not how real observations work.
In reality each wavelength channel has a finite width \(\Delta\lambda\) and
the measured flux (or image intensity) is an average over this range. To
be even more precise, each wavelength channel \(i\) has some profile
\(\Phi_i(\lambda)\) defined such that
\begin{equation*}
\begin{split}\int_0^{\infty}\Phi_i(\lambda)d\lambda=1\end{split}
\end{equation*}
\sphinxAtStartPar
For wide filters such as the standard photometric systems (e.g. UVBRI in
the optical and JHK in the near infrared) these profiles span ranges with a
width of the order of \(\lambda\) itself. Many instruments have their own
set of filters. Usually one can download these profiles as digital tables.
It can, under some circumstances, be important to include a treatment of
these profiles in the model predictions. As an example take the N band. This
is a band that includes the 10 \(\mu`m silicate feature, which is a strong
function of wavelength *within* the N band. If you have a wide filter in
the N band, then one cannot simply calculate the model spectrum in one single
wavelength. Instead one has to calculate it for a properly finely sampled
set of wavelengths :math:\)lambda\_i\textasciigrave{} for \(1\le i\le n\), where \(n\) is the number of
wavelength samples, and then compute the filter\sphinxhyphen{}averaged flux with:
\begin{equation*}
\begin{split}F_{band} = \int_0^{\infty}\Phi_i(\lambda)F(\lambda)d\lambda
= \sum_{i=1}^{n} \Phi_i F_i \delta\lambda\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\delta\lambda\) is the wavelength sampling spacing used. The same is
true for image intensities. \sphinxcode{\sphinxupquote{RADMC\sphinxhyphen{}3D}} will not do this
automatically. You have to tell it the \(\lambda_i\) sampling points, let it
make the images or fluxes, and you will then have to perform this sum
yourself. \sphinxstyleemphasis{Note that this will not always be necessary!} In many (most?)
cases the dust continuum is not expected to change so dramatically over the
width of the filter that such degree of accuracy is required. So you are
advised to think carefully: ‘do I need to take care of this or can I make
do with a single wavelength sample for each filter?’. If the former, then
do the hard work. If the latter: then you can save time.


\subsection{Using channel\sphinxhyphen{}integrated intensities to improve line channel map quality}
\label{\detokenize{imagesspectra:using-channel-integrated-intensities-to-improve-line-channel-map-quality}}\label{\detokenize{imagesspectra:sec-wavelength-bands-subsec}}
\sphinxAtStartPar
When you make line channel maps you may face a problem that is somehow
related to the above issue of single\sphinxhyphen{}\(\lambda\)\sphinxhyphen{}sampling versus
filter\sphinxhyphen{}integrated fluxes/intensities. If the model contains gas motion, then
doppler shift will shift the line profile around. In your channel map you
may see regions devoid of emission because the lines have doppler shifted
out of the channel you are looking at. However, as described in Section
{\hyperref[\detokenize{lineradtrans:sec-lines-pitfalls}]{\sphinxcrossref{\DUrole{std,std-ref}{What can go wrong with line transfer?}}}}, if the intrinsic line width of the gas is smaller
than the cell\sphinxhyphen{}to\sphinxhyphen{}cell velocity differences, then the channel images may look
very distorted (they will look ‘blocky’, as if there is a bug in the
code). Please refer to Section {\hyperref[\detokenize{lineradtrans:sec-lines-pitfalls}]{\sphinxcrossref{\DUrole{std,std-ref}{What can go wrong with line transfer?}}}} for more details and
updates on this important, but difficult issue. It is not a bug, but a
general problem with ray\sphinxhyphen{}tracing of gas lines in models with large velocity
gradients.

\sphinxAtStartPar
As one of the \(\beta\)\sphinxhyphen{}testers of \sphinxcode{\sphinxupquote{RADMC\sphinxhyphen{}3D}}, Rahul Shetty, has
found out, this problem can often be alleviated a lot if you treat the
finite width of a channel. By taking multiple \(\lambda_i\) points in each
wavelength channel (i.e. multiple \(v_i\) points in each velocity channel) and
simply averaging the intensities (i.e. assuming a perfectly square \(\Phi\)
function) and taking the width of the channels to be not smaller (preferably
substantially wider) than the cell\sphinxhyphen{}to\sphinxhyphen{}cell velocity differences, this
‘blocky noise’ sometimes smoothes out well. However, it is always safer to
use the ‘doppler catching’ mode (see Section {\hyperref[\detokenize{lineradtrans:sec-doppler-catching}]{\sphinxcrossref{\DUrole{std,std-ref}{Preventing doppler jumps: The ‘doppler catching method’}}}})
to automatically prevent such problems (though this mode requires more
computer memory).


\section{The issue of flux conservation: recursive sub\sphinxhyphen{}pixeling}
\label{\detokenize{imagesspectra:the-issue-of-flux-conservation-recursive-sub-pixeling}}\label{\detokenize{imagesspectra:sec-image-refinement}}

\subsection{The problem of flux conservation in images}
\label{\detokenize{imagesspectra:the-problem-of-flux-conservation-in-images}}
\sphinxAtStartPar
If an image of nx\(\times\)ny pixels is made simply by ray\sphinxhyphen{}tracing one
single ray for each pixel, then there is the grave danger that certain regions
with high refinement (for instance with AMR in cartesian coordinates, or near
the center of the coordinate system for spherical coordinates) are not properly
‘picked up’. An example: suppose we start with a circumstellar disk ranging from
0.1 AU out to 1000 AU. Most of the near infrared flux comes from the very inner
regions near 0.1 AU. If an image of the disk is made with 100x100 pixels and
image half\sphinxhyphen{}size of 1000 AU, then none of the pixels in fact pass through these
very bright inner regions, for lack of spatial resolution.  The problem is then
that the image, when integrated over the entire image, does not have the correct
flux. What \sphinxstyleemphasis{should} be is that the centermost pixels contain the flux from this
innermost region, even if these pixels are much larger than the entire bright
region. In other words, the intensity of these pixels must represent the average
intensity, averaged over the entire pixel. Strictly speaking one should trace an
infinite continuous 2\sphinxhyphen{}D series of rays covering the entire pixel and then
average over all these rays; but this is of course not possible. In practice we
should find a way to estimate the average intensity with only a finite number of
rays.


\subsection{The solution: recursive sub\sphinxhyphen{}pixeling}
\label{\detokenize{imagesspectra:the-solution-recursive-sub-pixeling}}\label{\detokenize{imagesspectra:sec-recursive-subpixeling}}
\sphinxAtStartPar
In RADMC\sphinxhyphen{}3D what we do is to use some kind of ‘adaptive grid refinement’ of the
pixels of the image. For each pixel in the image the intensity is computed
through a call to a subroutine called \sphinxcode{\sphinxupquote{camera\_compute\_one\_pixel()}}. In this
subroutine a ray\sphinxhyphen{}tracing is performed for a ray that ends right in the middle of
our pixel. During the ray\sphinxhyphen{}tracing, however, we check if we pass regions in the
model grid that have grid cells with sizes \(S\) that are smaller than the
pixel size divided by some factor \(f_{\mathrm{ref}}\) (where pixel size is,
like the model grid size S itself, measured in centimeters. If this is found
\sphinxstyleemphasis{not} to be true, then the pixel size was apparently ok, and the intensity
resulting from the ray\sphinxhyphen{}tracing is now returned as the final intensity of this
pixel. If, however, this condition \sphinxstyleemphasis{is} found to be true, then the result of
this ray is rejected, and instead 2x2 sub\sphinxhyphen{}pixels are computed by calling the
\sphinxcode{\sphinxupquote{camera\_compute\_one\_pixel()}} subroutine recursively. We thus receive the
intensity of each of these four sub\sphinxhyphen{}pixels, and we return the average of these 4
intensities.

\sphinxAtStartPar
Note, by the way, that each of these 2x2 subpixels may be split even further
into 2x2 sub\sphinxhyphen{}pixels etc until the desired resolution is reached, i.e. until
the condition that \(S\) is larger or equal to the pixel size divided by
\(f_{\mathrm{ref}}\) is met. This is illustrated in Fig.
\hyperref[\detokenize{imagesspectra:fig-recursive-subpixeling}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-recursive-subpixeling}}}. By this recursive calling, we always end up at
the top level with the average intesity of the entire top\sphinxhyphen{}level pixel.  This
method is very similar to quad\sphinxhyphen{}tree mesh refinement, but instead of
retaining and returning the entire complex mesh structure to the user, this
method only returns the final average intensity of each (by definition top
level) pixel in the image. So the recursive sub\sphinxhyphen{}pixeling technique described
here is all done internally in the RADMC\sphinxhyphen{}3D code, and the user will not
really notice anything except that this sub\sphinxhyphen{}pixeling can of course be
computationally more expensive than if such a method is not used.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Subpixeling}.pdf}
\caption{Pictographic representation of how the recursive sub\sphinxhyphen{}pixeling for images
works. Pixels are recursively split in 2x2 subpixels as far as needed
to resolve the 3\sphinxhyphen{}D grid structure of the model. But at the end, the
fluxes of all subpixels are summed up such that the resulting image
has a regular grid again.}\label{\detokenize{imagesspectra:id5}}\label{\detokenize{imagesspectra:fig-recursive-subpixeling}}\end{figure}

\sphinxAtStartPar
Note that the smaller we choose \(f_{\mathrm{ref}}\) the more accurate our
image becomes. In the \sphinxcode{\sphinxupquote{radmc3d.inp}} file the value of \(f_{\mathrm{ref}}\)
can be set by setting the variable \sphinxcode{\sphinxupquote{camera\_refine\_criterion}} to the
value you want \(f_{\mathrm{ref}}\) to be. Not setting this variable means
RADMC\sphinxhyphen{}3D will use the default value which is reasonable as a choice (default
is 1.0). The smaller you set \sphinxcode{\sphinxupquote{camera\_refine\_criterion}}, the
more accurate and reliable the results become (but the heavier the calculation
becomes, too).

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE:} The issue of recursive sub\sphinxhyphen{}pixeling becomes tricky when stars
are treated as spheres, i.e. non\sphinxhyphen{}point\sphinxhyphen{}like (see Section
{\hyperref[\detokenize{imagesspectra:sec-image-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{Stars in the images and spectra}}}} and Chapter {\hyperref[\detokenize{stars:chap-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{More information about the treatment of stars}}}}).

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE:} If you want to know, for a given image, how RADMC\sphinxhyphen{}3D subpixeled the
image, you can either set \sphinxcode{\sphinxupquote{camera\_diagnostics\_subpix=1}} in the \sphinxcode{\sphinxupquote{radmc3d.inp}}
file or add \sphinxcode{\sphinxupquote{diag\_subpix}} to the command line. This forces RADMC\sphinxhyphen{}3D to
write out a file called \sphinxcode{\sphinxupquote{subpixeling\_diagnostics.out}} which contains
four columns, for respectivly: \sphinxcode{\sphinxupquote{px,py,pdx,pdy}}, i.e. the pixel position
and its size. This allows the user to
find out if the recursive subpixeling went well or if certain areas were
over/under\sphinxhyphen{}resolved. This is really only meant as a diagnostic.


\subsection{A danger with recursive sub\sphinxhyphen{}pixeling}
\label{\detokenize{imagesspectra:a-danger-with-recursive-sub-pixeling}}
\sphinxAtStartPar
It is useful to keep in mind that for each pixel the recursive sub\sphinxhyphen{}pixeling
is triggered if the ray belonging to that pixel encounters a cell that is
smaller than the pixel size. This \sphinxstyleemphasis{normally} works well if
\(f_{\mathrm{ref}}\) is chosen small enough. But if there exist regions in the
model where one big non\sphinxhyphen{}refined cell lies adjacent to a cell that is
refined, say, 4 times (meaning the big cell has neighbors that are 16 times
smaller!), then if the ray of the pixel just happens to miss the small cells
and only passes the big cell, it won’t ‘notice’ that it may need to refine
to correctly capture the tiny neighboring cells accurarely.

\sphinxAtStartPar
Such a problem only happens if refinement levels jump by more than 1 between
adjacent cells. If so, then it may be important to make \(f_{\mathrm{ref}}\)
correspondingly smaller (by setting \sphinxcode{\sphinxupquote{camera\_refine\_criterion}} in
\sphinxcode{\sphinxupquote{radmc3d.inp}} to the desired value). A bit of experimentation may
be needed here.


\subsection{Recursive sub\sphinxhyphen{}pixeling in spherical coordinates}
\label{\detokenize{imagesspectra:recursive-sub-pixeling-in-spherical-coordinates}}\label{\detokenize{imagesspectra:sec-rec-subpixel-spher-coord}}
\sphinxAtStartPar
In spherical coordinates the recursive sub\sphinxhyphen{}pixeling has a few issues that
you may want to be aware of. First of all, in 1\sphinxhyphen{}D spherical coordinates each
cell is in fact a shell of a certain thickness. In 2\sphinxhyphen{}D spherical coordinates
cells are rings. In both cases the cells are not just local boxes, but have
2 or 1 (respectively) extended dimensions. RADMC\sphinxhyphen{}3D takes care to still
calculate properly how to define the recursive sub\sphinxhyphen{}pixeling scale. But
for rays that go through the central cavity of the coordinate
system there is no uniquely defined pixel resolution to take. The
global variable \sphinxcode{\sphinxupquote{camera\_spher\_cavity\_relres}} (with default
value 0.05) defines such a relative scale. You can change this value
in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file.

\sphinxAtStartPar
A second issue is when the user introduces extreme ‘separable refinement’
(see Section {\hyperref[\detokenize{gridding:sec-separable-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{Separable grid refinement in spherical coordinates (important!)}}}} and Figure
\hyperref[\detokenize{gridding:fig-spher-sep-ref-rays}]{Fig.\@ \ref{\detokenize{gridding:fig-spher-sep-ref-rays}}}) in the \(R\), \(\Theta\) or \(\Phi\)
coordinate. This may, for instance, be necessary near the inner edge of a
dusty disk model in order to keep the first cell optically thin. This may
lead, however, to extremely deep sub\sphinxhyphen{}pixeling for rays that skim the inner
edge of the grid. This leads to a huge slow\sphinxhyphen{}down of the ray\sphinxhyphen{}tracing process
although it is likely not to give much a different result. By default
RADMC\sphinxhyphen{}3D plays it safe. If you wish to prevent this excessive sub\sphinxhyphen{}pixeling
(at your own risk) then you can set the following variables in the
\sphinxcode{\sphinxupquote{radmc3d.inp}} file:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_min\_drr}} which sets a lower limit to the \(\Delta
R/R\) taken into account for the sub\sphinxhyphen{}pixeling (region ‘B’ in Figure
\hyperref[\detokenize{gridding:fig-spher-sep-ref-txt}]{Fig.\@ \ref{\detokenize{gridding:fig-spher-sep-ref-txt}}}). The default is 0.003. By setting this to
e.g. 0.03 you can already get a strong speed\sphinxhyphen{}up for models with strong
\(R\)\sphinxhyphen{}refinement.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_min\_dangle}} which sets a lower limit to
\(\Delta\Theta\) (region ‘C’ in Figure \hyperref[\detokenize{gridding:fig-spher-sep-ref-txt}]{Fig.\@ \ref{\detokenize{gridding:fig-spher-sep-ref-txt}}})
and/or \(\Delta\Phi\). The default is 0.05. By setting this to e.g. 0.1 you
can already get some speed\sphinxhyphen{}up for models with e.g. strong
\(\Theta\)\sphinxhyphen{}refinement.

\end{itemize}

\sphinxAtStartPar
It is important to keep in mind that the smaller you make this number, the
more accurate and reliable the results. It may be prudent to experiment with
smaller values of \sphinxcode{\sphinxupquote{camera\_min\_drr}} for models with extremely
optically thick inner edges, e.g. a protoplanetary disk with an abrupt
inner edge and a high dust surface density. For a disk model with a very
thin vertical extent it will be important to choose small values of
\sphinxcode{\sphinxupquote{camera\_min\_dangle}}, perhaps even smaller than the default
value.

\sphinxAtStartPar
\sphinxstyleemphasis{For your convenience:} Because it can be sometimes annoying to always have to
play with the \sphinxcode{\sphinxupquote{camera\_min\_drr}}, \sphinxcode{\sphinxupquote{camera\_min\_dangle}} and
\sphinxcode{\sphinxupquote{camera\_spher\_cavity\_relres}} values, and since it is usually (!) not really
necessary to have such extremely careful subpixeling, RADMC\sphinxhyphen{}3D now has a new
command line option called \sphinxcode{\sphinxupquote{sloppy}}. This command\sphinxhyphen{}line option will set:
\sphinxcode{\sphinxupquote{camera\_min\_drr=0.1}}, \sphinxcode{\sphinxupquote{camera\_min\_dangle=0.1}} and
\sphinxcode{\sphinxupquote{camera\_spher\_cavity\_relres=0.1}}. So if you have an image like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{sloppy}
\end{sphinxVerbatim}

\sphinxAtStartPar
then it will make the image with moderate, but not excessive subpixeling.
This may, under some circumstances, speed up the image\sphinxhyphen{}making in spherical
coordinates by a large factor. Similar for making spectra. For instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{sed} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{sloppy}
\end{sphinxVerbatim}

\sphinxAtStartPar
can be, under some circumstances, very much faster than without the sloppy
option.

\sphinxAtStartPar
Note,however, that using the \sphinxcode{\sphinxupquote{sloppy}} option and/or setting the values of
\sphinxcode{\sphinxupquote{camera\_min\_drr}}, \sphinxcode{\sphinxupquote{camera\_min\_dangle}} and \sphinxcode{\sphinxupquote{camera\_spher\_cavity\_relres}} in
the \sphinxcode{\sphinxupquote{radmc3d.inp}} file by hand, \{bf is all at your own risk!\} It is always
prudent to check your results, now and then, against a non\sphinxhyphen{}sloppy calculation.


\subsection{How can I find out which pixels RADMC\sphinxhyphen{}3D is recursively refining?}
\label{\detokenize{imagesspectra:how-can-i-find-out-which-pixels-radmc-3d-is-recursively-refining}}
\sphinxAtStartPar
Sometimes you notice that the rendering of an image or spectrum takes much
more time than you expected. When recursive sub\sphinxhyphen{}pixeling is used for
imaging, RADMC\sphinxhyphen{}3D will give diagnostic information about how many more
pixels it has rendered than the original image resolution. This factor
can give some insight if extreme amount of sub\sphinxhyphen{}pixeling refinement has
been used. But it does not say where in the image this occurs. If you want
to see exactly which pixels and subpixels RADMC\sphinxhyphen{}3D has rendered for some
image, you can use the following command\sphinxhyphen{}line option:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{diag\PYGZus{}subpix}
\end{sphinxVerbatim}

\sphinxAtStartPar
This \sphinxcode{\sphinxupquote{diag\_subpix}} option will tell RADMC\sphinxhyphen{}3D to write a
file called \sphinxcode{\sphinxupquote{subpixeling\_diagnostics.out}} which contains four
columns: One for the x\sphinxhyphen{}coordinate of the (sub\sphinxhyphen{})pixel, one for the
y\sphinxhyphen{}coordinate of the (sub\sphinxhyphen{})pixel, one for the x\sphinxhyphen{}width of the (sub\sphinxhyphen{})pixel
and a final one for the y\sphinxhyphen{}width of the (sub\sphinxhyphen{})pixel. In Python you can
then use, for instance, the Numpy \sphinxcode{\sphinxupquote{loadtxt}} method to
read these columns.

\sphinxAtStartPar
If this diagnostic shows that the subpixeling is excessive (which can
particularly happen in spherical coordinates) then you might want to
read Section {\hyperref[\detokenize{imagesspectra:sec-rec-subpixel-spher-coord}]{\sphinxcrossref{\DUrole{std,std-ref}{Recursive sub\sphinxhyphen{}pixeling in spherical coordinates}}}}.


\subsection{Alternative to recursive sub\sphinxhyphen{}pixeling}
\label{\detokenize{imagesspectra:alternative-to-recursive-sub-pixeling}}
\sphinxAtStartPar
As an alternative to using this recursive sub\sphinxhyphen{}pixeling technique to ensure
flux conservation for images, one can simply enhance the spatial resolution
of the image, for instance

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{npix} \PYG{l+m+mi}{400}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or even 800 or so. This has the clear advantage that the user gets the complete
information of the details in the image (while in the recursive sub\sphinxhyphen{}pixeling
technique only the averages are retained). The clear disadvantages are that
one may need rediculously high\sphinxhyphen{}resolution images (i.e. large data sets) to
resolve all the details and one may waste a lot of time rendering parts of
the image which do not need that resolution. The latter is typically an
issue when images are rendered from models that use AMR techniques.


\section{Stars in the images and spectra}
\label{\detokenize{imagesspectra:stars-in-the-images-and-spectra}}\label{\detokenize{imagesspectra:sec-image-stars}}
\sphinxAtStartPar
Per default, stars are still treated as point sources. That means that none of
the rays of an image can be intercepted by a star. Starlight is included in each
image as a post\sphinxhyphen{}processing step. First the image is rendered without the stars
(though with of course all the emission of dust, lines etc \sphinxstyleemphasis{induced} by the
stars) and then for each star a ray tracing is done from the star to the
observer (where only extinction is taken into account, because the emission is
already taken care of) and the flux is then added to the image at the correct
position. You can switch off the inclusion of the stars in the images or spectra
with the \sphinxcode{\sphinxupquote{nostar}} command line option.

\sphinxAtStartPar
However, as of version 0.17, stars can also be treated as the finite\sphinxhyphen{}size
spheres they are. This is done with setting \sphinxcode{\sphinxupquote{istar\_sphere = 1}} in
\sphinxcode{\sphinxupquote{radmc3d.inp}}. However, this mode can slow down the code a bit or
even substantially. And it may still be partly under development, so the
code may stop if it is required to handle a situation it cannot handle yet.
See Chapter {\hyperref[\detokenize{stars:chap-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{More information about the treatment of stars}}}} for details.


\section{Second order ray\sphinxhyphen{}tracing (Important information!)}
\label{\detokenize{imagesspectra:second-order-ray-tracing-important-information}}\label{\detokenize{imagesspectra:sec-second-order}}
\sphinxAtStartPar
Ideally we would like to assure that the model grid is sufficiently finely
spaced everywhere. But in many cases of interest one does not have this
luxury. One must live with the fact that, for memory and/or computing time
reasons, the grid is perhaps a bit coarser than would be ideal. In such a
case it becomes important to consider the ‘order’ of integration of the
transfer equation. By default, for images and spectra, RADMC\sphinxhyphen{}3D uses first
order integration: The source term and the opacity in each cell are assumed
to be constant over the cell. This is illustrated in
Fig. \hyperref[\detokenize{imagesspectra:fig-cellcenter}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-cellcenter}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{cellcenter}.pdf}
\caption{Pictographic representation of the \sphinxstyleemphasis{first order} integration of the transfer
equation along a ray (red line with arrow head) through an AMR grid (black
lines).  The grid cuts the ray into ray segments A, B, C and D. At the bottom
it is shown how the integrands are assumed to be along these four segments.
The emissivity function \(j_\nu\) and extinction function
\(\alpha_\nu\) are constant within each cell and thus constant along each
ray segment.}\label{\detokenize{imagesspectra:id6}}\label{\detokenize{imagesspectra:fig-cellcenter}}\end{figure}

\sphinxAtStartPar
The integration over each cell proceeds according to the following formula:
\begin{equation*}
\begin{split}I_{\mathrm{result}} = I_{\mathrm{start}}e^{-\tau} + (1-e^{-\tau})S\end{split}
\end{equation*}
\sphinxAtStartPar
where \(S=j/\alpha\) is the source function, assumed constant throughout the
cell, \(\tau=\alpha\,\Delta s\) is the optical depth along the path that the
ray makes through the cell, and \(I_{\mathrm{start}}\) is the intensity upon
entering the cell. This is the default used by RADMC\sphinxhyphen{}3D because the Monte
Carlo methods also treat cells as having constant properties over each
cell. This type of simple integration is therefore the closest to how the
Monte Carlo methods (thermal MC, scattering MC and mono MC) ‘see’ the
grid. However, with first order integration the images look somewhat
‘blocky’: you can literally see the block structure of the grid cells in
the image, especially if you make images at angles aligned with the
grid. For objects with high optical depths you may even see grid patterns in
the images.

\sphinxAtStartPar
RADMC\sphinxhyphen{}3D can also use second order integration for its images and spectra.
This is illustrated in Fig. \hyperref[\detokenize{imagesspectra:fig-cellcorner}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-cellcorner}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{cellcorner}.pdf}
\caption{Pictographic representation of the \sphinxstyleemphasis{second order} integration of the transfer
equation along a ray (red line with arrow head) through an AMR grid (black
lines). The grid cuts the ray into ray segments A, B, C and D. At the bottom
it is shown how the integrands are assumed to be along these four segments.
The emissivity function \(j_\nu\) and extinction function
\(\alpha_\nu\) are given at the cell corners (solid blue circles), and
linearly interpolated from the cell corners to the locations where the ray
crosses the cell walls (open blue circles).  Then, along each ray segment the
emissivity and extinction functions are assumed to be linear functions, so
that the integration result is quadratic.}\label{\detokenize{imagesspectra:id7}}\label{\detokenize{imagesspectra:fig-cellcorner}}\end{figure}

\sphinxAtStartPar
This is done with a simple \sphinxcode{\sphinxupquote{secondorder}} option added on the
command line, for instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{secondorder}
\end{sphinxVerbatim}

\sphinxAtStartPar
The integration now follows the formula (Olson et al. 1986):
\begin{equation*}
\begin{split}I_{\mathrm{result}} = I_{\mathrm{start}}e^{-\tau} + (1-e^{-\tau}-\beta) S_{\mathrm{start}}
+ \beta S_{\mathrm{end}}\end{split}
\end{equation*}
\sphinxAtStartPar
with
\begin{equation*}
\begin{split}\beta = \frac{\tau-1+e^{-\tau}}{\tau}\end{split}
\end{equation*}
\sphinxAtStartPar
and
\begin{equation*}
\begin{split}\tau = \frac{\alpha_{\mathrm{start}}+\alpha_{\mathrm{end}}}{2}\Delta s\end{split}
\end{equation*}
\sphinxAtStartPar
For \(\tau\rightarrow 0\) we have the limit \(\beta\rightarrow \tau/2\),
while for \(\tau\rightarrow \infty\) we have the limit
\(\beta\rightarrow 1\).

\sphinxAtStartPar
The values of \(\alpha\), \(S\) etc., at the ‘start’ position are
obtained at the cell interface where the ray enters the cell. The values at the
‘end’ position are obtained at the cell interface where the ray leaves the cell.
The above formulas represent the exact solution of the transfer equation along
this ray\sphinxhyphen{}section if we assume that all variables are linear functions between
the ‘start’ and ‘end’ positions.

\sphinxAtStartPar
The next question is: How do we determine the physical variables at the
cell interfaces (‘start’ and ‘end’)? After all, initially all variables
are stored for each cell, not for each cell interface or cell corner. The
way that RADMC\sphinxhyphen{}3D does this is:
\begin{itemize}
\item {} 
\sphinxAtStartPar
First create a ‘grid of cell corners’, which we call the \sphinxstyleemphasis{vertex
grid} (see the solid blue dots in
Fig. \hyperref[\detokenize{imagesspectra:fig-cellcorner}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-cellcorner}}}). The cell grid already
implicitly defines the locations of all the cell corners, but these
corners are, by default, not explicitly listed in computer memory. When
the \sphinxcode{\sphinxupquote{secondorder}} option is given, however, RADMC\sphinxhyphen{}3D will
explicitly find all cell corners and assign an identity (a unique integer
number) to each one of them. NOTE: Setting up this vertex grid costs
computer memory!

\item {} 
\sphinxAtStartPar
At each vertex (cell corner) the physical variables of the (up to) 8
cells touching the vertex are averaged with equal weight for each cell.
This now maps the physical variables from the cells to the vertices.

\item {} 
\sphinxAtStartPar
Whenever a ray passes through a cell wall, the physical variables of
the 4 vertices of the cell wall are interpolated bilinearly onto the point
where the ray passes through the cell wall (see the open blue circles in
Fig. \hyperref[\detokenize{imagesspectra:fig-cellcorner}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-cellcorner}}}). This gives the values at the
‘start’ or ‘end’ points.

\item {} 
\sphinxAtStartPar
Since the current ‘end’ point will be the ‘start’ point for the
next ray segment, the physical variables need only be obtained once per
cell wall, as they can be recycled for the next ray segment. Each set of
physical variables will thus be used twice: once for the ‘end’ and once
for the ‘start’ of a ray segment (except of course at the very beginning
and very end of the ray).

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{simple_4_1st}.pdf}
\caption{First\sphinxhyphen{}order integration of transfer equation in ray\sphinxhyphen{}tracing
seen at inclination 4 degrees.}\label{\detokenize{imagesspectra:id8}}\label{\detokenize{imagesspectra:fig-effect-of-second-order-integration-4-1}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{simple_60_1st}.pdf}
\caption{First\sphinxhyphen{}order integration of transfer equation in ray\sphinxhyphen{}tracing
seen at inclination 60 degrees.}\label{\detokenize{imagesspectra:id9}}\label{\detokenize{imagesspectra:fig-effect-of-second-order-integration-60-1}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{simple_4_2nd}.pdf}
\caption{Second\sphinxhyphen{}order integration of transfer equation in ray\sphinxhyphen{}tracing
seen at inclination 4 degrees.}\label{\detokenize{imagesspectra:id10}}\label{\detokenize{imagesspectra:fig-effect-of-second-order-integration-4-2}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{simple_60_2nd}.pdf}
\caption{Second\sphinxhyphen{}order integration of transfer equation in ray\sphinxhyphen{}tracing
seen at inclination 60 degrees.}\label{\detokenize{imagesspectra:id11}}\label{\detokenize{imagesspectra:fig-effect-of-second-order-integration-60-2}}\end{figure}

\sphinxAtStartPar
If you compare the images or spectra obtained with first order integration
(default, see Figs. \hyperref[\detokenize{imagesspectra:fig-effect-of-second-order-integration-4-2}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-effect-of-second-order-integration-4-2}}} and
\hyperref[\detokenize{imagesspectra:fig-effect-of-second-order-integration-60-2}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-effect-of-second-order-integration-60-2}}}) or second order integration
(see Figs. \hyperref[\detokenize{imagesspectra:fig-effect-of-second-order-integration-4-2}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-effect-of-second-order-integration-4-2}}} and
\hyperref[\detokenize{imagesspectra:fig-effect-of-second-order-integration-60-2}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-effect-of-second-order-integration-60-2}}}) you see that with the first
order method you still see the cell structure of the grid very much.  Also
numerical noise in the temperature due to the Monte Carlo statistics is much
more prominent in the first order method. The second order method makes much
smoother results.

\sphinxAtStartPar
For line transfer the second order mode can be even improved with the
‘doppler catching method’, see Section {\hyperref[\detokenize{lineradtrans:sec-doppler-catching}]{\sphinxcrossref{\DUrole{std,std-ref}{Preventing doppler jumps: The ‘doppler catching method’}}}}.

\sphinxAtStartPar
\sphinxstyleemphasis{WARNING:} Second order integration for the images and spectra from dust
continuum emission can in some cases lead to overestimation of the fluxes.
This is because the dust temperature calculated using the thermal Monte
Carlo algorithm assumes the temperature to be constant over each cell. The
second order integration for the images and spectra will, however, smear the
sources a bit out. This then leads to ‘leaking’ of emissivity from
optically thick cells into optically thin cells. These optically thin cells
can then become too bright.


\subsection{Second order integration in spherical coordinates: a subtle issue}
\label{\detokenize{imagesspectra:second-order-integration-in-spherical-coordinates-a-subtle-issue}}\label{\detokenize{imagesspectra:sec-secord-spher}}
\sphinxAtStartPar
The second order integration (as well as the doppler\sphinxhyphen{}catching method, see
Section {\hyperref[\detokenize{lineradtrans:sec-doppler-catching}]{\sphinxcrossref{\DUrole{std,std-ref}{Preventing doppler jumps: The ‘doppler catching method’}}}}) work in cartesian coordinates as well as
in spherical coordinates. In spherical coordinates in 1\sphinxhyphen{}D (spherical
symmetry) or 2\sphinxhyphen{}D (axial symmetry) there is, however, a very subtle issue
that can lead to inaccuracies, in particular with line transfer. The problem
arises in the cell where a ray reaches its closest approach to the origin of
the coordinate system (or closest approach to the symmetry axis). There the
ray segment can become fairly long, and its angle with respect to the
symmetry axis and/or the origin can drastically change within this single
ray\sphinxhyphen{}segment. This can sometimes lead to inaccuracies.

\sphinxAtStartPar
As of version 0.41 of \sphinxcode{\sphinxupquote{RADMC\sphinxhyphen{}3D}} a new global variable is
introduced, \sphinxcode{\sphinxupquote{camera\_maxdphi}}, which has as default the value 0.1,
but which can be set to another value in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file.
It sets the maximum angle (in radian) which a ray segment in spherical
coordinates is allowed to span with respect to the origin of the coordinate
system. If a ray segment spans an angle larger than that, the ray\sphinxhyphen{}segment
is cut into smaller segments. This means that in that cell the ray will
consist of more than one segment.

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{camera\_maxdphi=0}} this segment cutting is switched off (for
backward compatibility to earlier versions of \sphinxcode{\sphinxupquote{RADMC\sphinxhyphen{}3d}}).


\section{Circular images}
\label{\detokenize{imagesspectra:circular-images}}\label{\detokenize{imagesspectra:sec-circularimages}}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D offers (optionally!) an alternative to the usual x\sphinxhyphen{}y rectangular pixel
arrangement of images: \sphinxstyleemphasis{circular images}. Here the pixels are not arranged in
rows that are vertically stacked \((x,y)\), but in concentric circles
\((r,\phi)\). Such a pixel arrangement is, of course, radically different
from what we usually consider “an image”, and it is therefore not possible to
view such an image with the usual image viewing methods (such as Python’s
\sphinxcode{\sphinxupquote{plt.imshow()}}). Or more precisely: if you would use \sphinxcode{\sphinxupquote{plt.imshow()}}
on a circular image you would see something that you would not recognize
as the image it should represent.

\sphinxAtStartPar
So what is the purpose? It is useful for models created on a spherical
coordinate system. Such models can have structure at a huge range of scales,
from very tiny (at the small\sphinxhyphen{}end side of the radius coordinate \(r\))
to very large (at the large\sphinxhyphen{}end side of the radius coordinate \(r\)).
If you make a normal image, you have to pick the right “zoom factor”: are
you interested to see the outer regions or more interested in the inner
regions? If you choose a “zoomed out” image, you will under\sphinxhyphen{}resolve
the inner regions. If you choose a “zoomed in” image, you will not see
the outer regions (they are beyond the edge of the image). One solution
could be to choose a huge number of pixels, but that would create huge
image files.

\sphinxAtStartPar
Circular images solve this dilemma. By arranging the pixels not in \((x,y)\)
but instead of \((r,\phi)\), the \(r\) coordinate grid of the image will
automatically be adapted to the \(r\) coordinate grid of the spherical
coordinate system. If the latter is logarithmically spaced, so will the circular
image.

\sphinxAtStartPar
Here is how it works: Assuming you have a model in spherical coordinates,
you can create a circular image as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{n}{circ} \PYG{k}{lambda} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxAtStartPar
which creates a circular image at wavelength \(\lambda=10\mu m\).

\sphinxAtStartPar
Using \sphinxcode{\sphinxupquote{radmc3dPy}} you can read this image as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{radmc3dPy} \PYG{k+kn}{import} \PYG{n}{image}
\PYG{n}{im} \PYG{o}{=} \PYG{n}{image}\PYG{o}{.}\PYG{n}{readcircimage}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The data is now in \sphinxcode{\sphinxupquote{im.image}}. A radial plot of the intensity at a given angle
\(\phi\) could be made as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{loglog}\PYG{p}{(}\PYG{n}{im}\PYG{o}{.}\PYG{n}{rc}\PYG{p}{,}\PYG{n}{im}\PYG{o}{.}\PYG{n}{image}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r [cm]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}I\PYGZus{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{nu [erg}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{, cm\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZhy{}2\PYGZcb{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{, s\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZhy{}1\PYGZcb{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{, Hz\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZhy{}1\PYGZcb{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{, ster\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZhy{}1\PYGZcb{}]\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The result will look like shown in Fig. \hyperref[\detokenize{imagesspectra:fig-circ-image}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-circ-image}}} .

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{circularimage}.pdf}
\caption{Example of a circular image of a 1\sphinxhyphen{}D spherical model (the model in the
\sphinxcode{\sphinxupquote{examples/run\_spher1d\_1/}} directory).}\label{\detokenize{imagesspectra:id12}}\label{\detokenize{imagesspectra:fig-circ-image}}\end{figure}

\sphinxAtStartPar
If you have 2\sphinxhyphen{}D or 3\sphinxhyphen{}D models in spherical coordinates, the circular images
(should) have not only a grid in \(r\), but also \(\phi\) grid points.
A simple plot such as Fig. \hyperref[\detokenize{imagesspectra:fig-circ-image}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-circ-image}}} will only show the intensity
for a single \(phi\) choice. There is no “right” or “wrong” way of displaying
such an image. It depends on your taste. You could, of course, remap onto a
“normal” image, but that would defeat the purpose of circular images. You could
also display the \((r,\phi)\) image directly with e.g. \sphinxcode{\sphinxupquote{plt.imshow()}},
which simply puts the \(r\) axis horizontally on the screen, and the
\(\phi\) axis vertically, essentially creating a ‘heat map’ of the
intensity as a function of \(r\) and \(\phi\).

\sphinxAtStartPar
This is illustrated in the model \sphinxcode{\sphinxupquote{examples/run\_spher2d\_1/}}.
Fig. \hyperref[\detokenize{imagesspectra:fig-circ-image-2d}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-circ-image-2d}}} shows the circular image (as a ‘heat map’)
at a wavelength of \(\lambda=10\;\mu m\). For comparison, the same image
is shown as a ‘normal’ image in Fig. \hyperref[\detokenize{imagesspectra:fig-rect-circ-image-2d}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-rect-circ-image-2d}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{circim2d}.pdf}
\caption{Example of a circular image of a 2\sphinxhyphen{}D spherical model (the model in the
\sphinxcode{\sphinxupquote{examples/run\_spher2d\_1/}} directory).}\label{\detokenize{imagesspectra:id13}}\label{\detokenize{imagesspectra:fig-circ-image-2d}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{spher2dim10mic}.pdf}
\caption{The rectangular (‘normal’) version of the image of Fig. \hyperref[\detokenize{imagesspectra:fig-circ-image-2d}]{Fig.\@ \ref{\detokenize{imagesspectra:fig-circ-image-2d}}}.
As one can see: the inner regions of this image are not well\sphinxhyphen{}resolved.}\label{\detokenize{imagesspectra:id14}}\label{\detokenize{imagesspectra:fig-rect-circ-image-2d}}\end{figure}

\sphinxAtStartPar
With a bit of “getting used to” one will find that the circular images will
reveal a lot of information.

\sphinxAtStartPar
\sphinxstyleemphasis{Note:} Fig. {\color{red}\bfseries{}:numfig:\textasciigrave{}fig\sphinxhyphen{}circ\sphinxhyphen{}image\sphinxhyphen{}2d\textasciigrave{}} shows an effect similar to what is
shown in Fig. \hyperref[\detokenize{tipsandtricks:fig-innerrim-lowres}]{Fig.\@ \ref{\detokenize{tipsandtricks:fig-innerrim-lowres}}}. This indicates that near the inner
radius of the model, the radial grid is under\sphinxhyphen{}resolved in example model
\sphinxcode{\sphinxupquote{examples/run\_spher2d\_1/}}: see Section {\hyperref[\detokenize{tipsandtricks:sec-things-going-wrong}]{\sphinxcrossref{\DUrole{std,std-ref}{Careful: Things that might go wrong}}}}, point
‘Too optically thick cells at the surface or inner edge’. So, to improve
the reliability of model \sphinxcode{\sphinxupquote{examples/run\_spher2d\_1/}}, one would need to
refine the radial grid near the inner edge and/or smooth the density there.


\section{Visualizing the \protect\(\tau=1\protect\) surface}
\label{\detokenize{imagesspectra:visualizing-the-tau-1-surface}}\label{\detokenize{imagesspectra:sec-tausurf}}
\sphinxAtStartPar
To be able to interpret the outcome of the radiative transfer calculations it is
often useful to find the spatial location of the \(\tau=1\) surface (or, for
that matter, the \(\tau=0.1\) surface or any \(\tau=\tau_s\) surface) as
seen from the vantage point of the observer. This makes it easier to understand
where the emission comes from that you are seeing. RADMC\sphinxhyphen{}3D makes this
possible. Thanks to Peter Schilke and his team, for suggesting this useful
option.

\sphinxAtStartPar
The idea is to simply replace the command\sphinxhyphen{}line keyword \sphinxcode{\sphinxupquote{image}} with \sphinxcode{\sphinxupquote{tausurf
1.0}}. The \(1.0\) stands for \(\tau_s=1.0\), meaning we will find the
\(\tau=1.0\) surface. Example: Normally you might make an image with
e.g. the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now you make a \(\tau=1\) surface with the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{tausurf} \PYG{l+m+mf}{1.0} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30}
\end{sphinxVerbatim}

\sphinxAtStartPar
or a \(\tau=0.2\) surface with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{tausurf} \PYG{l+m+mf}{0.2} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30}
\end{sphinxVerbatim}

\sphinxAtStartPar
The image output file \sphinxcode{\sphinxupquote{image.out}} will now contain, for each pixel, the
position along the ray in centimeters where \(\tau=\tau_s\). The zero point
is the surface perpendicular to the direction of observation, going through the
pointing position (which is, by default \((0,0,0)\), but see the description
of \sphinxcode{\sphinxupquote{pointau}} in Section {\hyperref[\detokenize{imagesspectra:sec-images}]{\sphinxcrossref{\DUrole{std,std-ref}{Basics of image making with RADMC\sphinxhyphen{}3D}}}}). Positive values mean that the
surface is closer to the observer than the plane, while negative values mean
that the surface is behind the plane.

\sphinxAtStartPar
If, for some pixel, there exists no \(\tau=\tau_s\) point because the total
optical depth of the object for the ray belonging to that pixel is less than
\(\tau_s\), then the value will be \sphinxhyphen{}1e91.

\sphinxAtStartPar
You can also get the 3\sphinxhyphen{}D (i.e. \(x\), \(y\), \(z\)) positions of
each of these points on the \(\tau=\tau_s\) surface. They are stored in the
file \sphinxcode{\sphinxupquote{tausurface\_3d.out}}.

\sphinxAtStartPar
Note that if you make multi\sphinxhyphen{}frequency images, you will also get multi\sphinxhyphen{}frequency
\(\tau=\tau_s\) surfaces. This can be particularly useful if you want to
understand the sometimes complex origins of the shapes of molecular/atomic
lines.

\sphinxAtStartPar
You can also use this option in the local observer mode, though I am not sure
how useful it is. Note, however, that in that mode the value stored in the
\sphinxcode{\sphinxupquote{image.out}} file will describe the distance in centimeter to the local
observer. The larger the value, the farther away from the observer (contrary to
the case of observer\sphinxhyphen{}at\sphinxhyphen{}infinity).

\sphinxAtStartPar
Example usage:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{tausurf} \PYG{l+m+mi}{1} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30}
\end{sphinxVerbatim}


\section{Maps of optical depth \protect\(\tau\protect\)}
\label{\detokenize{imagesspectra:maps-of-optical-depth-tau}}\label{\detokenize{imagesspectra:sec-tracetau}}
\sphinxAtStartPar
Another way to get a better understanding of the optical depth of your model
is to make an “image of optical depths”. It is just like making an image, but
instead of each pixel containing the intensity \(I_\nu\) of the image,
each pixel now contains the full optical depth \(\tau_\nu\) along the ray.
In this way you get an optical depth map.

\sphinxAtStartPar
The idea is to simply make an image, as you would normally do, but now add
the command\sphinxhyphen{}line  keyword \sphinxcode{\sphinxupquote{tracetau}}. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{10} \PYG{n}{incl} \PYG{l+m+mi}{45} \PYG{n}{phi} \PYG{l+m+mi}{30} \PYG{n}{tracetau}
\end{sphinxVerbatim}

\sphinxAtStartPar
The image output file \sphinxcode{\sphinxupquote{image.out}} will now contain, for each pixel, the
optical depth.

\sphinxAtStartPar
You can also use the command\sphinxhyphen{}line  keyword \sphinxcode{\sphinxupquote{tracecolumn}}, in which case
your image will not contain the optical depth, but the total column density.
Note: For now it only includes the column density of the dust.


\section{For public outreach work: local observers inside the model}
\label{\detokenize{imagesspectra:for-public-outreach-work-local-observers-inside-the-model}}\label{\detokenize{imagesspectra:sec-local-observer}}
\sphinxAtStartPar
While it may not be very useful for scientific purposes (though there may be
exceptions), it is very nice for public outreach to be able to view a model
from the inside, as if you, as the observer, were standing right in the
middle of the model cloud or object. One can then use physical or
semi\sphinxhyphen{}physical or even completely ad\sphinxhyphen{}hoc opacities to create the right
‘visual effects’. RADMC\sphinxhyphen{}3D has a viewing mode for this purpose. You can use
different projections:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Projection onto flat screen:}

\sphinxAtStartPar
The simplest one is a projection onto a screen in front (or behind) the
point\sphinxhyphen{}location of the observer. This gives an image that is good for viewing
in a normal screen. This is the default (\sphinxcode{\sphinxupquote{camera\_localobs\_projection=1}}).

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Projection onto a sphere:}

\sphinxAtStartPar
Another projection is a projection onto a sphere, which allow fields of view
that are equal or larger than \(2\pi\) of the sky. It may be useful for
projection onto an OMNIMAX dome. This is projection mode
\sphinxcode{\sphinxupquote{camera\_localobs\_projection=2}}.

\end{itemize}

\sphinxAtStartPar
You can set the variable \sphinxcode{\sphinxupquote{camera\_localobs\_projection}} to 1 or 2 by adding on
the command line \sphinxcode{\sphinxupquote{projection 2}} (or 1), or by setting it in the
\sphinxcode{\sphinxupquote{radmc3d.inp}} as a line \sphinxcode{\sphinxupquote{camera\_localobs\_projection = 2}} (or 1).

\sphinxAtStartPar
To use the local projection mode you must specify the following variables
on the command line:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sizeradian}}:
This sets the size of the image in radian (i.e. the entire width of the
image). Setting this will make the image width and height the same (like
setting \sphinxcode{\sphinxupquote{sizeau}} in the observer\sphinxhyphen{}at\sphinxhyphen{}infinity mode, see Section
{\hyperref[\detokenize{imagesspectra:sec-images}]{\sphinxcrossref{\DUrole{std,std-ref}{Basics of image making with RADMC\sphinxhyphen{}3D}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zoomradian}}:
\sphinxstyleemphasis{Instead} of \sphinxcode{\sphinxupquote{sizeradian}} you can also specify \sphinxcode{\sphinxupquote{zoomradian}}, which is the
local\sphinxhyphen{}observer version of \sphinxcode{\sphinxupquote{zoomau}} or\textasciigrave{}\textasciigrave{}zoompc\textasciigrave{}\textasciigrave{} (see Section
{\hyperref[\detokenize{imagesspectra:sec-images}]{\sphinxcrossref{\DUrole{std,std-ref}{Basics of image making with RADMC\sphinxhyphen{}3D}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{posang}}:
The position angle of the camera. Has the same meaning as in the
observer\sphinxhyphen{}at\sphinxhyphen{}infinity mode.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{locobsau}} or \sphinxcode{\sphinxupquote{locobspc}}:
Specify the 3\sphinxhyphen{}D location of the local observer inside the model in units
of AU or parsec. This requires 3 numbers which are the x, y and z
positions (also when using spherical coordinates for the model setup:
these are still the cartesian coordinates).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pointau}} or \sphinxcode{\sphinxupquote{pointpc}}:
These have the same meaning as in the observer\sphinxhyphen{}at\sphinxhyphen{}infinity model.  They
specify the 3\sphinxhyphen{}D location of the point of focus for the camera (to which
point in space is the camera pointing) in units of AU or parsec. This
requires 3 numbers which are the x, y and z positions (also when using
spherical coordinates for the model setup: these are still the cartesian
coordinates).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zenith}} (optional):
For Planetarium Dome projection (\sphinxcode{\sphinxupquote{camera\_localobs\_projection=2}}) it is
useful to make the pointing direction not at the zenith (because then the
audience will always have to look straight up) but at, say, 45 degrees. You
can facilitate this (optionally) by adding the command line option \sphinxcode{\sphinxupquote{zenith
45}} for a 45 degrees offset. This means that if you are sitting under the
OMNIMAX dome, then the camera pointing (see \sphinxcode{\sphinxupquote{pointau}} above) is 45 degrees
in front of you rather than at the zenith. This option is highly recommended
for dome projections, but you may need to play with the angle to see which
gives the best effect.

\end{itemize}

\sphinxAtStartPar
Setting \sphinxcode{\sphinxupquote{sizeradian}}, \sphinxcode{\sphinxupquote{zoomradian}}, \sphinxcode{\sphinxupquote{locobsau}} or \sphinxcode{\sphinxupquote{locobspc}} on the
command line automatically switches to the local observer mode (i.e. there is no
need for an extra keyword setting the local observer mode on). To switch back to
observer\sphinxhyphen{}at\sphinxhyphen{}infinity mode, you specify e.g. \sphinxcode{\sphinxupquote{incl}} or \sphinxcode{\sphinxupquote{phi}} (the direction
toward which the observer is located in the observer\sphinxhyphen{}at\sphinxhyphen{}infinity mode). Note
that if you accidently specify both e.g. \sphinxcode{\sphinxupquote{sizeradian}} and \sphinxcode{\sphinxupquote{incl}}, you might
end up with the wrong mode, because the mode is set by the last relevant entry
on the command line.

\sphinxAtStartPar
The images that are produced using the local observer mode will have the x\sphinxhyphen{} and
y\sphinxhyphen{} pixel size specifications in radian instead of cm. The first line of an image
(the format number of the file) contains then the value 2 (indicating local
observer image with pixel sizes in radian) instead of 1 (which indicates
observer\sphinxhyphen{}at\sphinxhyphen{}infinity image with pixel sizes in cm).

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE: For technical reasons dust scattering is (at least for now) not included
in the local observer mode! It is discouraged to use the local observer mode for
scientific purposes.}


\section{Multiple vantage points: the ‘Movie’ mode}
\label{\detokenize{imagesspectra:multiple-vantage-points-the-movie-mode}}\label{\detokenize{imagesspectra:sec-movie-mode}}
\sphinxAtStartPar
It can be useful, both scientifically and for public outreach, to make movies of
your model, for instance by showing your model from different vantage points or
by ‘travelling’ through the model using the local observer mode (Section
{\hyperref[\detokenize{imagesspectra:sec-local-observer}]{\sphinxcrossref{\DUrole{std,std-ref}{For public outreach work: local observers inside the model}}}}). For a movie one must make many frames, each frame
being an image created by RADMC\sphinxhyphen{}3D’s image capabilities. If you call \sphinxcode{\sphinxupquote{radmc3d}}
separately for each image, then often the reading of all the large input files
takes up most of the time. One way to solve this is to call \sphinxcode{\sphinxupquote{radmc3d}} in
‘child mode’ (see Chapter \DUrole{xref,std,std-ref}{chap\sphinxhyphen{}child\sphinxhyphen{}mode}). But this is somewhat
complicated and cumbersome. A better way is to use RADMC\sphinxhyphen{}3D’s ‘movie mode’. This
allows you to ask RADMC\sphinxhyphen{}3D to make a sequence of images in a single call. The
way to do this is to call \sphinxcode{\sphinxupquote{radmc3d}} with the \sphinxcode{\sphinxupquote{movie}} keyword:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{movie}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will make \sphinxcode{\sphinxupquote{radmc3d}} to look for a file called \sphinxcode{\sphinxupquote{movie.inp}} which
contains the information about each image it should make. The structure of the
\sphinxcode{\sphinxupquote{movie.inp}} file is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}
\PYG{n}{nframes}
\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{information} \PYG{k}{for} \PYG{n}{frame} \PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}\PYGZgt{}}
\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{information} \PYG{k}{for} \PYG{n}{frame} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}\PYGZgt{}}
\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{information} \PYG{k}{for} \PYG{n}{frame} \PYG{l+m+mi}{3}\PYG{o}{\PYGZgt{}\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{n}{information} \PYG{k}{for} \PYG{n}{frame} \PYG{n}{nframes}\PYG{o}{\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{iformat}} is an integer that is described below.  The \sphinxcode{\sphinxupquote{nframes}} is the
number of frames. The \sphinxcode{\sphinxupquote{\textless{}\textless{}information for frame xx\textgreater{}\textgreater{}}} are lines
containing the information of how the camera should be positioned for each frame
of the movie (i.e. for each imag). It is also described below.

\sphinxAtStartPar
There are multiple ways to tell RADMC\sphinxhyphen{}3D how to make
this sequence of images. Which if these ways RADMC\sphinxhyphen{}3D should use is specified
by the \sphinxcode{\sphinxupquote{iformat}} number. Currently there are 2, but later we may add
further possibilities. Here are the current possibilities
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat=1}}:
The observer is at infinity (as usual) and the \sphinxcode{\sphinxupquote{\textless{}\textless{}information
for frame xx\textgreater{}\textgreater{}}} consists of the following numbers (separated by
spaces):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pntx} \PYG{n}{pnty} \PYG{n}{pntz} \PYG{n}{hsx} \PYG{n}{hsy} \PYG{n}{pa} \PYG{n}{incl} \PYG{n}{phi}
\end{sphinxVerbatim}

\sphinxAtStartPar
These 8 numbers have the following meaning:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pntx,pnty,pntz}}:
These are the x, y and z coordinates (in units of cm) of the point toward
which the camera is pointing.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hsx,hsy}}:
These are the image half\sphinxhyphen{}size in horizontal and vertical direction on the
image (in units of cm).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pa}}:
This is the position angle of the camera in degrees.
This has the same meaning as for a single image.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{incl,phi}}:
These are the inclination and phi angle toward the observer in degrees.
These have the same meaning as for a single image.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat=\sphinxhyphen{}1}}:
The observer is local (see Section
{\hyperref[\detokenize{imagesspectra:sec-local-observer}]{\sphinxcrossref{\DUrole{std,std-ref}{For public outreach work: local observers inside the model}}}}) and the \sphinxcode{\sphinxupquote{\textless{}\textless{}information for frame
xx\textgreater{}\textgreater{}}} consists of the following numbers (separated by spaces):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pntx} \PYG{n}{pnty} \PYG{n}{pntz} \PYG{n}{hsx} \PYG{n}{hsy} \PYG{n}{pa} \PYG{n}{obsx} \PYG{n}{obsy} \PYG{n}{obsz}
\end{sphinxVerbatim}

\sphinxAtStartPar
These 9 numbers have the following meaning:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pntx,pnty,pntz,hsx,hsy,pa}}:
Same meaning as for \sphinxcode{\sphinxupquote{iformat=1}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{obsx,obsy,obsz}}:
These are the x, y and z position of the local observer (in units of cm).

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Apart from the quantities that are thus set for each image separately, all other
command\sphinxhyphen{}line options still remain valid.

\sphinxAtStartPar
Example, let us make a movie of 360 frames of a model seen at infinity while
rotating the object 360 degrees, and as seen at a wavelength of
\(\lambda=10\mu`m with 200x200 pixels. We construct the ``movie.inp`\) file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{360}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1e15} \PYG{l+m+mf}{1e15} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{60.}  \PYG{l+m+mf}{1.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1e15} \PYG{l+m+mf}{1e15} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{60.}  \PYG{l+m+mf}{2.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1e15} \PYG{l+m+mf}{1e15} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{60.}  \PYG{l+m+mf}{3.}
\PYG{o}{.}
\PYG{o}{.}
\PYG{o}{.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1e15} \PYG{l+m+mf}{1e15} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{60.}  \PYG{l+m+mf}{358.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1e15} \PYG{l+m+mf}{1e15} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{60.}  \PYG{l+m+mf}{359.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1e15} \PYG{l+m+mf}{1e15} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{60.}  \PYG{l+m+mf}{360.}
\end{sphinxVerbatim}

\sphinxAtStartPar
We now call RADMC\sphinxhyphen{}3D in the following way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{movie} \PYG{k}{lambda} \PYG{l+m+mf}{10.} \PYG{n}{npix} \PYG{l+m+mi}{200}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will create image files \sphinxcode{\sphinxupquote{image\_0001.out}}, \sphinxcode{\sphinxupquote{image\_0002.out}}, all the way
to \sphinxcode{\sphinxupquote{image\_0360.out}}.  The images will have a full width and height of
\(2\times 10^{15}`cm (about 130 AU), will always point to the center of the
image, will be taken at an inclination of 60 degrees and with varying
:math:\)phi\textasciigrave{}\sphinxhyphen{}angle.

\sphinxAtStartPar
Another example: let us move through the object (local observer mode),
approaching the center very closely, but not precisely:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{101}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{6.e13} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0000e15} \PYG{l+m+mf}{0.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{6.e13} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.9800e15} \PYG{l+m+mf}{0.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{6.e13} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.9600e15} \PYG{l+m+mf}{0.}
\PYG{o}{.}
\PYG{o}{.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{6.e13} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0200e15} \PYG{l+m+mf}{0.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{6.e13}  \PYG{l+m+mf}{0.0000e15} \PYG{l+m+mf}{0.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{6.e13}  \PYG{l+m+mf}{0.0200e15} \PYG{l+m+mf}{0.}
\PYG{o}{.}
\PYG{o}{.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{6.e13}  \PYG{l+m+mf}{0.9600e15} \PYG{l+m+mf}{0.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{6.e13}  \PYG{l+m+mf}{0.9800e15} \PYG{l+m+mf}{0.}
\PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.8} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{6.e13}  \PYG{l+m+mf}{1.0000e15} \PYG{l+m+mf}{0.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here the camera automatically rotates such that the focus remains on the center,
as the camera flies by the center of the object at a closest\sphinxhyphen{}approach to the
center of \(6\times 10^{13}\) cm. The half\sphinxhyphen{}width of the image is 0.8 radian.

\sphinxAtStartPar
\sphinxstyleemphasis{Important note:} If you have scattering switched on, then every rendering of an
image makes a new scattering Monte Carlo run. Since Monte Carlo produces noise,
this would lead to a movie that is very jittery (every frame has a new noise
set). It is of course best to avoid this by using so many photon packages that
this is not a concern. But in practice this may be very CPU\sphinxhyphen{}time consuming. You
can also fix the noise in the following way: add \sphinxcode{\sphinxupquote{resetseed}} to the
command\sphinxhyphen{}line call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{movie} \PYG{n}{resetseed}
\end{sphinxVerbatim}

\sphinxAtStartPar
and it will force each new scattering Monte Carlo computation to start with the
same seed, so that the photons will exactly move along the same
trajectories. Now only the scattering phase function will change because of the
different vantage points, but not the Monte Carlo noise. You can in fact set the
actual value of the initial seed in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file by adding a line

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iseed} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5415}
\end{sphinxVerbatim}

\sphinxAtStartPar
(where \sphinxhyphen{}5415 is to be replaced by the value you want) to the \sphinxcode{\sphinxupquote{radmc3d.inp}}
file. Note also that if your movie goes through different wavelengths, the
resetseed will likely not help fixing the noisiness, because the paths of
photons will change for different wavelengths, even with the same initial seed.

\sphinxstepscope


\chapter{More information about the gridding}
\label{\detokenize{gridding:more-information-about-the-gridding}}\label{\detokenize{gridding:chap-gridding}}\label{\detokenize{gridding::doc}}
\sphinxAtStartPar
We already discussed the various types of grids in Section
{\hyperref[\detokenize{basicstructure:sec-spatial-grid}]{\sphinxcrossref{\DUrole{std,std-ref}{The spatial grid}}}}, and the grid input file structure is described in
Section {\hyperref[\detokenize{inputoutputfiles:sec-grid-input}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): amr\_grid.inp}}}}. In this chapter let us take a closer look
at the gridding possibilities and things to take special care of.


\section{Regular grids}
\label{\detokenize{gridding:regular-grids}}\label{\detokenize{gridding:sec-regular-grid}}
\sphinxAtStartPar
A regular grid is called ‘grid style 0’ in RADMC\sphinxhyphen{}3D. It can be used in
Cartesian coordinates as well as in spherical coordinates (Section
{\hyperref[\detokenize{basicstructure:sec-coord-systems}]{\sphinxcrossref{\DUrole{std,std-ref}{Coordinate systems}}}}).

\sphinxAtStartPar
A regular grid, in our definition, is a multi\sphinxhyphen{}dimensional grid which is
separable in \(x\), \(y\) and \(z\) (or in spherical coordinates in
\(r\), \(\theta\) and \(\phi\)). You specify a 1\sphinxhyphen{}D monotonically
increasing array of values \(x_1, x_2,\cdots,x_{\mathrm{nx+1}}\) which
represent the cell walls in \(x-direction\).  You do the same for the other
directions: \(y_1, y_2,\cdots,y_{\mathrm{ny+1}}\) and \(z_1,
z_2,\cdots,z_{\mathrm{nz+1}}\).  The value of, say, \(x_2\) is the same for
every position in \(y\) and \(z\): this is what we mean with
‘separable’.

\sphinxAtStartPar
In Cartesian coordinates RADMC\sphinxhyphen{}3D enforces perfectly cubic grid cells (i.e.
linear grids). But that is only to make the image sub\sphinxhyphen{}pixeling easier (see
Section {\hyperref[\detokenize{imagesspectra:sec-recursive-subpixeling}]{\sphinxcrossref{\DUrole{std,std-ref}{The solution: recursive sub\sphinxhyphen{}pixeling}}}}). For spherical grids this is not
enforced, and in fact it is strongly encouraged to use non\sphinxhyphen{}linear grids in
spherical coordinates. Please read Section {\hyperref[\detokenize{gridding:sec-separable-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{Separable grid refinement in spherical coordinates (important!)}}}}
if you use spherical coordinates!

\sphinxAtStartPar
In a regular grid you specify the grids in each direction separately.  For
instance, the x\sphinxhyphen{}grid is given by specifying the cell walls in x\sphinxhyphen{}direction. If we
have, say, 10 cells in x\sphinxhyphen{}direction, we must specify 11 cell wall positions. For
instance: \(x_i=\{-5,-4,-3,-2,-1,0,1,2,3,4,5\}\).  For the
\(y\)\sphinxhyphen{}direction and \(z\)\sphinxhyphen{}direction
likewise. Fig. \hyperref[\detokenize{gridding:fig-regular-grid}]{Fig.\@ \ref{\detokenize{gridding:fig-regular-grid}}} shows an example of a 2\sphinxhyphen{}D regular grid
of 4x3 cells.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{base_amr_bare}.pdf}
\caption{Example of a regular 2\sphinxhyphen{}D grid with \sphinxcode{\sphinxupquote{nx=4}} and \sphinxcode{\sphinxupquote{ny=3}}.}\label{\detokenize{gridding:id1}}\label{\detokenize{gridding:fig-regular-grid}}\end{figure}

\sphinxAtStartPar
In Cartesian coordinates we typically define our model in full 3\sphinxhyphen{}D.
However, if your problem has translational symmetries, you might also want
to consider the 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel mode (see Section
{\hyperref[\detokenize{gridding:sec-1d-plane-parallel}]{\sphinxcrossref{\DUrole{std,std-ref}{1\sphinxhyphen{}D Plane\sphinxhyphen{}parallel models}}}}).

\sphinxAtStartPar
In full 3\sphinxhyphen{}D Cartesian coordinates the cell sizes \sphinxstyleemphasis{must} be perfectly
cubical, i.e. the spacing in each direction must be the same. If you need a
finer grid in some location, you can use the AMR capabilities discussed
below.

\sphinxAtStartPar
In spherical coordinates you can choose between 1\sphinxhyphen{}D spherically symmetric
models, 2\sphinxhyphen{}D axisymmetric models or fully 3\sphinxhyphen{}D models. In spherical coordinates
you do \sphinxstyleemphasis{not} have restrictions to the cell geometry or grid spacing.
You can choose any set of numbers \(r_1,\cdots,r_{\mathrm{nr}}\) as radial
grid, as long as this set of numbers is larger than 0 and monotonically
increasing. The same is true for the \(\theta\)\sphinxhyphen{}grid and the \(\phi\)\sphinxhyphen{}grid.

\sphinxAtStartPar
The precise way how to set up a regular grid using the \sphinxcode{\sphinxupquote{amr\_grid.inp}} file is
described in Section {\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-regular}]{\sphinxcrossref{\DUrole{std,std-ref}{Regular grid}}}}.  The input of any spatial
variables (such as e.g. the dust density) uses the sequence of grid cells in
the same order as the cells are specified in that \sphinxcode{\sphinxupquote{amr\_grid.inp}} file.

\sphinxAtStartPar
For input and output data to file, for stuff on a regular grid, the order of
nested loops over coordinates would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{do} \PYG{n}{iz}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{amr\PYGZus{}grid\PYGZus{}nz}
   \PYG{n}{do} \PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{amr\PYGZus{}grid\PYGZus{}ny}
      \PYG{n}{do} \PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{amr\PYGZus{}grid\PYGZus{}nx}
         \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{read} \PYG{o+ow}{or} \PYG{n}{write} \PYG{n}{your} \PYG{n}{data} \PYG{o}{\PYGZgt{}\PYGZgt{}}
      \PYG{n}{enddo}
   \PYG{n}{enddo}
\PYG{n}{enddo}
\end{sphinxVerbatim}

\sphinxAtStartPar
For spherical coordinates we have the following association: \(x\rightarrow r\),
\(y\rightarrow \theta\), \(z\rightarrow \phi\).


\section{Separable grid refinement in spherical coordinates (important!)}
\label{\detokenize{gridding:separable-grid-refinement-in-spherical-coordinates-important}}\label{\detokenize{gridding:sec-separable-refinement}}
\sphinxAtStartPar
Spherical coordinates are a very powerful way of dealing with
centrally\sphinxhyphen{}concentrated problems. For instance, collapsing protostellar cores,
protoplanetary disks, disk galaxies, dust tori around active galactic nuclei,
accretion disks around compact objects, etc. In other words: problems in which a
single central body dominates the problem, and material at all distances from
the central body matters. For example a disk around a young star goes all the
way from 0.01 AU out to 1000 AU, covering 5 orders of magnitude in
radius. Spherical coordinates are the easiest way of dealing with such a huge
radial dynamic range: you simply make a radial grid, where the grid spacing
\(r_{i+1}-r_i\) scales roughly with \(r_i\).

\sphinxAtStartPar
This is called a \sphinxstyleemphasis{logarithmic radial grid}. This is a grid whith a spacing in
which \((r_{i+1}-r_i)/r_i\) is constant with \(r\). In this way you
assure that you have always the right spatial resolution in \(r\) at each
radius. In spherical coordinates it is highly recomended to use such a log
spacing. But you can also refine the \(r\) grid even more (in addition to
the log\sphinxhyphen{}spacing). This is also strongly recommended near the inner edge of a
circumstellar shell, for instance.  Or at the inner dust rim of a disk. There
you must refine the \(r\) grid (by simply making the spacing smaller as you
approach the inner edge from the outside) to assure that the first few cells are
optically thin and that there is a gradual transition from optically thin to
optically thick as you go outward. This is particularly important for, for
instance, the inner rim of a dusty disk.

\sphinxAtStartPar
In spherical coordinates you can vary the spacing in \(r\), \(\theta\)
and \(\phi\) completely freely. That means: you could have for instance
\(r\) to be spaced as \(1.00, 1.01, 1.03, 1.05, 1.1, 1.2, 1.35,
\cdots\). There is no restriction, as long as the coordinate points are
monotonically increasing. In Figs \hyperref[\detokenize{gridding:fig-spher-sep-ref-txt}]{Fig.\@ \ref{\detokenize{gridding:fig-spher-sep-ref-txt}}} and
\hyperref[\detokenize{gridding:fig-spher-sep-ref-rays}]{Fig.\@ \ref{\detokenize{gridding:fig-spher-sep-ref-rays}}} this is illustrated.

\sphinxAtStartPar
\sphinxstyleemphasis{Note that in addition to separable refinement, also AMR refinement
is possible in spherical coordinates. See Section} {\hyperref[\detokenize{gridding:sec-oct-tree-amr}]{\sphinxcrossref{\DUrole{std,std-ref}{Oct\sphinxhyphen{}tree Adaptive Mesh Refinement}}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.300\linewidth]{{spher_grid_ref_txt}.pdf}
\caption{Example of a spherical 2\sphinxhyphen{}D grid in which the radial and \(\theta\) grids
are refined in a ‘separable’ way. In radial direction the inner cells are
refined (‘B’ in the right figure) and in \(\theta\) direction the cells
near the equatorial plane are refined (‘C’ in the right figure). This kind of
grid refinement does not require oct\sphinxhyphen{}tree AMR: the grid remains
separable. For models in which the inner grid edge is also the inner model
edge (e.g. a simple model of a protoplanetary disk with a sharp inner
cut\sphinxhyphen{}off) this kind of separable grid refinement in \(R\)\sphinxhyphen{}direction may be
essential to avoid problems with optically thick inner cells (see e.g. Fig.
\hyperref[\detokenize{tipsandtricks:fig-innerrim-lowres}]{Fig.\@ \ref{\detokenize{tipsandtricks:fig-innerrim-lowres}}} for an example of what could go wrong if you do
not do this). Separable grid refinement in \(\Theta\)\sphinxhyphen{}direction is
typically important for protoplanetary disk models, where the midplane and
surface layers of the disk need to have sufficient resolution, but any
possible surrounding spherical nebula may not.}\label{\detokenize{gridding:id2}}\label{\detokenize{gridding:fig-spher-sep-ref-txt}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.650\linewidth]{{spher_grid_ref_rays}.pdf}
\caption{When making an image, RADMC\sphinxhyphen{}3D will automatically make ‘sub\sphinxhyphen{}pixels’ to ensure
that all structure of the model as projected on the sky of the observer are
spatially resolved.  Extreme grid refinement leads thus to extreme
sub\sphinxhyphen{}pixeling. See Section {\hyperref[\detokenize{imagesspectra:sec-rec-subpixel-spher-coord}]{\sphinxcrossref{\DUrole{std,std-ref}{Recursive sub\sphinxhyphen{}pixeling in spherical coordinates}}}} for details,
and ways to prevent excessive sub\sphinxhyphen{}pixeling when this is not necessary.}\label{\detokenize{gridding:id3}}\label{\detokenize{gridding:fig-spher-sep-ref-rays}}\end{figure}

\sphinxAtStartPar
For models of accretion disks it can, for instance, be useful to make sure that
there are more grid points of \(\theta\) near the equatorial plane
\(\theta=\pi/2\). So the grid spacing between \(\theta=0.0\) and
\(\theta=1.0\) may be very coarse while between \(\theta=1.0\) and
\(\theta=\pi/2\) you may put a finer grid. All of this ‘grid refinement’ can
be done without the ‘AMR’ refinement technique: this is the ‘separable’ grid
refinement, because you can do this separately for \(r\), for \(\theta\)
and for \(\phi\).

\sphinxAtStartPar
Sometimes, however, separable refinement may not help you to refine the grid
where necessary. For instance: if you model a disk with a planet in the
disk, then you may need to refine the grid around the planet. You could
refine the grid in principle in a separable way, but you would then have a
large redundancy in cells that are refined by far away from the planet.  Or
if you have a disk with an inner rim that is not exactly at
\(r=r_{\mathrm{rim}}\), but is a rounded\sphinxhyphen{}off rim. In these cases you need
refinement exactly located at the region of interest. For that you need the
‘AMR’ refinement (Sections {\hyperref[\detokenize{gridding:sec-oct-tree-amr}]{\sphinxcrossref{\DUrole{std,std-ref}{Oct\sphinxhyphen{}tree Adaptive Mesh Refinement}}}} and {\hyperref[\detokenize{gridding:sec-layered-amr}]{\sphinxcrossref{\DUrole{std,std-ref}{Layered Adaptive Mesh Refinement}}}}).

\sphinxAtStartPar
\sphinxstyleemphasis{Important note:} When using strong refinement in one of the coordinates
\(r\), \(\theta\) or \(\phi\), image\sphinxhyphen{}rendering and
spectrum\sphinxhyphen{}rendering can become very slow, because of the excessive sub\sphinxhyphen{}pixeling
this causes. There are ways to limit the sub\sphinxhyphen{}pixeling for those cases. See the
Section on sub\sphinxhyphen{}pixeling in spherical coordinate: Section
{\hyperref[\detokenize{imagesspectra:sec-rec-subpixel-spher-coord}]{\sphinxcrossref{\DUrole{std,std-ref}{Recursive sub\sphinxhyphen{}pixeling in spherical coordinates}}}}.


\section{Oct\sphinxhyphen{}tree Adaptive Mesh Refinement}
\label{\detokenize{gridding:oct-tree-adaptive-mesh-refinement}}\label{\detokenize{gridding:sec-oct-tree-amr}}
\sphinxAtStartPar
An oct\sphinxhyphen{}tree refinened grid is called ‘grid style 1’ in RADMC\sphinxhyphen{}3D. It can be
used in Cartesian coordinates as well as in spherical coordinates (Section
{\hyperref[\detokenize{basicstructure:sec-coord-systems}]{\sphinxcrossref{\DUrole{std,std-ref}{Coordinate systems}}}}).

\sphinxAtStartPar
You start from a normal regular base grid (see Section
{\hyperref[\detokenize{gridding:sec-regular-grid}]{\sphinxcrossref{\DUrole{std,std-ref}{Regular grids}}}}), possibly even with ‘separable refinement’ (see
Section {\hyperref[\detokenize{gridding:sec-separable-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{Separable grid refinement in spherical coordinates (important!)}}}}). You can then split some of the cells
into 2x2x2 subcells (or more precisely: in 1\sphinxhyphen{}D 2 subcells, in 2\sphinxhyphen{}D 2x2
subcells and in 3\sphinxhyphen{}D 2x2x2 subcells). If necessary, each of these 2x2x2
subcells can also be split into further subcells. This can be repeated as
many times as you wish until the desired grid refinement level is reached.
Each refinement step refines the grid by a factor of 2 in linear dimension,
which means in 3\sphinxhyphen{}D a factor of 8 in volume. In this way you get, for each
refined cell of the base grid, a tree of refinement. The base grid can have
any size, as long as the number of cells in each direction is an even
number. For instance, you can have a 6x4 base grid in 2\sphinxhyphen{}D, and refine cell
(1,2) by one level, so that this cell splits into 2x2 subcells.

\sphinxAtStartPar
Note that it is important to set which dimensions are ‘active’ and which
are ‘non\sphinxhyphen{}active’. For instance, if you have a 1\sphinxhyphen{}D model with 100 cells and
you tell RADMC\sphinxhyphen{}3D (see Section {\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-oct-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Oct\sphinxhyphen{}tree\sphinxhyphen{}style AMR grid}}}}) to make a base
grid of 100x1x1 cells, but you still keep all three dimensions ‘active’
(see Section {\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-oct-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Oct\sphinxhyphen{}tree\sphinxhyphen{}style AMR grid}}}}), then a refinement of cell 1
(which is actually cell (1,1,1)) will split that cell into 2x2x2 subcells,
i.e. it will also refine in y and z direction. Only if you explicitly
switch the y and z dimensions off the AMR will split it into just 2
subcells.

\sphinxAtStartPar
Oct\sphinxhyphen{}tree mesh refinement is very powerful, because it allows you to refine
the grid exactly there where you need it. And because we start from a
regular base grid like the grid specified in Section {\hyperref[\detokenize{gridding:sec-regular-grid}]{\sphinxcrossref{\DUrole{std,std-ref}{Regular grids}}}},
we can start designing our model on a regular base grid, and then refine
where needed. See Fig. \hyperref[\detokenize{gridding:fig-oct-tree-amr}]{Fig.\@ \ref{\detokenize{gridding:fig-oct-tree-amr}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{oct_tree_amr_bare}.pdf}
\caption{Example of a 2\sphinxhyphen{}D grid with oct\sphinxhyphen{}tree refinement. The base grid has \sphinxcode{\sphinxupquote{nx=4}}
and \sphinxcode{\sphinxupquote{ny=3}}. Three levels of refinement are added to this base grid.}\label{\detokenize{gridding:id4}}\label{\detokenize{gridding:fig-oct-tree-amr}}\end{figure}

\sphinxAtStartPar
The AMR stand for ‘Adaptive Mesh Refinement’, which may suggest that
RADMC\sphinxhyphen{}3D will refine internally. At the moment this is not yet the case.
The ‘adaptive’ aspect is left to the user: he/she will have to ‘adapt’
the grid such that it is sufficiently refinened where it is needed. In the
future we may allow on\sphinxhyphen{}the\sphinxhyphen{}fly adaption of the grid, but that is not yet
possible now.

\sphinxAtStartPar
One problem with oct\sphinxhyphen{}tree AMR is that it is difficult to handle such grids in
external plotting programs, or even in programs that set up the grid.  While it
is highly flexible, it is not very user\sphinxhyphen{}friendly. Typically you may use this
oct\sphinxhyphen{}tree refinement either because you import data from a hydrodynamics code
that works with oct\sphinxhyphen{}tree refinement (e.g. FLASH, RAMSES), or when you
internally refine the grid using the \sphinxcode{\sphinxupquote{userdef\_module.f90}} (see Chapter
{\hyperref[\detokenize{internalsetup:chap-internal-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Modifying RADMC\sphinxhyphen{}3D: Internal setup and user\sphinxhyphen{}specified radiative processes}}}}). In the former case you are anyway forced to manage
the complexities of AMR, while in the latter case you can make use of the AMR
modules of RADMC\sphinxhyphen{}3D internally to handle them. But if you do not need to full
flexibility of oct\sphinxhyphen{}tree refinement and want to use a simpler kind of refinement,
then you can use RADMC\sphinxhyphen{}3D’s alternative refinement mode: the layer\sphinxhyphen{}style AMR
described in Section {\hyperref[\detokenize{gridding:sec-layered-amr}]{\sphinxcrossref{\DUrole{std,std-ref}{Layered Adaptive Mesh Refinement}}}} below.

\sphinxAtStartPar
The precise way how to set up such an oct\sphinxhyphen{}tree grid using the \sphinxcode{\sphinxupquote{amr\_grid.inp}}
file is described in Section {\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-oct-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Oct\sphinxhyphen{}tree\sphinxhyphen{}style AMR grid}}}}.  The input of any
spatial variables (such as e.g. the dust density) uses the sequence of grid
cells in the same order as the cells are specified in that \sphinxcode{\sphinxupquote{amr\_grid.inp}}
file.


\section{Layered Adaptive Mesh Refinement}
\label{\detokenize{gridding:layered-adaptive-mesh-refinement}}\label{\detokenize{gridding:sec-layered-amr}}
\sphinxAtStartPar
A layer\sphinxhyphen{}style refinened grid is called ‘grid style 10’ in RADMC\sphinxhyphen{}3D. It can
be used in Cartesian coordinates as well as in spherical coordinates
(Section {\hyperref[\detokenize{basicstructure:sec-coord-systems}]{\sphinxcrossref{\DUrole{std,std-ref}{Coordinate systems}}}}).

\sphinxAtStartPar
This is an alternative to the full\sphinxhyphen{}fledged oct\sphinxhyphen{}tree refinement of Section
{\hyperref[\detokenize{gridding:sec-oct-tree-amr}]{\sphinxcrossref{\DUrole{std,std-ref}{Oct\sphinxhyphen{}tree Adaptive Mesh Refinement}}}}. The main advantage of the layer\sphinxhyphen{}style refinement is
that it is far easier to handle by the human brain, and thus easier for
model setup  and the analysis of the results.

\sphinxAtStartPar
The idea here is that you start again with a regular grid (like that of
Section {\hyperref[\detokenize{gridding:sec-regular-grid}]{\sphinxcrossref{\DUrole{std,std-ref}{Regular grids}}}}), but you can now specify a rectangular
region which you want to refine by a factor of 2. The way you do this is by
choosing the starting indices of the rectangle and specifying the size of
the rectangle by setting the number of cells in each direction from that
starting point onward. For instance, setting the starting point at (2,3,1)
and the size at (1,1,1) will simply refine just cell (2,3,1) of the base
grid into a set of 2x2x2 sub\sphinxhyphen{}cells. But setting the starting point at
(2,3,1) and the size at (2,2,2) will split cells (2,3,1), (3,3,1), (2,4,1),
(3,4,1), (2,3,2), (3,3,2), (2,4,2) and (3,4,2) each into 2x2x2 subcells.
This in fact is handled as a 4x4x4 regular sub\sphinxhyphen{}grid patch. And setting the
starting point at (2,3,1) and the size at (4,6,8) will make an entire
regular sub\sphinxhyphen{}grid patch of 8x12x16 cells. Such a sub\sphinxhyphen{}grid patch is
called a \sphinxstyleemphasis{layer}.

\sphinxAtStartPar
The nice thing of these layers is that each layer (i.e. subgrid patch) is
handled as a regular sub\sphinxhyphen{}grid. The base grid is layer number 0, and the first
layer is layer number 1, etc. Each layer (including the base grid) can contain
multiple sub\sphinxhyphen{}layers. The only restriction is that each layer fits entirely
inside its parent layer, and layers with the same parent layer should not
overlap. Each layer can thus have one or more sub\sphinxhyphen{}layers, each of which can
again be divided into sub\sphinxhyphen{}layers. This builds a tree structure, with the base
layer as the trunk of the tree (this is contrary to the oct\sphinxhyphen{}tree structure,
where each base grid \sphinxstyleemphasis{cell} forms the trunk of its own tree). In
Fig. \hyperref[\detokenize{gridding:fig-twolayer-amr}]{Fig.\@ \ref{\detokenize{gridding:fig-twolayer-amr}}} an example is shown of two layers with the same
parent (= layer 0 = base grid), while in Fig. \hyperref[\detokenize{gridding:fig-nestedlayer-amr}]{Fig.\@ \ref{\detokenize{gridding:fig-nestedlayer-amr}}} an
example is shown of two nested layers.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{twolayer_bare}.pdf}
\caption{Example of a 2\sphinxhyphen{}D base grid with \sphinxcode{\sphinxupquote{nx}}=4 and \sphinxcode{\sphinxupquote{ny}}=3, with two
AMR\sphinxhyphen{}layers added to it. This example has just one level of refinement, as
the two layers (brown and green) are on the same level (they have the same
parent layer = layer 0).}\label{\detokenize{gridding:id5}}\label{\detokenize{gridding:fig-twolayer-amr}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{nestedlayer_bare}.pdf}
\caption{Example of a 2\sphinxhyphen{}D base grid with \sphinxcode{\sphinxupquote{nx}}=4 and \sphinxcode{\sphinxupquote{ny}}=3, with two nested
AMR\sphinxhyphen{}layers added to it.  This example has two levels of refinement, as layer
1 (brown) is the parent of layer 2 (green).}\label{\detokenize{gridding:id6}}\label{\detokenize{gridding:fig-nestedlayer-amr}}\end{figure}

\sphinxAtStartPar
If you now want to specify data on this grid, then you simply specify it on
each layer separately, as if each layer is a separate entity. Each layer is
treated as a regular grid, irrespective of whether it contains sub\sphinxhyphen{}layers
or not. So if we have a base grid of 4x4x4 grid cells containing two layers:
one starting at (1,1,1) and having (2,2,2) size and another starting at
(3,3,3) and having (1,1,2) size, then we first specify the data on the
\(4^3=64\) base grid, then on the \((2\times 2)^3=64\) grid cells of the first
layer and then on the 2x2x4=16 cells of the second layer. Each of these
three layers are regular grids, and the data is inputted/outputted in
the same way as if these are normal regular grids (see Section
{\hyperref[\detokenize{gridding:sec-regular-grid}]{\sphinxcrossref{\DUrole{std,std-ref}{Regular grids}}}}). But instead of just one such regular grid, now
the data file (e.g. \sphinxcode{\sphinxupquote{dust\_density.inp}}) will contain three
successive lists of numbers, the first for the base grid, the second for
the first layer and the last for the second layer. You may realize at this
point that this will introduce a redundancy. See Subsection
{\hyperref[\detokenize{gridding:sec-layer-amr-redundancy}]{\sphinxcrossref{\DUrole{std,std-ref}{On the ‘successively regular’ kind of data storage, and its slight redundancy}}}} for a discussion of this redundancy.

\sphinxAtStartPar
The precise way how to set up such an oct\sphinxhyphen{}tree grid using the \sphinxcode{\sphinxupquote{amr\_grid.inp}}
file is described in Section {\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-layered}]{\sphinxcrossref{\DUrole{std,std-ref}{Layer\sphinxhyphen{}style AMR grid}}}}.  The input of any
spatial variables (such as e.g. the dust density) uses the sequence of grid
cells in the same order as the cells are specified in that \sphinxcode{\sphinxupquote{amr\_grid.inp}}
file.


\subsection{On the ‘successively regular’ kind of data storage, and its slight redundancy}
\label{\detokenize{gridding:on-the-successively-regular-kind-of-data-storage-and-its-slight-redundancy}}\label{\detokenize{gridding:sec-layer-amr-redundancy}}
\sphinxAtStartPar
With the layered grid refinement style there will be \sphinxstyleemphasis{redundant} data in the
data files (such as e.g. the \sphinxcode{\sphinxupquote{dust\_density.inp}} file. Each layer is a regular
(sub\sphinxhyphen{})grid and the data will be specified in each of these grid cells of that
regular (sub\sphinxhyphen{})grid.  If then some of these cells are overwritten by a
higher\sphinxhyphen{}level layer, these data are then redundant. We could of course have
insistent that only the data in those cells that are not refined by a layer
should be written to (or read from) the data files. But this would require quite
some clever programming on the part of the user to a\sphinxhyphen{}priori find out where the
layers are and therefore which cells should be skipped. We have decided that it
is far easier to just insist that each layer (including the base grid, which is
layer number 0) is simply written to the data file as a regular block of
data. The fact that some of this data will be not used (because they reside in
cells that are refined) means that we write more data to file than really exists
in the model. This makes the files larger than strictly necessary, but it makes
the data structure by far easier. Example: suppose you have a base grid of 8x8x8
cells and you replace the inner 4x4x4 cells with a layer of 8x8x8 cells (each
cell being half the size of the original cells).  Then you will have for
instance a \sphinxcode{\sphinxupquote{dust\_density.inp}} file containing 1024 values of the density:
\(8^3\)=512 values for the base grid and again \(8^3\)=512 values for
the refinement layer. Of the first \(8^3\)=512 values \(4^3\)=64 values
are ignored (they could have any value as they will not be used). The file is
thus 64 values larger than strictly necessary, which is a redundancy of
64/1024=0.0625. If you would have used the oct\sphinxhyphen{}tree refinement style for making
exactly the same grid, you would have only 1024\sphinxhyphen{}64=960 values in your file,
making the file 6.25\% smaller. But since 6.25\% is just a very small
difference, we decided that this is not a major problem and the simplicity of
our ‘successively regular’ kind of data format is more of an advantage than the
6.25\% redundance is a disadvantage.


\section{Unstructured grids}
\label{\detokenize{gridding:unstructured-grids}}\label{\detokenize{gridding:sec-unstruct-grids}}
\sphinxAtStartPar
In a future version of RADMC\sphinxhyphen{}3D we will include unstructured gridding as a
possibility. But at this moment such a gridding is not yet implemented.


\section{1\sphinxhyphen{}D Plane\sphinxhyphen{}parallel models}
\label{\detokenize{gridding:d-plane-parallel-models}}\label{\detokenize{gridding:sec-1d-plane-parallel}}
\sphinxAtStartPar
Sometimes it can be useful to make simple 1\sphinxhyphen{}D plane parallel models, for
instance if you want to make a simple 1\sphinxhyphen{}D model of a stellar atmosphere.
RADMC\sphinxhyphen{}3D is, however, by nature a 3\sphinxhyphen{}D code. But as of version 0.31 it features a
genuine 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel mode as well. This coordinate type has the
number 10. In this mode the \(x\)\sphinxhyphen{} and \(y\)\sphinxhyphen{}coordinates are the
in\sphinxhyphen{}plane coordinates, while the \(z\)\sphinxhyphen{}coordinate is the 1\sphinxhyphen{}D coordinate.  We
thus have a 1\sphinxhyphen{}D grid in the \(z\)\sphinxhyphen{}coordinate, but no grid in \(x\)\sphinxhyphen{} or
\(y\)\sphinxhyphen{}directions.

\sphinxAtStartPar
You can make a 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel model by setting some settings in the
\sphinxcode{\sphinxupquote{amr\_grid.inp}} file. Please consult Section {\hyperref[\detokenize{inputoutputfiles:sec-grid-input}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): amr\_grid.inp}}}} for the
format of this file. The changes/settings you have to do are (see example
below): (1) set the coordinate type number to 10, (2) set the \(x\) and
\(y\) dimensions to non\sphinxhyphen{}active and (3) setting the cell interfaces in
\(x\) to \sphinxhyphen{}1d90, +1d90, and likewise for \(y\). Here is then how it
looks:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}                                     \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Format} \PYG{n}{number} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{0}                                     \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Grid} \PYG{n}{style} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{=}\PYG{n}{regular} \PYG{n}{grid}\PYG{p}{)}
\PYG{l+m+mi}{10}                                    \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Coordinate} \PYG{n+nb}{type} \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{=}\PYG{n}{plane}\PYG{o}{\PYGZhy{}}\PYG{n}{parallel}\PYG{p}{)}
\PYG{l+m+mi}{0}                                     \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{p}{(}\PYG{n}{obsolete}\PYG{p}{)}
\PYG{l+m+mi}{0}  \PYG{l+m+mi}{0}  \PYG{l+m+mi}{1}                               \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{x} \PYG{o+ow}{and} \PYG{n}{y} \PYG{n}{are} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{active}\PYG{p}{,} \PYG{n}{z} \PYG{o+ow}{is} \PYG{n}{active}
\PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{100}                             \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{x} \PYG{o+ow}{and} \PYG{n}{y} \PYG{n}{are} \PYG{l+m+mi}{1} \PYG{n}{cell}\PYG{p}{,} \PYG{o+ow}{in} \PYG{n}{z} \PYG{n}{we} \PYG{n}{have} \PYG{l+m+mi}{100} \PYG{n}{cells}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e90} \PYG{l+m+mf}{1e90}                            \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{cell} \PYG{n}{walls} \PYG{o+ow}{in} \PYG{n}{x} \PYG{n}{are} \PYG{n}{at} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{infinity}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e90} \PYG{l+m+mf}{1e90}                            \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{cell} \PYG{n}{walls} \PYG{o+ow}{in} \PYG{n}{y} \PYG{n}{are} \PYG{n}{at} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{infinity}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{zi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{n}{zi}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{n}{zi}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{n}{zi}\PYG{p}{[}\PYG{n}{nz}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The other input files are for the rest as usual, as in the 3\sphinxhyphen{}D case.

\sphinxAtStartPar
You can now make your 1\sphinxhyphen{}D model as usual. For 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel problems it is
often useful to put a thermal boundary at the bottom of the model.  For
instance, if the model is a stellar atmosphere, you may want to cap the grid
from below with some given temperature. See Section
{\hyperref[\detokenize{gridding:sec-thermal-boundaries}]{\sphinxcrossref{\DUrole{std,std-ref}{Thermal boundaries in Cartesian coordinates}}}} for details on how to set up thermal boundaries.

\sphinxAtStartPar
In the 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel mode some things work a bit different than in the
“normal” 3\sphinxhyphen{}D mode:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Images are by default 1x1 pixels, because in a plane\sphinxhyphen{}parallel case it
is useless to have multiple pixels.

\item {} 
\sphinxAtStartPar
Spectra cannot be made, because “spectrum” is (in RADMC\sphinxhyphen{}3D ‘language’)
the flux as a function of frequency as seen at a very large distance of
the object, so that the object is in the “far field”. Since the concept of
“far\sphinxhyphen{}field” is no longer meaningful in a plane\sphinxhyphen{}parallel case, it is better
to make frequency\sphinxhyphen{}dependent 1x1 pixel images. This gives you the
frequence\sphinxhyphen{}dependent intensity, which is all you should need.

\item {} 
\sphinxAtStartPar
Stars are not allowed, as they have truly 3\sphinxhyphen{}D positions, which is
inconsistent with the plane\sphinxhyphen{}parallel assumption.

\end{itemize}

\sphinxAtStartPar
But for the rest, most stuff works similarly to the 3\sphinxhyphen{}D version. For instance,
you can compute dust temperatures with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{mctherm}
\end{sphinxVerbatim}

\sphinxAtStartPar
as usual.


\subsection{Making a spectrum of the 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel atmosphere}
\label{\detokenize{gridding:making-a-spectrum-of-the-1-d-plane-parallel-atmosphere}}
\sphinxAtStartPar
As mentioned above, the ‘normal’ 3\sphinxhyphen{}D way of making a spectrum of the 1\sphinxhyphen{}D
plane\sphinxhyphen{}parallel atmosphere is not possible, because formally the atmosphere is
infinitely extended. Instead you can obtain a spectrum in the form of an
intensity (\(\mathrm{erg}\,\mathrm{s}^{-1}\,\mathrm{cm}^{-2}\,\mathrm{Hz}^{-1}\,\mathrm{ster}^{-1}\))
as a function of wavelength. To do this you ask RADMC\sphinxhyphen{}3D to make a
multi\sphinxhyphen{}wavelength image of the atmosphere under a certain inclination
(inclination 0 meaning face\sphinxhyphen{}on), e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{n}{allwl} \PYG{n}{incl} \PYG{l+m+mi}{70}
\end{sphinxVerbatim}

\sphinxAtStartPar
This make an SED at \(\lambda=10\,\mu\)m for the observer seeing the
atmosphere at an inclination of 70 degrees. This produces a file image.out,
described in Section {\hyperref[\detokenize{inputoutputfiles:sec-image-out}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT: image.out or image\_****.out}}}}. The image is, in fact, a 1x1 pixel
multi\sphinxhyphen{}wavelength image. The \sphinxcode{\sphinxupquote{allwl}} (which stands for ‘all wavelengths’) means
that the spectral points are the same as those in the \sphinxcode{\sphinxupquote{wavelength\_micron.inp}}
file (see Section {\hyperref[\detokenize{inputoutputfiles:sec-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): wavelength\_micron.inp}}}}).  You can also specify the wavelengths
in a different way, e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{n}{lambdarange} \PYG{l+m+mi}{5} \PYG{l+m+mi}{20} \PYG{n}{nlam} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxAtStartPar
In fact, see Section {\hyperref[\detokenize{imagesspectra:sec-multi-wavelength-images}]{\sphinxcrossref{\DUrole{std,std-ref}{Making multi\sphinxhyphen{}wavelength images}}}} and
Section {\hyperref[\detokenize{imagesspectra:sec-set-camera-frequencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}}}} for details.


\subsection{In 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel: no star, but incident parallel flux beams}
\label{\detokenize{gridding:in-1-d-plane-parallel-no-star-but-incident-parallel-flux-beams}}
\sphinxAtStartPar
In 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel geometry it is impossible to include meaningful stars as
sources of photons. This is not a technical issue, but a mathematical truth: a
point in 1\sphinxhyphen{}D is in reality a plane in 3\sphinxhyphen{}D. As a replacement RADMC\sphinxhyphen{}3D offers
(only in 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel geometry) the possibility of illuminating the 1\sphinxhyphen{}D
atmosphere from above with a flux, incident onto the atmosphere in a prescribed
angle. This allows you to model, e.g., the Earth’s atmosphere being illuminated
by the sun at a given time of the day.  This is done by providing an ascii file
called \sphinxcode{\sphinxupquote{illum.inp}} which has the following form (similar, but not identical,
to the \sphinxcode{\sphinxupquote{stars.inp}} file, see Section {\hyperref[\detokenize{inputoutputfiles:sec-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (mostly required): stars.inp}}}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
iformat                           \PYGZlt{}=== Put this to 2 !
nillum     nlam
theta[1]      phi[1]
  .             .
  .             .
theta[nillum] phi[nillum]
lambda[1]
  .
  .
lambda[nlam]
flux[1,illum=1]
  .
  .
flux[nlam,illum=1]
flux[1,illum=2]
  .
  .
flux[nlam,illum=2]
  .
  .
  .
  .
flux[nlam,illum=nstar]
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{nillum}} is the number of illuminating beams you want to
specify. Normally this is 1, unless you have, e.g., a planet around a double
star. The \sphinxcode{\sphinxupquote{theta}} is the angle (in degrees) under which the beam impinges onto
the atmosphere. If you have \sphinxcode{\sphinxupquote{theta}}=0, then the flux points vertically
downward (sun at zenith). If you have \sphinxcode{\sphinxupquote{theta}}=89, then the flux points
almost parallel to the atmosphere (sunset). It is not allowed to put \sphinxcode{\sphinxupquote{theta}}=90.

\sphinxAtStartPar
You can, if you wish, also put the source behind the slab, i.e. \sphinxcode{\sphinxupquote{theta}}\textgreater{}90. Please note, however, that if you compute the spectrum of the
plane\sphinxhyphen{}parallel atmosphere the direct flux from these illumination beams does not
get picked up in the spectrum.


\subsection{Similarity and difference between 1\sphinxhyphen{}D spherical and 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel}
\label{\detokenize{gridding:similarity-and-difference-between-1-d-spherical-and-1-d-plane-parallel}}
\sphinxAtStartPar
Note that this 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel mode is only available in \(z\)\sphinxhyphen{}direction,
and only for cartesian coordinates! For spherical coordinates, a simple switch
to 1\sphinxhyphen{}D yields spherically symmetric 1\sphinxhyphen{}D radiative transfer, which is, however,
geometrically distinct from 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel radiative transfer. However, you
can also use a 1\sphinxhyphen{}D spherically symmetric setup to ‘emulate’ 1\sphinxhyphen{}D plane parallel
problems: You can make, for instance, a radial grid in which
\(r_{\mathrm{nr}}/r_1-1\ll 1\). An example: \(r=\{10000.0\),
\(10000.1\), \(10000.2\), \(\cdots,\) \(10001.0\}\). This is not
perfectly plane\sphinxhyphen{}parallel, but sufficiently much so that the difference is
presumably indiscernable.  The spectrum is then automatically that of the entire
large sphere, but by dividing it by the surface area, you can recalculate the
local flux.  In fact, since a plane\sphinxhyphen{}parallel model usually is meant to
approximate a tiny part of a large sphere, this mode is presumably even more
realistic than a truly 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel model.


\section{Thermal boundaries in Cartesian coordinates}
\label{\detokenize{gridding:thermal-boundaries-in-cartesian-coordinates}}\label{\detokenize{gridding:sec-thermal-boundaries}}
\sphinxAtStartPar
By default all boundaries of the computational domain are open, in the sense
that photons can move out freely. The only photons that move into the domain
from the outside are those from the interstellar radiation field (see Section
{\hyperref[\detokenize{stars:sec-external-source}]{\sphinxcrossref{\DUrole{std,std-ref}{The interstellar radiation field: external source of energy}}}}) and from any stars that are located outside of the
computational domain (see Section {\hyperref[\detokenize{inputoutputfiles:sec-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (mostly required): stars.inp}}}}). For some purposes it might,
however, be useful to have one or more of the six boundaries in 3\sphinxhyphen{}D to be
closed. RADMC\sphinxhyphen{}3D offers the possibility, in cartesian coordinates, to convert
the boundaries (each of the six separately) to a thermal boundary, i.e. a
blackbody emitter at some user\sphinxhyphen{}secified temperature. If you want that the left
X\sphinxhyphen{}boundary is a thermal wall at T=100 Kelvin, then you add the following line to
the \sphinxcode{\sphinxupquote{radmc3d.inp}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{thermal\PYGZus{}boundary\PYGZus{}xl} \PYG{o}{=} \PYG{l+m+mi}{100}
\end{sphinxVerbatim}

\sphinxAtStartPar
and similarly for xr (right X\sphinxhyphen{}boundary), yl, yr, zl and/or zr. You can set this
for each boundary separately, and particularly you can choose to set just one or
just two of the boundaries to thermal boundaries. Note that setting
\sphinxcode{\sphinxupquote{thermal\_boundary\_xl=0}} is equivalent to switching off the thermal boundary.

\sphinxAtStartPar
Note that if you now make an image of the box, the ray\sphinxhyphen{}tracer will show you
still the inside of the box, through any possible thermal boundary. In other
words: for the imaging or spectra these thermal boundaries are opaque for
radiation entering the grid, while they are transparent for radiation exiting
the grid. In other words, we see the blackbody emission from the backside walls,
but not of the frontside walls. In this way we can have a look inside the box in
spite of the thermal walls.

\sphinxstepscope


\chapter{More information about the treatment of stars}
\label{\detokenize{stars:more-information-about-the-treatment-of-stars}}\label{\detokenize{stars:chap-stars}}\label{\detokenize{stars::doc}}
\sphinxAtStartPar
How stars are treated in RADMC\sphinxhyphen{}3D is perhaps something that needs some more
background information. This is the structure:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Stars as individual objects:}

\sphinxAtStartPar
The most standard way of injecting stellar light into the model is by putting
one or more individual stars in the model. A star can be placed anywhere,
both inside the grid and outside. The main input file specifying their
location and properties is: \sphinxcode{\sphinxupquote{stars.inp}}. The stars can be treated in two
different ways, depending on the setting of the variable \sphinxcode{\sphinxupquote{istar\_sphere}}
that can be set to 0 or 1 in the file \sphinxcode{\sphinxupquote{radmc3d.inp}} file.
\begin{itemize}
\item {} 
\sphinxAtStartPar
The default is to treat stars as zero\sphinxhyphen{}size point sources. This is the way
it is done if (as is the default) \sphinxcode{\sphinxupquote{istar\_sphere=0}}.  The stars are then
treated as point sources in spite of the fact that their radius is
specified as non\sphinxhyphen{}zero in the \sphinxcode{\sphinxupquote{stars.inp}} file.  This default mode is the
easiest and quickest. For most purposes it is perfectly fine. Only if you
have material very close to a stellar surface it may be important to treat
the finite size(s) of the star(s).

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{istar\_sphere=1}} in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file, then all stars are
treated as spheres, their radii being the radii specified in the
\sphinxcode{\sphinxupquote{stars.inp}} file. This mode can be tricky, so please read Section
{\hyperref[\detokenize{stars:sec-stars-as-spheres}]{\sphinxcrossref{\DUrole{std,std-ref}{Stars treated as spheres}}}}.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Smooth distributions of zillions of stars:}

\sphinxAtStartPar
For modeling galaxies or objects of that size scale, it is of course
impossible and unnecessary to treat each star individually. So \sphinxstyleemphasis{in addition
to the individual stars} you can specify spatial distributions of stars,
assuming that the number of stars is so large that there will always be a
very large number of them in each cell. Please note that using this
possibility does \sphinxstyleemphasis{not} exclude the use of individual stars as well. For
instance, for a galaxy you may want to have distributions of unresolved
stars, but one single ‘star’ for the active nucleus and perhaps a few
individual ‘stars’ for bright star formation regions or O\sphinxhyphen{}star clusters or
so. The distribution of stars is described in Section
{\hyperref[\detokenize{stars:sec-distrib-of-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{Distributions of zillions of stars}}}}.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{An external ‘interstellar radiation field’:}

\sphinxAtStartPar
Often an object is affected not only by the stellar radiation from the stars
inside the object itself, but also by the diffuse radiation from the many
near and far stars surrounding the object. This ‘Interstellar Radiation
Field’ can be treated by RADMC\sphinxhyphen{}3D as well. This is called the ‘external
source’ in RADMC\sphinxhyphen{}3D. It is described in Section {\hyperref[\detokenize{stars:sec-external-source}]{\sphinxcrossref{\DUrole{std,std-ref}{The interstellar radiation field: external source of energy}}}}.

\end{enumerate}


\section{Stars treated as point sources}
\label{\detokenize{stars:stars-treated-as-point-sources}}\label{\detokenize{stars:sec-stars-as-points}}
\sphinxAtStartPar
By default the stars are treated as point\sphinxhyphen{}sources. Even if the radius is
specified as non\sphinxhyphen{}zero in the \sphinxcode{\sphinxupquote{stars.inp}} file, they are still
treated as points. The reason for this is that it is much easier and faster
for the code to treat them as point\sphinxhyphen{}sources. Point sources cannot occult
anything in the background, and nothing can partly occult them (they are
only fully or not occulted, of course modulo optical depth of the occulting
object). This approximation is, however, not valid if the spatial scales you
are interested in are not much larger (or even the same or smaller) than the
size of the star. For instance, if we are interested in modeling the
radiative transfer in a disk around a Brown Dwarf, where dust can survive
perhaps even all the way down to the stellar surface, we must take the
non\sphinxhyphen{}point\sphinxhyphen{}like geometry of the star into account. This is because due to its
size, the star can shine \sphinxstyleemphasis{down} onto the disk, which would not be
possible if the star is treated as a point source. However, for a dust disk
arounda Herbig Ae star, where the dust evaporation radius is at about 0.5
AU, the star can be treated as a point\sphinxhyphen{}source without problems.

\sphinxAtStartPar
So if you just use RADMC\sphinxhyphen{}3D as\sphinxhyphen{}is, or if you explicitly set \sphinxcode{\sphinxupquote{istar\_sphere=0}}
in the file \sphinxcode{\sphinxupquote{radmc3d.inp}}, then the stars are all treated as point sources.


\section{Stars treated as spheres}
\label{\detokenize{stars:stars-treated-as-spheres}}\label{\detokenize{stars:sec-stars-as-spheres}}
\sphinxAtStartPar
For problems in which the finite geometrical size of the star (or stars)
is/are important, RADMC\sphinxhyphen{}3D has a mode by which the stars are treated as
spheres. This can be necessary for instance if you model a disk around
a Brown Dwarf, where the dusty disk goes all the way down to the stellar
surface. The finite size of the star can thus shine \sphinxstyleemphasis{down} onto the
disk, but only if its finite size is treated as such. In the default
point\sphinxhyphen{}source approximation the surface layers of such a disk would be
too cold, because this ‘shining down onto the disk’ phenomenon is
not treated.

\sphinxAtStartPar
You can switch this mode on by setting \sphinxcode{\sphinxupquote{istar\_sphere=1}} in the
file \sphinxcode{\sphinxupquote{radmc3d.inp}}. Note that no limb darkening or brightening is
included in this mode, and currently RADMC\sphinxhyphen{}3D does not have such a mode
available.

\sphinxAtStartPar
This mode is, however, somewhat complex. A sphere can partly overlap the
grid, while being partly outside the grid. A sphere can also overlap
multiple cells at the same time, engulfing some cells entirely, while only
partly overlapping others. The correct and fast treatment of this makes
the code a bit slower, and required some complex programming. So the user
is at the moment advised to use this mode only if necessary and remain
aware of possible errors for now (as of version 0.17).

\sphinxAtStartPar
For the Monte Carlo simulations the finite star size means that photon
packages are emitted from the surface of the sphere of the star. It also
means that any photon that re\sphinxhyphen{}enters the star during the Monte Carlo
simulation is assumed to be lost.


\section{Distributions of zillions of stars}
\label{\detokenize{stars:distributions-of-zillions-of-stars}}\label{\detokenize{stars:sec-distrib-of-stars}}
\sphinxAtStartPar
For models of galaxies it is important to be able to have distributed
stellar sources instead of individual stars. The way to implement this
in a model for RADMC\sphinxhyphen{}3D is to
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Prepare one or more \sphinxstyleemphasis{template stellar spectra} \(S^{*}_{i,\nu}\), for instance, one for each
stellar type you wish to include. These must be specified in the file
\sphinxcode{\sphinxupquote{stellarsrc\_templates.inp}} (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-stellarsrc-templates}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (optional): stellarsrc\_templates.inp}}}}). The format for each template stellar
spectrum is:
\begin{equation*}
\begin{split}S^{*}_\nu = \frac{L^{*}_\nu}{4\pi M_{*}}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(L^{*}_\nu\) is the luminosity spectrum of the star in
units of \(\mathrm{erg}\; \mathrm{s}^{-1} \mathrm{Hz}^{-1}\) and \(M_{*}\) is
the mass of the star. Of course the more templates you have, the
more memory consuming it becomes, which is of particular concern for models
on large grids. You can of course also take a sum of various stellar types as
a template. For instance, if we wish to include a ‘typical’ bulge stellar
component, then you do not need to treat each stellar type of bulge stars
separately. You can take the ‘average spectrum per gram of average star’ as
the template and thus save memory.

\item {} 
\sphinxAtStartPar
For each template you must specify the \sphinxstyleemphasis{spatial distribution},
i.e. how many stars of each template star are there per unit volume in
each cell. The stellar density \(\rho_{*}\) is, in fact, given as gram\sphinxhyphen{}of\sphinxhyphen{}star/cm\(^3\)
(i.e. not as number density of stars \(N_{*}\)). In other words: \(\rho_{*}=N_{*}M_{*}\).
The stellar spatial densities
are specified in the file \sphinxcode{\sphinxupquote{stellarsrc\_density.inp}} (see
Section {\hyperref[\detokenize{inputoutputfiles:sec-stellarsrc-density}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (optional): stellarsrc\_density.inp}}}}).

\end{enumerate}

\sphinxAtStartPar
The emissivity of each stellar population is then:
\begin{equation*}
\begin{split}j^{*}_\nu = \rho_{*} S^{*}_\nu\end{split}
\end{equation*}
\sphinxAtStartPar
where \(j^{*}_\nu\) is in units of \(\mathrm{erg}\; \mathrm{s}^{-1} \mathrm{cm}^{-3} \mathrm{Hz}^{-1} \mathrm{steradian}^{-1}\), i.e., it is
the usual emissivity function for the radiative transfer equation \(dI_\nu/ds = j_\nu - \rho\kappa_\nu I_\nu\).

\sphinxAtStartPar
Note that if you have a file \sphinxcode{\sphinxupquote{stellarsrc\_templates.inp}} in your
model directly, then the stellar sources are automatically switched on.
If you do not want to use them, then you must delete this file.

\sphinxAtStartPar
The smooth stellar source distributions are nothing else than source
functions for the radiative transfer with the spectral shape of the template
stellar spectra from the \sphinxcode{\sphinxupquote{stellarsrc\_templates.inp}}.  You will
see that if you make a spectrum of your object, then even if the dust
temperature etc is zero everywhere, you still see a spectrum: that of the
stellar template(s). In the Monte Carlo simulations these stellar templates
act as net sources of photons, that subsequently move through the grid in a
Monte Carlo way.

\sphinxAtStartPar
Note that the smooth stellar source distributions assume that the zillions
of stars that they represent are so small that they do not absorb any
appreciable amount of radiation. They are therefore pure sources, not sinks.


\section{The interstellar radiation field: external source of energy}
\label{\detokenize{stars:the-interstellar-radiation-field-external-source-of-energy}}\label{\detokenize{stars:sec-external-source}}
\sphinxAtStartPar
You can include an \sphinxstyleemphasis{isotropic} interstellar radiation field in
RADMC\sphinxhyphen{}3D. This will take effect both in the making of spectra and images, as
well as in the Monte Carlo module.

\sphinxAtStartPar
The way to activate this is to make a file \sphinxcode{\sphinxupquote{external\_source.inp}}
and fill it with the information needed (see Section {\hyperref[\detokenize{inputoutputfiles:sec-ext-src-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (optional): external\_source.inp}}}}).


\subsection{Role of the external radiation field in Monte Carlo simulations}
\label{\detokenize{stars:role-of-the-external-radiation-field-in-monte-carlo-simulations}}
\sphinxAtStartPar
For the Monte Carlo simulations this means that photons may be launched from
outside inward. The way that this is done is that RADMC\sphinxhyphen{}3D will make a
sphere around the entire grid, just large enough to fit in the entire grid
but not larger. Photon packages can freely leave this sphere. But if
necessary, photon packages can be launched from this sphere inward.
RADMC\sphinxhyphen{}3D will then calculate the total luminosity of this sphere, which is
\(L=4\pi^2 I r_{\mathrm{sphere}}^2\) where \(I\) is the intensity. For
monochromatic Monte Carlo it is simply \(I=I_\nu\), while for the thermal
Monte Carlo it is \(I=\int_0^\infty I_\nu d\nu\), where \(I_\nu\) is the
intensity as specified in the file \sphinxcode{\sphinxupquote{external\_source.inp}}.  Note
that if the sphere would have been taken larger, then the luminosity of the
external radiation field would increase. This may seem anti\sphinxhyphen{}intuitive. The
trick, however, is that if the sphere is larger, then also more of these
interstellar photons never enter the grid and are lost immediately. That is
why it is so important that RADMC\sphinxhyphen{}3D makes the sphere as small as possible,
so that it limits the number of lost photon packages. It also means that you,
the user, would make the grid much larger than the object you are interested
in, then RADMC\sphinxhyphen{}3D is forced to make a large sphere, and thus potentially
many photons will get lost: they may enter the outer parts of the grid, but
there they will not get absorbed, nor will they do much.

\sphinxAtStartPar
In fact, this is a potential difficulty of the use of the external sources:
since the photon packages are lauchned from outside\sphinxhyphen{}inward, it may happen that
only few of them will enter in the regions of the model that you, the user, are
interested in. For instance, you are modeling a 3\sphinxhyphen{}D molecular cloud complex with
a few dense cold starless cores. Suppose that no stellar sources exist in this
model, only the interstellar radiation field. The temperature in the centers of
these starless cores will be determined by the interstellar radiation field. But
since the cores are very small compared to the total model (e.g. you have used
AMR to refine the grid around/in these cores), the chance of each external
photon package to ‘hit’ the starless core is small. It means that the larger the
grid or the smaller the starless core, the more photon packages (\sphinxcode{\sphinxupquote{nphot}},
see Section {\hyperref[\detokenize{dustradtrans:sec-dust-thermal-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{The thermal Monte Carlo simulation: computing the dust temperature}}}}) one must use to make sure that
at least some of them enter the starless cores. If you choose \sphinxcode{\sphinxupquote{phot}} too small
in this case, then the temperature in these cores would remain undetermined
(i.e. they will be zero in the results).


\subsection{Role of the external radiation field in images and spectra}
\label{\detokenize{stars:role-of-the-external-radiation-field-in-images-and-spectra}}
\sphinxAtStartPar
The interstellar radiation field also affects the images and spectra that
you make. Every ray will start at minus\sphinxhyphen{}infinity with the intensity given by
the external radiation field, instead of 0 as it would be if no external
radiation field is specified. If you make an image, the background of your
object will then therefore not be black. You can even make silhouette images
like those of the famous silhouette disks in Orion.

\sphinxAtStartPar
But there is a danger: if you make spectra, then also the background
radiation is inside the beam, and will thus contribute to the spectrum.
In fact, the larger you make the beam the more you will pick up of the
background. This could thus lead to the spectrum of your source to be
swamped by the background if you do not specify a beam in the spectrum.


\section{Internal heat source}
\label{\detokenize{stars:internal-heat-source}}\label{\detokenize{stars:sec-internal-source}}
\sphinxAtStartPar
Sometimes the gas and dust inside the object of interest gets heated up by
some internal process such as friction, magnetic reconnection, chemical
reactions, etc. A nice example is the ‘viscous heating’ inside an
accretion disk. This net heat source can be included in RADMC\sphinxhyphen{}3D by creating
a file \sphinxcode{\sphinxupquote{heatsource.inp}}. The format of the file is described in
Section {\hyperref[\detokenize{inputoutputfiles:sec-heatsource}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (optional): heatsource.inp}}}}. It is the same as for other scalar fields.

\sphinxAtStartPar
With this input file you have to specify in each cell how much energy per
second per cubic centimeter is released in the form of heat. This energy
will then be emitted as radiation by the dust. The way the code does this in
the Bjorkman \& Wood algorithm is that it will launch photon packages from
these cells. The difference with the stellar energy input (see Section
{\hyperref[\detokenize{stars:sec-distrib-of-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{Distributions of zillions of stars}}}}) is that the energy is first injected into the
dust of the cell, and then emitted as thermal dust emission. The launching
of the photon package is therefore always a thermal dust emission. In
contrast, in the stellar energy input method of Section
{\hyperref[\detokenize{stars:sec-distrib-of-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{Distributions of zillions of stars}}}} the photon package is launched directly, with a
wavelength randomly drawn from the local stellar spectrum shape. The
difference between these two methods will be most apparent for optically
thin models. For very optically thick cases, where the heat source is
released deep inside an optically thick object, both methods will
presumably yield the same result. Nevertheless, it is recommended to
use the heat source method for cases such as chemical or viscous heating
of the gas and dust, even for optically thick cases.

\sphinxAtStartPar
A note of caution: in spite of the fact that this heat source method allows
you to add additional energy sources, the object of study must still be in
local thermodynamic equilibrium (LTE). If the gas+dust mixture is flowing
and experiences significant adiabatic heating and cooling events, then the
LTE condition is no longer met and RADMC\sphinxhyphen{}3D will not be able to give
reliable answers. Sometimes one may be able to fudge this in some clever
way, but one should always be aware that strictly speaking the Bjorkman \&
Wood Monte Carlo method only works if in each cell all energy input (be it
radiative absorption or an internal heat source) is balanced exactly by the
same amount of radiative energy output. The algorithm  computes
the dust temperature on that assumption: it computes how much energy the
cell gains (by the heat source or by absorbing photons) and then it requires
that the temperature of the dust is such that precisely the same amount of
radiative energy is emitted.


\subsection{Slow performance of RADMC\sphinxhyphen{}3D with heat source}
\label{\detokenize{stars:slow-performance-of-radmc-3d-with-heat-source}}
\sphinxAtStartPar
For very optically thick models, such as the inner regions of actively
accreting dusty protoplanetary disks, the use of this heat source can lead
to extremely slow performance. The reason is that all photons originating
from this heat source will start their journey right in the middle of the
most optically thick regions, requiring these photons to make gazillions of
absorption/re\sphinxhyphen{}emission events before finally diffusing out. It should in
principle work if the code runs long enough. But one must have some
patience. The use of the Modified Random Walk method (see Section
{\hyperref[\detokenize{dustradtrans:sec-modrandwalk}]{\sphinxcrossref{\DUrole{std,std-ref}{Modified Random Walk method for high optical depths}}}}) would then be useful to speed things up, but still it
can take time.

\sphinxAtStartPar
A few things might be useful to consider. One is that protoplanetary disks
only have such insane optical depths (\(\tau\gtrsim 10^5\)) if none of the
dust has coagulated to bigger grains. This might be the correct assumption,
especially in the very early phases of protoplanetary disk evolution. But
dust coagulation is known to be quick, so it might equally well be that,
say, 90\% of the small grain dust has already grown to larger grains, which
have less opacity. This is of course just a pure guess. Another thing is
that many MHD models of disk turbulence show that most of the energy is
not released near the midplane, but instead at one or two scale heights
above the midplane. Both considerations would lower the optical depth for
the energy to get out of the disk, speeding up the calculation. And
the outcoming spectrum or image it will presumably not be affected that
much, because at the end of the day the effective temperature of the disk
surface must anyway be such that it radiates away the internal heat,
independent of how deep inside the disk this heat is released.

\sphinxstepscope


\chapter{Modifying RADMC\sphinxhyphen{}3D: Internal setup and user\sphinxhyphen{}specified radiative processes}
\label{\detokenize{internalsetup:modifying-radmc-3d-internal-setup-and-user-specified-radiative-processes}}\label{\detokenize{internalsetup:chap-internal-setup}}\label{\detokenize{internalsetup::doc}}
\sphinxAtStartPar
It has been mentioned several times before that as an alternative to the
standard \sphinxtitleref{compile once\sphinxhyphen{}and\sphinxhyphen{}for\sphinxhyphen{}all’ philosophy, one can also use RADMC\sphinxhyphen{}3D by
modifying the code directly so that \textasciigrave{}\textasciigrave{}radmc3d\textasciigrave{}} will have new
functionality that might be of use for you. We refer to Section
{\hyperref[\detokenize{installation:sec-special-purpose-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Making special\sphinxhyphen{}purpose modified versions of RADMC\sphinxhyphen{}3D (optional)}}}} for an in\sphinxhyphen{}depth description of how to
modify the code in a way that is \sphinxstyleemphasis{non\sphinxhyphen{}invasive} to the main code. We
urge the reader to read Section {\hyperref[\detokenize{installation:sec-special-purpose-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Making special\sphinxhyphen{}purpose modified versions of RADMC\sphinxhyphen{}3D (optional)}}}} first
before continuing to read this chapter. In all of the following we assume
that the editings to the fortran files are done in the local way described
in Section {\hyperref[\detokenize{installation:sec-special-purpose-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Making special\sphinxhyphen{}purpose modified versions of RADMC\sphinxhyphen{}3D (optional)}}}} so that the original source
files in the \sphinxcode{\sphinxupquote{src/}} directory stay unaffected, and only local
copies are edited.


\section{Setting up a model \sphinxstyleemphasis{inside} of RADMC\sphinxhyphen{}3D}
\label{\detokenize{internalsetup:setting-up-a-model-inside-of-radmc-3d}}
\sphinxAtStartPar
The most common reason for editing the code itself is for setting up the
model \sphinxstyleemphasis{internally} rather than reading in all data via input files. For
a list of advantages and disadvantages of setting models up internally as
opposed to the standard way, see Section {\hyperref[\detokenize{internalsetup:sec-internalsetup-proscons}]{\sphinxcrossref{\DUrole{std,std-ref}{Some caveats and advantages of internal model setup}}}}
below. Setting up a model within RADMC\sphinxhyphen{}3D is done by making a local copy of
the file \sphinxcode{\sphinxupquote{userdef\_module.f90}} and editing it (see Section
{\hyperref[\detokenize{installation:sec-special-purpose-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Making special\sphinxhyphen{}purpose modified versions of RADMC\sphinxhyphen{}3D (optional)}}}}). This file contains a set of standard
subroutines that are called by the main program at special points in the
code. Each subroutine has a special purpose which will be described below.
By keeping a subroutine empty, nothing is done. By filling it with your own
code lines, you can set up the density, temperature or whatever needs to be
set up for the model. In addition to this you can do the following as well:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Add new variables or arrays in the module header (above the \sphinxcode{\sphinxupquote{contains}}
command), which you can use in the subroutines of the \sphinxcode{\sphinxupquote{userdef\_module.f90}}
module. You are completely free to add any new variables you like. A small
tip: it may be useful (though not required) to start all their names with
e.g. \sphinxcode{\sphinxupquote{userdef\_}} to make sure that no name conflicts with other variables in
the code happen.

\item {} 
\sphinxAtStartPar
Add new subroutines at will (below the \sphinxcode{\sphinxupquote{contains}} command) which you can
call from within the standard subroutines.

\item {} 
\sphinxAtStartPar
Introduce your own \sphinxcode{\sphinxupquote{radmc3d}} command\sphinxhyphen{}line options (see Section
{\hyperref[\detokenize{internalsetup:sec-predef-userdef}]{\sphinxcrossref{\DUrole{std,std-ref}{The pre\sphinxhyphen{}defined subroutines of the userdef\_module.f90}}}}).

\item {} 
\sphinxAtStartPar
Introduce your own \sphinxcode{\sphinxupquote{radmc3d.inp}} namelist variables (see Section
{\hyperref[\detokenize{internalsetup:sec-predef-userdef}]{\sphinxcrossref{\DUrole{std,std-ref}{The pre\sphinxhyphen{}defined subroutines of the userdef\_module.f90}}}}).

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{dataflow-basic-userdef}.pdf}
\caption{Pictographic representation of the dataflow for the case when you define your
model \sphinxstyleemphasis{internally} using the \sphinxcode{\sphinxupquote{userdef\_module.f90}}.}\label{\detokenize{internalsetup:id1}}\label{\detokenize{internalsetup:fig-dataflow-basic-userdef}}\end{figure}

\sphinxAtStartPar
Often you still want some of the input data to be still read in in the usual
way, using input files. For instance, you may want to still read the
\sphinxcode{\sphinxupquote{dustopac.inp}} and the opacities using the \sphinxcode{\sphinxupquote{dustkappa\_xxx.inp}} files. This
is all possible. Typically, you simply keep the files you still want RADMC\sphinxhyphen{}3D to
read, and omit the files that contain data that you allocate and set in the
\sphinxcode{\sphinxupquote{userdef\_module.f90}}. This is all a bit complicated, so the best way to
learn how to do this is to start from the example directories in which a model
is set up with the \sphinxcode{\sphinxupquote{userdef\_module.f90}} method.

\sphinxAtStartPar
In Fig. \hyperref[\detokenize{internalsetup:fig-dataflow-basic-userdef}]{Fig.\@ \ref{\detokenize{internalsetup:fig-dataflow-basic-userdef}}} the dataflow for the user\sphinxhyphen{}defined
model setup is graphically depicted.


\section{The pre\sphinxhyphen{}defined subroutines of the userdef\_module.f90}
\label{\detokenize{internalsetup:the-pre-defined-subroutines-of-the-userdef-module-f90}}\label{\detokenize{internalsetup:sec-predef-userdef}}
\sphinxAtStartPar
The idea of the \sphinxcode{\sphinxupquote{userdef\_module.f90}} is that it contains a number of standard
pre\sphinxhyphen{}defined subroutines that are called from the \sphinxcode{\sphinxupquote{main.f90}} code (and \sphinxstyleemphasis{only}
from there). Just browse through the \sphinxcode{\sphinxupquote{main.f90}} file and search for the
sequence \sphinxcode{\sphinxupquote{calluserdef\_}} and you will find all the points where these standard
routines are called. It means that at these points you as the user have
influence on the process of model setup. Here is the list of standard routines
and how they are used. They are ordered roughly in chronological order in which
they are called.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{userdef\_defaults()}}

\sphinxAtStartPar
This subroutine allows you to set the default value of any new parameters you
may have introduced. If neither on the command line nor in the \sphinxcode{\sphinxupquote{radmc3d.inp}}
file the values of these parameters are set, then they will simply retain this
default value.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{userdef\_commandline(buffer,numarg,iarg,fromstdi,gotit)}}

\sphinxAtStartPar
This subroutine allows you to add your own command\sphinxhyphen{}line options for
\sphinxcode{\sphinxupquote{radmc3d}}. The routine has a series of standard arguments which you are
not allowed to change. The \sphinxcode{\sphinxupquote{buffer}} is a string containing the current
command line option that is parsed. You will check here if it is an option of
your module, and if yes, activate it.  An example is listed in the code. You
an also require a second argument, for which also an example is listed in the
original code.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{userdef\_commandline\_postprocessing()}}

\sphinxAtStartPar
After the command line options have been read, it can be useful to check if
the user has not asked for conflicting things. Here you can do such checks.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{userdef\_parse\_main\_namelist()}}

\sphinxAtStartPar
Here you can add your own namelist parameters that read from the
\sphinxcode{\sphinxupquote{radmc3d.inp}} file. An example is provided in the original code.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{userdef\_main\_namelist\_postprocessing()}}

\sphinxAtStartPar
Also here, after the entire \sphinxcode{\sphinxupquote{radmc3d.inp}} file has been read and
interpreted, you can do some consistency checks and postprocessing here.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{userdef\_prep\_model()}}

\sphinxAtStartPar
This routine can be used if you wish to set up the grid not from input files
but internally. You will have to know how to deal with the \sphinxcode{\sphinxupquote{amr\_module.f90}}
module. You can also set your own global frequency grid here. And finally, you
can set your own stellar sources here. In all cases, if you set these things
here (which requires you to make the proper memory allocations, or in case of
the gridding, let the \sphinxcode{\sphinxupquote{amr\_module.f90}} do the memory allocations for you)
the further course of \sphinxcode{\sphinxupquote{radmc3d}} will skip any of its own settings (it will
simply detect if these arrays are allocated already, and if yes, it will
simply not read or allocate them anymore).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{userdef\_setup\_model()}}

\sphinxAtStartPar
This is the place where you can actually make your own model setup.  By the
time this subroutine is called, all your parameters have been read in, as well
as all of the other parameters from the original \sphinxcode{\sphinxupquote{radmc3d}} code. So you can
now set up the dust density, or the gas velocity or you name it. For all of
these things you will have to allocate the arrays youself (!!!). Once you did
this, the rest of the \sphinxcode{\sphinxupquote{radmc3d}} code won’t read those data anymore, because
it detects that the corresponding arrays have already been allocated (by
you). This allows you to completely circumvent the reading of any of the
following files by making these data yourself here at this location:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{amr\_grid.inp}} or in the future the input files for any of the other griding types.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dust\_density.inp}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dust\_temperature.dat}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gas\_density.inp}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gas\_temperature.inp}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gas\_velocity.inp}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{microturbulence.inp}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{levelpop\_XXX.dat}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{numberdens\_XXX.inp}}

\end{itemize}

\sphinxAtStartPar
To learn how to set up a model in this way, we refer you for now to the
\sphinxcode{\sphinxupquote{ioput\_module.f90}} or \sphinxcode{\sphinxupquote{lines\_module.f90}} and search for the above file
names to see how the arrays are allocated and how the data are inserted. I
apologise for not explaining this in more detail at this point. But examples
are or will be given in the \sphinxcode{\sphinxupquote{examples/}} directory.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{userdef\_dostuff()}}

\sphinxAtStartPar
This routine will be called by the main routine to allow you to do any kind of
calculation after the main calculation (for instance after the monte carlo
simulation). This is done within the execution\sphinxhyphen{}loop.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{userdef\_compute\_levelpop()}}

\sphinxAtStartPar
This is a subroutine that can be called by the camera module for
on\sphinxhyphen{}the\sphinxhyphen{}fly calculation of level populations according to your own recipe.
This may be a bit tricky to use, but I hope to be able to provide some
example(s) in the near future.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{userdef\_srcalp()}}

\sphinxAtStartPar
This subroutine allows you to add any emission/absorption process you
want, even fake ones. For instance, you could use this to create nicely
volume\sphinxhyphen{}rendered images of your 3\sphinxhyphen{}D models with fake opacities, which are
chosen to make the image look nice and/or insight\sphinxhyphen{}giving.  You can also
use this to add physical processes that are not yet implemented in
RADMC\sphinxhyphen{}3D. This subroutine allows you full freedom and flexibility to
add emissivity and extinction whereever/however you like. To activate
it you must set \sphinxcode{\sphinxupquote{incl\_userdef\_srcalp=1}} in the
\sphinxcode{\sphinxupquote{radmc3d.inp}} file.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{userdef\_writemodel()}}

\sphinxAtStartPar
This allows the user to dump any stuff to file that the user computed
in this module. You can also use this routine to write out files that would
have been used normally as input file (like \sphinxcode{\sphinxupquote{amr\_grid.inp}} or
\sphinxcode{\sphinxupquote{dust\_density.inp}}) so that the Python routines can read them if
they need. In particular the grid information may be needed by these
external analysis tools. Here is a list of standard subroutines you can
call for writing such files:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{write\_grid\_file()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{write\_dust\_density()}}

\item {} 
\sphinxAtStartPar
…more to come…

\end{itemize}

\end{itemize}

\sphinxAtStartPar
For now this is it, more routines will be included in the future.

\sphinxAtStartPar
Note that the \sphinxcode{\sphinxupquote{userdef\_compute\_levelpop()}} subroutine, in contrast to all the
others, is called not from the \sphinxcode{\sphinxupquote{main.f90}} program but from the
\sphinxcode{\sphinxupquote{camera\_module.f90}} module. This is why the camera module is the only module
that is higher in compilation ranking than the userdef module (i.e. the userdef
module will be compiled before the camera module). For this reason the userdef
module has no access to the variables of the camera module. For the rest, the
userdef module has access to the variables in all other modules.

\sphinxAtStartPar
Note also that not all input data is meant to be generated in this way. The
following types of data are still supposed to be read from file:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Dust opacity data

\item {} 
\sphinxAtStartPar
Molecular fundamental data

\end{itemize}

\sphinxAtStartPar
Please have a look in the \sphinxcode{\sphinxupquote{examples/}} directory for models
which are set up in this internal way.


\section{Some caveats and advantages of internal model setup}
\label{\detokenize{internalsetup:some-caveats-and-advantages-of-internal-model-setup}}\label{\detokenize{internalsetup:sec-internalsetup-proscons}}
\sphinxAtStartPar
Setting up the models internally has several advantages as well as
disadvantages compared to the standard way of feeding the models into
\sphinxcode{\sphinxupquote{radmc3d}} via files. The advantages are, among others:
\begin{itemize}
\item {} 
\sphinxAtStartPar
You can modify the model parameters in \sphinxcode{\sphinxupquote{radmc3d.inp}} and/or in the command
line options (depending on how you allow the user to set these parameters,
i.e. in the \sphinxcode{\sphinxupquote{userdef\_parse\_main\_namelist()}} routine and/or in the
\sphinxcode{\sphinxupquote{userdef\_commandline()}} routine. You then do not need to run Python anymore
(except for setting up the basic files; see examples). Some advantages of
this:
\begin{itemize}
\item {} 
\sphinxAtStartPar
It allows you, for instance, to create a version of the \sphinxcode{\sphinxupquote{radmc3d}} code
that acts as if it is a special\sphinxhyphen{}purpose model. You can specify model
parameters on the command line (rather than going through the cumbersome
Python stuff).

\item {} 
\sphinxAtStartPar
It is faster: even a large model is built up quickly and does not
require a long read from large input files.

\end{itemize}

\item {} 
\sphinxAtStartPar
You can make use of the AMR module routines such as the
\sphinxcode{\sphinxupquote{amr\_branch\_refine()}} routine, so you can adaptively refine the grid while
you are setting up the model.

\end{itemize}

\sphinxAtStartPar
Some of the disadvantages are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The model needs to be explicitly written out to file and read into Python or
any other data plotting package before you can analyze the density structure
to test if you’ve done it right. You can explicitly ask \sphinxcode{\sphinxupquote{./radmc3d}} to call
the \sphinxcode{\sphinxupquote{userdef\_writemodel()}} subroutine (which is supposed to be writing out
all essential data; but that is the user’s responsibility) by typing
\sphinxcode{\sphinxupquote{./radmc3dwritemodel}}.

\item {} 
\sphinxAtStartPar
Same is true for the grid, and this is potentially even more dangerous if not
done. You can explicitly ask \sphinxcode{\sphinxupquote{./radmc3d}} to write out the grid file by
typing \sphinxcode{\sphinxupquote{./radmc3dwritegridfile}}.  Note that if you call the
\sphinxcode{\sphinxupquote{write\_grid\_file()}} subroutine from within \sphinxcode{\sphinxupquote{userdef\_writemodel()}}, then
you do not have to explicitly type \sphinxcode{\sphinxupquote{./radmc3dwritegridfile}} as well.  Note
also that \sphinxcode{\sphinxupquote{radmc3d}} will automatically call the \sphinxcode{\sphinxupquote{write\_grid\_file()}}
subroutine when it writes the results of the thermal Monte Carlo computation,
if it has its grid from inside (i.e. it has not read the grid from the file
\sphinxcode{\sphinxupquote{amr\_grid.inp}}.

\item {} 
\sphinxAtStartPar
It requires a bit more knowledge of the internal workings of the \sphinxcode{\sphinxupquote{radmc3d}}
code, as you will need to directly insert code lines in the
\sphinxcode{\sphinxupquote{userdef\_module.f90}} file.

\end{itemize}


\section{Using the userdef module to compute integrals of \protect\(J_\nu\protect\)}
\label{\detokenize{internalsetup:using-the-userdef-module-to-compute-integrals-of-j-nu}}\label{\detokenize{internalsetup:sec-compute-radiation-integrals}}
\sphinxAtStartPar
With the monochromatic Monte Carlo computation (see Section
{\hyperref[\detokenize{dustradtrans:sec-dust-monochromatic-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Special\sphinxhyphen{}purpose feature: Computing the local radiation field}}}}) we can calculate the mean intensity
\(J_\nu\) at every location in the model at a user\sphinxhyphen{}defined set of
wavelengths. However, as mentioned before, for large models and large numbers of
wavelengths this could easily lead to a data volume that is larger than what the
computer can handle. Since typically the main motivation for computing
\(J_\nu\) is to compute some integral of the the form:
\begin{equation*}
\begin{split}Q = \int_0^{\infty} J_\nu K_\nu d\nu\end{split}
\end{equation*}
\sphinxAtStartPar
where \(K_\nu\) is some cross section function or so, it may not be
necessary to store the entire function \(J\) as a function of \(nu\).
Instead we would then only by interested in the result of this integral
at each spatial location.

\sphinxAtStartPar
So it would be useful to allow the user to do this computation internally.  We
should start by initializing \(Q(x,y,z)=0\) (or \(Q(r,\theta,\phi)=0\)
if you use spherical coordinates). Then we call the monochromatic Monte Carlo
routine for the first wavelength we want to include, and multiply the resulting
mean intensities with an appropriate \(\Delta\nu\) and add this to
\(Q(x,y,z)\). Then we do the monochromatic Monte Carlo for the next
wavelength and again add to \(Q\) everywhere. We repeat this until our
integral (at every spatial location on the grid) is finished, and we are
done. This saves a huge amount of memory.

\sphinxAtStartPar
Since this is somewhat hard to explain in this PDF document, we refer to
the example model \sphinxcode{\sphinxupquote{run\_example\_jnu\_integral/}}.

\sphinxAtStartPar
\sphinxstyleemphasis{STILL IN PROGRESS.}


\section{Some tips and tricks for programming user\sphinxhyphen{}defined subroutines}
\label{\detokenize{internalsetup:some-tips-and-tricks-for-programming-user-defined-subroutines}}
\sphinxAtStartPar
Apart from the standard subroutines that \sphinxstyleemphasis{must} be present in the
\sphinxcode{\sphinxupquote{userdef\_module.f90}} file (see Section {\hyperref[\detokenize{internalsetup:sec-predef-userdef}]{\sphinxcrossref{\DUrole{std,std-ref}{The pre\sphinxhyphen{}defined subroutines of the userdef\_module.f90}}}}), you are
free to add any subroutines or functions that you want, which you can call from
within the predefined subroutines of Section {\hyperref[\detokenize{internalsetup:sec-predef-userdef}]{\sphinxcrossref{\DUrole{std,std-ref}{The pre\sphinxhyphen{}defined subroutines of the userdef\_module.f90}}}}. You are
completely free to expand this module as you wish. You can add your own
variables, your own arrays, allocate arrays, etc.

\sphinxAtStartPar
Sometimes you may need to know ‘where you are’ in the grid. For instance, the
subroutine \sphinxcode{\sphinxupquote{userdef\_compute\_levelpop()}} is called with an argument \sphinxcode{\sphinxupquote{index}}. This is the index of the current cell from within which the subroutine has
been called. You can now address, for instance, the dust temperature at this
location:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temp} \PYG{o}{=} \PYG{n}{dusttemp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{index}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
(for the case of a single dust species). You may also want to know the
coordinates of the center of the cell. For this, you must first get a pointer to
the AMR\sphinxhyphen{}tree structure of this cell. The pointer \sphinxcode{\sphinxupquote{b}} is declared as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{amr\PYGZus{}branch}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pointer} \PYG{p}{:}\PYG{p}{:} \PYG{n}{b}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then you can point the pointer to that cell structure

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{amr\PYGZus{}index\PYGZus{}to\PYGZus{}leaf}\PYG{p}{(}\PYG{n}{index}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{n}{link}
\end{sphinxVerbatim}

\sphinxAtStartPar
And now you can get the x,y,z\sphinxhyphen{}coordinates of the center of the cell:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{xc} \PYG{o}{=} \PYG{n}{amr\PYGZus{}finegrid\PYGZus{}xc}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{ixyzf}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{level}\PYG{p}{)}
\PYG{n}{yc} \PYG{o}{=} \PYG{n}{amr\PYGZus{}finegrid\PYGZus{}xc}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{ixyzf}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{level}\PYG{p}{)}
\PYG{n}{zc} \PYG{o}{=} \PYG{n}{amr\PYGZus{}finegrid\PYGZus{}xc}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{ixyzf}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{level}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or the left and right cell walls:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{xi\PYGZus{}l} \PYG{o}{=} \PYG{n}{amr\PYGZus{}finegrid\PYGZus{}xi}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{ixyzf}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{level}\PYG{p}{)}
\PYG{n}{yi\PYGZus{}l} \PYG{o}{=} \PYG{n}{amr\PYGZus{}finegrid\PYGZus{}xi}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{ixyzf}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{level}\PYG{p}{)}
\PYG{n}{zi\PYGZus{}l} \PYG{o}{=} \PYG{n}{amr\PYGZus{}finegrid\PYGZus{}xi}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{ixyzf}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{level}\PYG{p}{)}
\PYG{n}{xi\PYGZus{}r} \PYG{o}{=} \PYG{n}{amr\PYGZus{}finegrid\PYGZus{}xi}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{ixyzf}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{level}\PYG{p}{)}
\PYG{n}{yi\PYGZus{}r} \PYG{o}{=} \PYG{n}{amr\PYGZus{}finegrid\PYGZus{}xi}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{ixyzf}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{level}\PYG{p}{)}
\PYG{n}{zi\PYGZus{}r} \PYG{o}{=} \PYG{n}{amr\PYGZus{}finegrid\PYGZus{}xi}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{ixyzf}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{level}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Creating your own emission and absorption processes}
\label{\detokenize{internalsetup:creating-your-own-emission-and-absorption-processes}}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D Allows you to add your own physics to the ray\sphinxhyphen{}tracing images and
spectra. At every point during the ray\sphinxhyphen{}tracing process, when it computes the
emissivity and extinction coefficients \(j_\nu\) and \(\alpha_\nu\) it
calls the \sphinxcode{\sphinxupquote{userdef\_srcalp()}} subroutine, giving it the \sphinxcode{\sphinxupquote{index}} in which cell
we are, the frequencies of the different image channels and the \sphinxcode{\sphinxupquote{src}} and
\sphinxcode{\sphinxupquote{alp}} arrays which are for resp.\(j_\nu\) and \(\alpha_\nu\). You
can \sphinxstyleemphasis{add} any process by

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{src}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)} \PYG{o}{=} \PYG{n}{src}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)} \PYG{o}{+} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{alp}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)} \PYG{o}{=} \PYG{n}{alp}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)} \PYG{o}{+} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
where …… is your formula. You can find the local variables like
density and temperature using the \sphinxcode{\sphinxupquote{index}}, e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rho\PYGZus{}g} \PYG{o}{=} \PYG{n}{gasdens}\PYG{p}{(}\PYG{n}{index}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can be completely free in your choices. If you need some information
that is not usually read into RADMC\sphinxhyphen{}3D, you can add read commands in the
\sphinxcode{\sphinxupquote{userdef\_setup\_model()}} subroutine, e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{call} \PYG{n}{read\PYGZus{}gas\PYGZus{}density}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
See the example directory \sphinxcode{\sphinxupquote{examples/run\_simple\_userdefsrc}} for
more ideas.

\sphinxstepscope


\chapter{Python analysis tool set}
\label{\detokenize{pythontools:python-analysis-tool-set}}\label{\detokenize{pythontools:chap-python-analysis-tools}}\label{\detokenize{pythontools::doc}}
\sphinxAtStartPar
While the code RADMC\sphinxhyphen{}3D is written in fortran\sphinxhyphen{}90, there is an extensive set
of tools written in Python that make it easier for the user to set up models
and interpret results. See Section {\hyperref[\detokenize{installation:sec-install-pythonscripts}]{\sphinxcrossref{\DUrole{std,std-ref}{Installing the simple Python analysis tools}}}} for where
they are and how they can be properly installed so that they are easy to
use.

\sphinxAtStartPar
The RADMC\sphinxhyphen{}3D package has two support\sphinxhyphen{}libraries:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{python/tools/simpleread.py}}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{python/tools/simpleread.py}} is a set of functions to read the most
important data files used by RADMC\sphinxhyphen{}3D.  However, the \sphinxcode{\sphinxupquote{simpleread.py}} module
is very simple, and does not read all RADMC\sphinxhyphen{}3D files in all formats. It can
therefore only be used for certain (simple) models, and is primarily useful
as a didactical tool.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{python/radmc3dPy}}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{radmc3dPy}} package is a stand\sphinxhyphen{}alone Python package, written by Attila
Juhasz, meant for the pre\sphinxhyphen{} and post\sphinxhyphen{}processing of RADMC\sphinxhyphen{}3D files.  It has its
own manual, and has to be installed using e.g.\textasciitilde{}Python’s \sphinxcode{\sphinxupquote{pipinstall}}
method. This is described in the README file in that package.

\end{enumerate}


\section{The simpleread.py library}
\label{\detokenize{pythontools:the-simpleread-py-library}}\label{\detokenize{pythontools:sec-simpleread-tools}}
\sphinxAtStartPar
For the most rudimentary analysis of the output (or input) files of RADMC\sphinxhyphen{}3D you
can use the \sphinxcode{\sphinxupquote{simpleread.py}} file, which you can find in the \sphinxcode{\sphinxupquote{python/tools/}}
directory. If everything has been installed correctly, you should be able to
use it within Python like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{radmc3d\PYGZus{}tools}\PYG{n+nn}{.}\PYG{n+nn}{simpleread} \PYG{k+kn}{import} \PYG{o}{*}
\end{sphinxVerbatim}

\sphinxAtStartPar
Examples of data files you can read:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{read\PYGZus{}dustdens}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{read\PYGZus{}dusttemp}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{read\PYGZus{}image}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{read\PYGZus{}spectrum}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{read\PYGZus{}dustkappa}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{read\PYGZus{}gastemp}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{read\PYGZus{}gasvelocity}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{read\PYGZus{}molnumdens}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{co}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{read\PYGZus{}mollevelpop}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{co}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{read\PYGZus{}subbox}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dust\PYGZus{}temperature}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{read\PYGZus{}subbox}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dust\PYGZus{}density}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Of course each one only if the corresponding file is present. Note that ‘co’ is
just an example molecule. In all these reading functions, except the ones for
images and spectra, the reading function automatically calls:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grid} \PYG{o}{=} \PYG{n}{read\PYGZus{}grid}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
which reads the information about the spatial grid. This is then put inside the
\sphinxcode{\sphinxupquote{d}} object like this: \sphinxcode{\sphinxupquote{d.grid}}.

\sphinxAtStartPar
Here is an example of how you can plot the data (let us take the
\sphinxcode{\sphinxupquote{examples/run\_simple\_1/}} model, after we ran \sphinxcode{\sphinxupquote{radmc3d mctherm}}
and \sphinxcode{\sphinxupquote{radmc3d image incl 60 phi 30 lambda 1000}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{radmc3d\PYGZus{}tools}\PYG{n+nn}{.}\PYG{n+nn}{simpleread} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{import} \PYG{n+nn}{radmc3d\PYGZus{}tools}\PYG{n+nn}{.}\PYG{n+nn}{natconst} \PYG{k}{as} \PYG{n+nn}{nc}
\PYG{n}{tm} \PYG{o}{=} \PYG{n}{read\PYGZus{}dusttemp}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{tm}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{x}\PYG{o}{/}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{au}\PYG{p}{,}\PYG{n}{tm}\PYG{o}{.}\PYG{n}{dusttemp}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x [au]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T [K]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{im} \PYG{o}{=} \PYG{n}{read\PYGZus{}image}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{im}\PYG{o}{.}\PYG{n}{image}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{3e\PYGZhy{}14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Important:} These reading functions are rather basic. At the moment, no binary
file support is included (though this may change), no AMR octree grids can be
read, and several other limitations. For more sophisticated Python tools,
use the radmc3dPy library.

\sphinxAtStartPar
\sphinxstyleemphasis{Note:} For the \sphinxcode{\sphinxupquote{read\_subbox()}} function, you need to read the section
on the creation of regular\sphinxhyphen{}gridded datacubes of your 3D model, which is
Section {\hyperref[\detokenize{toolsinside:sec-subbox}]{\sphinxcrossref{\DUrole{std,std-ref}{Making a regularly\sphinxhyphen{}spaced datacube (‘subbox’) of AMR\sphinxhyphen{}based models}}}}.


\section{The radmc3dPy library}
\label{\detokenize{pythontools:the-radmc3dpy-library}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{radmc3dPy}} library is a sophisticated Python library that you
can use for the in\sphinxhyphen{}depth analysis of the output (or input) files of RADMC\sphinxhyphen{}3D.
It supports most in/output formats of RADMC\sphinxhyphen{}3D, including octree grids,
binary file formats etc.

\sphinxAtStartPar
The package is stand\sphinxhyphen{}alone, and has its own bitbucket repository:

\sphinxAtStartPar
\sphinxurl{https://bitbucket.org/at\_juhasz/radmc3dpy/}

\sphinxAtStartPar
But you can find a copy of this package also inside the RADMC\sphinxhyphen{}3D package,
in the directory \sphinxcode{\sphinxupquote{python/radmc3dPy/}}.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{radmc3dPy}} package has its own manual, so we will not reiterate it
here. Instead, please simply open the html manual in that package with a
browser. The entry file of that manual is the \sphinxcode{\sphinxupquote{doc/html/index.html}}.  On a
Mac you can simply type \sphinxcode{\sphinxupquote{opendoc/html/index.html}} on the command line when you
are in the \sphinxcode{\sphinxupquote{radmc3dPy}} directory. To install \sphinxcode{\sphinxupquote{radmc3dPy}} please consult the
\sphinxcode{\sphinxupquote{README}} file in the \sphinxcode{\sphinxupquote{radmc3dPy}} directory.

\sphinxAtStartPar
Once it is installed, you can use \sphinxcode{\sphinxupquote{radmc3dPy}} in Python in the following
way:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Make sure to start Python 3 using \{small ipython \textendash{}matplotlib\} if you start
Python from the command line. If you instead use a Jupyter notebook, make
sure that as a first line you use \sphinxcode{\sphinxupquote{\%matplotlib inline}} to get the plots
inside the notebook. These are standard Python things, so if you have
trouble, ask your python friends or system manager.

\item {} 
\sphinxAtStartPar
Once you are inside Python you can include \sphinxcode{\sphinxupquote{radmc3dPy}} using a simple
\sphinxcode{\sphinxupquote{from radmc3dPy import *}}. This loads a series of radmc3dPy sub\sphinxhyphen{}libraries,
including \sphinxcode{\sphinxupquote{analyze}}, \sphinxcode{\sphinxupquote{image}} and several others.

\end{enumerate}

\sphinxAtStartPar
We give here a very concise overview of the \sphinxcode{\sphinxupquote{radmc3dPy}} package.
Please refer to the above mentioned stand\sphinxhyphen{}alone documentation for more details.


\section{Model creation from within radmc3dPy}
\label{\detokenize{pythontools:model-creation-from-within-radmc3dpy}}
\sphinxAtStartPar
Several of the example models of the RADMC\sphinxhyphen{}3D \sphinxcode{\sphinxupquote{examples/}} directory have been
implemented as part of the \sphinxcode{\sphinxupquote{radmc3dPy}} package. This allows you to launch
these models straight from within \sphinxcode{\sphinxupquote{radmc3dPy}}. But this is merely
optional. You can equally well use the models in the \sphinxcode{\sphinxupquote{examples/}} directory in
the RADMC\sphinxhyphen{}3D package, and post\sphinxhyphen{}process the results with \sphinxcode{\sphinxupquote{radmc3dPy}}.

\sphinxAtStartPar
To use one of the \sphinxcode{\sphinxupquote{radmc3dPy}}\sphinxhyphen{}internal models, create a directory
(e.g. \sphinxcode{\sphinxupquote{mymodel}}), go into it, and go into iPython. Then type
\sphinxcode{\sphinxupquote{from radmc3dPy import *}}. By typing \sphinxcode{\sphinxupquote{models.getModelNames()}} you get a list
of available models. Suppose we choose the model ‘ppdisk’, then we would go
about like this (for example):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{radmc3dPy} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{analyze}\PYG{o}{.}\PYG{n}{writeDefaultParfile}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ppdisk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{setup}\PYG{o}{.}\PYG{n}{problemSetupDust}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ppdisk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mdisk}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1e\PYGZhy{}5*ms}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{gap\PYGZus{}rin}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[10.0*au]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{gap\PYGZus{}rout}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[40.*au]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{gap\PYGZus{}drfact}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[1e\PYGZhy{}5]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{nz}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This example will set up a protoplanetary disk model in 2\sphinxhyphen{}D \((r,\theta)\),
with a gap between 10 and 40 au. You can now run RADMC\sphinxhyphen{}3D to compute the dust
temperature structure, by calling (on the Linux shell):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{mctherm}
\end{sphinxVerbatim}

\sphinxAtStartPar
An image can be created with (again on the Lunix shell):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{1000} \PYG{n}{incl} \PYG{l+m+mi}{60}
\end{sphinxVerbatim}

\sphinxAtStartPar
And the image can be displayed (in Python) by

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{cm}
\PYG{k+kn}{from} \PYG{n+nn}{radmc3dPy} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{im}\PYG{o}{=}\PYG{n}{image}\PYG{o}{.}\PYG{n}{readImage}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{image}\PYG{o}{.}\PYG{n}{plotImage}\PYG{p}{(}\PYG{n}{im}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{3e\PYGZhy{}3}\PYG{p}{,}\PYG{n}{au}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}heat}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Diagnostic tools in radmc3dPy}
\label{\detokenize{pythontools:diagnostic-tools-in-radmc3dpy}}
\sphinxAtStartPar
No matter whether you use the \sphinxcode{\sphinxupquote{radmc3dPy}}\sphinxhyphen{}internal model set, or you create
your own model setup, you can use the extensive tool set inside \sphinxcode{\sphinxupquote{radmc3dPy}} to
analyze the model itself, and the results of RADMC\sphinxhyphen{}3D calculations. In
everything below, we assume that you use \sphinxcode{\sphinxupquote{from radmc3dPy import *}} beforehand.


\subsection{Read the \sphinxstyleliteralintitle{\sphinxupquote{amr\_grid.inp}} file}
\label{\detokenize{pythontools:read-the-amr-grid-inp-file}}
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{grid=analyze.readGrid()}} to read the information about the
spatial and wavelength grid.


\subsection{Read all the spatial data}
\label{\detokenize{pythontools:read-all-the-spatial-data}}
\sphinxAtStartPar
Using \sphinxcode{\sphinxupquote{data=analyze.readData()}} you read the entire spatial
structure of the model: The dust density, dust temperature, velocity
etc.


\subsection{Read the \sphinxstyleliteralintitle{\sphinxupquote{image.out}} file}
\label{\detokenize{pythontools:read-the-image-out-file}}
\sphinxAtStartPar
Using \sphinxcode{\sphinxupquote{im=image.readImage()}} you read the \sphinxcode{\sphinxupquote{image.out}}
file created by RADMC\sphinxhyphen{}3D (if you call radmc3d for creating an image).
You can use the \sphinxcode{\sphinxupquote{image.plotImage()}} function to display
the image with the proper axes and color bar.


\subsection{Read the \sphinxstyleliteralintitle{\sphinxupquote{spectrum.out}} file}
\label{\detokenize{pythontools:read-the-spectrum-out-file}}
\sphinxAtStartPar
Any spectrum you create (a file called \sphinxcode{\sphinxupquote{spectrum.out}} can be
read using \sphinxcode{\sphinxupquote{s=analyze.readSpectrum()}}.

\sphinxstepscope


\chapter{Analysis tools inside of radmc3d}
\label{\detokenize{toolsinside:analysis-tools-inside-of-radmc3d}}\label{\detokenize{toolsinside:chap-radmc3d-internal-analysis-tools}}\label{\detokenize{toolsinside::doc}}
\sphinxAtStartPar
There are also some special purpose features in the Fortran\sphinxhyphen{}90 \sphinxcode{\sphinxupquote{radmc3d}} code that can be useful for analyzing complex AMR\sphinxhyphen{}gridded models.


\section{Making a regularly\sphinxhyphen{}spaced datacube (‘subbox’) of AMR\sphinxhyphen{}based models}
\label{\detokenize{toolsinside:making-a-regularly-spaced-datacube-subbox-of-amr-based-models}}\label{\detokenize{toolsinside:sec-subbox}}
\sphinxAtStartPar
Because handling AMR\sphinxhyphen{}based models in Python or other data analysis packages can
be rather cumbersome, we decided that it would be useful to create the
possibility in \sphinxcode{\sphinxupquote{radmc3d}} to generate 1\sphinxhyphen{}D, 2\sphinxhyphen{}D or 3\sphinxhyphen{}D regularly spaced
‘cut\sphinxhyphen{}outs’ or ‘sub\sphinxhyphen{}boxes’ (whatever you want to call them) of any variable of
the model.


\subsection{Creating a subbox}
\label{\detokenize{toolsinside:creating-a-subbox}}
\sphinxAtStartPar
You can call \sphinxcode{\sphinxupquote{radmc3d}} directly from the shell asking it to make
the subbox. Here is an example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{/}\PYG{n}{radmc3d} \PYG{n}{subbox\PYGZus{}dust\PYGZus{}density} \PYG{n}{subbox\PYGZus{}nxyz} \PYG{l+m+mi}{64} \PYG{l+m+mi}{64} \PYG{l+m+mi}{64} \PYG{n}{subbox\PYGZus{}xyz01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e15} \PYG{l+m+mf}{2.e15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e15} \PYG{l+m+mf}{2.e15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e15} \PYG{l+m+mf}{2.e15}
\end{sphinxVerbatim}

\sphinxAtStartPar
which creates a regularly sampled 64x64x64 datacube of the dust density, with \(x\) grid
between \(-2\times 10^{15}\;\mathrm{cm}\) and  \(+2\times 10^{15}\;\mathrm{cm}\) and
likewise for \(y\) and \(z\) (note that these box boundaries are the walls of the
regularly spaced cells of the subbox). The file that this creates is called \sphinxcode{\sphinxupquote{dust\_density\_subbox.out}}
(see section {\hyperref[\detokenize{toolsinside:sec-subbox-file-format}]{\sphinxcrossref{\DUrole{std,std-ref}{Format of the subbox output files}}}} for the format of this file).
For the dust temperature the command is
\sphinxcode{\sphinxupquote{./radmc3d subbox\_dust\_temperature}}, in which case the file is called
\sphinxcode{\sphinxupquote{dust\_temperature\_subbox.out}}.

\sphinxAtStartPar
You can also rotate the box along three angles: \(\phi_1\), \(\theta\),
and \(\phi_2\), for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{/}\PYG{n}{radmc3d} \PYG{n}{subbox\PYGZus{}dust\PYGZus{}temperature} \PYG{n}{subbox\PYGZus{}nxyz} \PYG{l+m+mi}{64} \PYG{l+m+mi}{64} \PYG{l+m+mi}{64} \PYG{n}{subbox\PYGZus{}xyz01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e15} \PYG{l+m+mf}{2.e15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e15} \PYG{l+m+mf}{2.e15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e15} \PYG{l+m+mf}{2.e15} \PYG{n}{subbox\PYGZus{}phi1} \PYG{l+m+mi}{30} \PYG{n}{subbox\PYGZus{}theta} \PYG{l+m+mi}{60}  \PYG{n}{subbox\PYGZus{}phi2} \PYG{l+m+mi}{45}
\end{sphinxVerbatim}

\sphinxAtStartPar
(Note that as of version 2.0 of RADMC\sphinxhyphen{}3D these angles are in degrees instead of radian).
An example for the level populations would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{/}\PYG{n}{radmc3d} \PYG{n}{subbox\PYGZus{}levelpop} \PYG{n}{subbox\PYGZus{}nxyz} \PYG{l+m+mi}{64} \PYG{l+m+mi}{64} \PYG{l+m+mi}{64} \PYG{n}{subbox\PYGZus{}xyz01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e15} \PYG{l+m+mf}{2.e15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e15} \PYG{l+m+mf}{2.e15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e15} \PYG{l+m+mf}{2.e15}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Note about subbox for level populations:} By default all level populations will
be written out. However, if you would add the \sphinxcode{\sphinxupquote{subbox\_levelpop}} keyword in a
call to RADMC\sphinxhyphen{}3D for making an image or spectrum, then it will only write out
the level populations that have been used for that image. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{/}\PYG{n}{radmc3d} \PYG{n}{image} \PYG{k}{lambda} \PYG{l+m+mi}{2600} \PYG{n}{subbox\PYGZus{}levelpop} \PYG{n}{subbox\PYGZus{}nxyz} \PYG{l+m+mi}{64} \PYG{l+m+mi}{64} \PYG{l+m+mi}{64} \PYG{n}{subbox\PYGZus{}xyz01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e15} \PYG{l+m+mf}{2.e15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e15} \PYG{l+m+mf}{2.e15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e15} \PYG{l+m+mf}{2.e15}
\end{sphinxVerbatim}

\sphinxAtStartPar
would give a much smaller \sphinxcode{\sphinxupquote{\textquotesingle{}levelpop\_co\_subbox.out\textquotesingle{}}} file, because only the
first two levels are included (remember that \(\lambda=2600\,\mu\)m is the
J1\sphinxhyphen{}0 line of CO). See Section {\hyperref[\detokenize{lineradtrans:sec-calcstore-levpop}]{\sphinxcrossref{\DUrole{std,std-ref}{Background information: Calculation and storage of level populations}}}} for more information
on how RADMC\sphinxhyphen{}3D automatically selects a subset of levels for storage in the
global array (and thus also for writing out to file).


\subsection{Format of the subbox output files}
\label{\detokenize{toolsinside:format-of-the-subbox-output-files}}\label{\detokenize{toolsinside:sec-subbox-file-format}}
\sphinxAtStartPar
All the files produced by the subbox method have the following format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{2} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{nx} \PYG{n}{ny} \PYG{n}{nz} \PYG{n}{nv}                              \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Box} \PYG{n}{of} \PYG{n}{nx}\PYG{o}{*}\PYG{n}{ny}\PYG{o}{*}\PYG{n}{nz} \PYG{n}{cells}\PYG{p}{,} \PYG{n}{each} \PYG{k}{with} \PYG{n}{nv} \PYG{n}{values}
\PYG{n}{x0} \PYG{n}{x1} \PYG{n}{y0} \PYG{n}{y1} \PYG{n}{z0} \PYG{n}{z1}                        \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{The} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o+ow}{and} \PYG{n}{z} \PYG{n}{boundaries} \PYG{n}{of} \PYG{n}{the} \PYG{n}{box}
\PYG{n}{phi1} \PYG{n}{theta} \PYG{n}{phi2}                          \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Three} \PYG{n}{rotation} \PYG{n}{angles} \PYG{n}{of} \PYG{n}{the} \PYG{n}{box}
                                         \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Empty} \PYG{n}{line}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}                             \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Identifications} \PYG{n}{of} \PYG{n}{the} \PYG{n}{nv} \PYG{n}{values}
                                         \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Empty} \PYG{n}{line}
\PYG{n}{data}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iz}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{data}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iz}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{o}{.}
\PYG{o}{.}
\PYG{n}{data}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{n}{nx}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iz}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{data}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{iz}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{o}{.}
\PYG{o}{.}
\PYG{o}{.}
\PYG{n}{data}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{n}{nx}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{n}{ny}\PYG{p}{,}\PYG{n}{iz}\PYG{o}{=}\PYG{n}{nz}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
                                         \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Empty} \PYG{n}{line} \PYG{n}{between} \PYG{n}{components}
\PYG{n}{data}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iz}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}
\PYG{o}{.}
\PYG{n}{data}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{n}{nx}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{n}{ny}\PYG{p}{,}\PYG{n}{iz}\PYG{o}{=}\PYG{n}{nz}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
                                         \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Empty} \PYG{n}{line} \PYG{n}{between} \PYG{n}{components}
\PYG{o}{.}
\PYG{o}{.}
\PYG{o}{.}
                                         \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Empty} \PYG{n}{line} \PYG{n}{between} \PYG{n}{components}
\PYG{n}{data}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iz}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{n}{nv}\PYG{p}{]}
\PYG{o}{.}
\PYG{o}{.}
\PYG{n}{data}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{n}{nx}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{n}{ny}\PYG{p}{,}\PYG{n}{iz}\PYG{o}{=}\PYG{n}{nz}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{n}{nv}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
and they are always in ascii format. For a subbox of the level populations the
identification numbers are the levels. For instance, if only the populations of
levels 4 and 8 are in this file, then \sphinxcode{\sphinxupquote{nv=2}} and the line with
the identification numbers will be \sphinxcode{\sphinxupquote{48}}. For all other quantities
(dust density, dust temperature) this line of identification numbers is simply
\sphinxcode{\sphinxupquote{123}} etc.


\subsection{Using the \sphinxstyleliteralintitle{\sphinxupquote{radmc3d\_tools}} to read the subbox data}
\label{\detokenize{toolsinside:using-the-radmc3d-tools-to-read-the-subbox-data}}
\sphinxAtStartPar
In Section {\hyperref[\detokenize{pythontools:sec-simpleread-tools}]{\sphinxcrossref{\DUrole{std,std-ref}{The simpleread.py library}}}} a set of simple Python tools are
discussed to read a variety of output files from RADMC\sphinxhyphen{}3D (as well as input
files to RADMC\sphinxhyphen{}3D) for further analysis.

\sphinxAtStartPar
Also for the subbox output there is now a Python function to read those.
Example: First run RADMC\sphinxhyphen{}3D:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{mctherm}
\PYG{n}{radmc3d} \PYG{n}{subbox\PYGZus{}dust\PYGZus{}density} \PYG{n}{subbox\PYGZus{}nxyz} \PYG{l+m+mi}{64} \PYG{l+m+mi}{64} \PYG{l+m+mi}{64} \PYG{n}{subbox\PYGZus{}xyz01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e14} \PYG{l+m+mf}{2.e14} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e14} \PYG{l+m+mf}{2.e14} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e14} \PYG{l+m+mf}{2.e14}
\PYG{n}{radmc3d} \PYG{n}{subbox\PYGZus{}dust\PYGZus{}temperature} \PYG{n}{subbox\PYGZus{}nxyz} \PYG{l+m+mi}{64} \PYG{l+m+mi}{64} \PYG{l+m+mi}{64} \PYG{n}{subbox\PYGZus{}xyz01} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e14} \PYG{l+m+mf}{2.e14} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e14} \PYG{l+m+mf}{2.e14} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.e14} \PYG{l+m+mf}{2.e14}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then go into Python and do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{radmc3d\PYGZus{}tools}\PYG{n+nn}{.}\PYG{n+nn}{simpleread} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{dustdens} \PYG{o}{=} \PYG{n}{read\PYGZus{}subbox}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dust\PYGZus{}density}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{dusttemp} \PYG{o}{=} \PYG{n}{read\PYGZus{}subbox}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dust\PYGZus{}temperature}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{grid}     \PYG{o}{=} \PYG{n}{dustdens}\PYG{o}{.}\PYG{n}{grid}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{n}{rhodustmin} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}18}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(}\PYG{n}{dustdens}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{]}\PYG{o}{+}\PYG{n}{rhodustmin}\PYG{p}{)}\PYG{p}{,}\PYG{n}{extent}\PYG{o}{=}\PYG{p}{[}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{dusttemp}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Alternative to subbox: arbitrary sampling of AMR\sphinxhyphen{}based models}
\label{\detokenize{toolsinside:alternative-to-subbox-arbitrary-sampling-of-amr-based-models}}\label{\detokenize{toolsinside:sec-sampling}}
\sphinxAtStartPar
For some purposes it is useful to sample values of various quantities at
arbitrary positions in the grid. The idea is very much like the subbox
method of Section {\hyperref[\detokenize{toolsinside:sec-subbox}]{\sphinxcrossref{\DUrole{std,std-ref}{Making a regularly\sphinxhyphen{}spaced datacube (‘subbox’) of AMR\sphinxhyphen{}based models}}}}, but instead of a regular subbox grid
the user provides a list of 3\sphinxhyphen{}D points where he/she wants to sample the
variables of the model. Here is how to do this. First you must produce
a file containing the list of 3\sphinxhyphen{}D positions. The file is called
\sphinxcode{\sphinxupquote{sample\_points.inp}} and is an ascii file that looks as
follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{npt}                                      \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Nr} \PYG{n}{of} \PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{sampling} \PYG{n}{points}
\PYG{n}{xpt}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{n}{ypt}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{n}{zpt}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{coordinates} \PYG{n}{of} \PYG{n}{point} \PYG{l+m+mi}{1}
\PYG{n}{xpt}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{n}{ypt}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{n}{zpt}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{coordinates} \PYG{n}{of} \PYG{n}{point} \PYG{l+m+mi}{2}
\PYG{n}{xpt}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}  \PYG{n}{ypt}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}  \PYG{n}{zpt}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{coordinates} \PYG{n}{of} \PYG{n}{point} \PYG{l+m+mi}{3}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
An example for the case in which you want to sample at just one point:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{1}
\PYG{l+m+mf}{1.49}\PYG{n}{d13}   \PYG{l+m+mf}{4.02}\PYG{n}{d14}   \PYG{l+m+mf}{1.03}\PYG{n}{d12}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you want to let RADMC\sphinxhyphen{}3D do the sampling of the dust density and
temperature, type (after you have calculated the temperature using
\sphinxcode{\sphinxupquote{radmc3dmctherm}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{sample}\PYG{o}{\PYGZhy{}}\PYG{n}{dustdens} \PYG{n}{sample}\PYG{o}{\PYGZhy{}}\PYG{n}{dusttemp}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can also do the dust temperature calculation and the sampling in one
go:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{mctherm} \PYG{n}{sample}\PYG{o}{\PYGZhy{}}\PYG{n}{dustdens} \PYG{n}{sample}\PYG{o}{\PYGZhy{}}\PYG{n}{dusttemp}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can also do only \sphinxcode{\sphinxupquote{sample\sphinxhyphen{}dusttemp}} or only \sphinxcode{\sphinxupquote{sample\sphinxhyphen{}dustdens}}. The
output is written to files \sphinxcode{\sphinxupquote{dust\_density\_sample.out}} resp.\sphinxcode{\sphinxupquote{dust\_temperature\_sample.out}}. The format of these files is (take dust
density as example):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{2} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{npt}  \PYG{n}{nv}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Nr} \PYG{n}{of} \PYG{n}{point} \PYG{o+ow}{and} \PYG{n}{size} \PYG{n}{of} \PYG{n}{datavector}
                                         \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Empty} \PYG{n}{line}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}                             \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Identifications} \PYG{n}{of} \PYG{n}{the} \PYG{n}{nv} \PYG{n}{values}
                                         \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Empty} \PYG{n}{line}
\PYG{n}{dustdensity}\PYG{p}{[}\PYG{n}{ipt}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{dustdensity}\PYG{p}{[}\PYG{n}{ipt}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{dustdensity}\PYG{p}{[}\PYG{n}{ipt}\PYG{o}{=}\PYG{n}{npt}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
                                         \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Empty} \PYG{n}{line} \PYG{n}{between} \PYG{n}{components}
\PYG{n}{dustdensity}\PYG{p}{[}\PYG{n}{ipt}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{dustdensity}\PYG{p}{[}\PYG{n}{ipt}\PYG{o}{=}\PYG{n}{npt}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
                                         \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Empty} \PYG{n}{line} \PYG{n}{between} \PYG{n}{components}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
                                         \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Empty} \PYG{n}{line} \PYG{n}{between} \PYG{n}{components}
\PYG{n}{dustdensity}\PYG{p}{[}\PYG{n}{ipt}\PYG{o}{=}\PYG{n}{npt}\PYG{p}{,}\PYG{n}{iv}\PYG{o}{=}\PYG{n}{nv}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{nv}} is in this case the nr of species of dust and
\sphinxcode{\sphinxupquote{iv}}=\textasciigrave{}\textasciigrave{}ispecies\textasciigrave{}\textasciigrave{}.

\sphinxAtStartPar
For a sample of the level populations the identification numbers are the
levels. For instance, if only the populations of levels 4 and 8 are in this
file, then \sphinxcode{\sphinxupquote{nv=2}} and the line with the identification numbers
will be \sphinxcode{\sphinxupquote{48}}. For all other quantities (dust density, dust
temperature) this line of identification numbers is simply \sphinxcode{\sphinxupquote{123}}
etc.

\sphinxAtStartPar
Later we will add other possible arrays to sample (at the moment it is only
dust density, dust temperature and level populations). But you can also
implement this yourself. Search in the following files for the following
parts to add your own sampling:
\begin{itemize}
\item {} 
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{rtglobal\_module.f90}}: Search for \sphinxcode{\sphinxupquote{do\_sample\_dustdens}} and add your
own variable, e.g. \sphinxcode{\sphinxupquote{o\_sample\_myvariable}}.

\item {} 
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{main.f90}}: Search for \sphinxcode{\sphinxupquote{do\_sample\_dustdens}} and you will find all
places where you have to add your own stuff, i.e.  where you will have to add
statements like \sphinxcode{\sphinxupquote{if(do\_sample\_myvariable)}} or where you have to set
\sphinxcode{\sphinxupquote{do\_sample\_myvariable=.true.}} or reset \sphinxcode{\sphinxupquote{do\_sample\_myvariable=.false.}} etc.

\end{itemize}

\sphinxAtStartPar
That should do it.

\sphinxstepscope


\chapter{Visualization with VTK tools (e.g. Paraview or VisIt)}
\label{\detokenize{vtkoutput:visualization-with-vtk-tools-e-g-paraview-or-visit}}\label{\detokenize{vtkoutput:chap-vtk-output}}\label{\detokenize{vtkoutput::doc}}
\sphinxAtStartPar
Since 3\sphinxhyphen{}D models can be very hard to visualize, and since RADMC\sphinxhyphen{}3D is not
made for quick rendering, it can be very useful to make use of a number of
freely available 3\sphinxhyphen{}D rendering tools, for example:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Paraview www.paraview.org

\item {} 
\sphinxAtStartPar
VisIt visit.llnl.gov

\end{itemize}

\sphinxAtStartPar
RADMC\sphinxhyphen{}3D can create data files for use with these tools. The file format is
VTK (Visual Tool Kit), which is a simple ascii file format which is used by
various programs. Those tools are not only useful for visualizing the
3\sphinxhyphen{}D structure of the model, but also for visualizing the structure of the
grid which can be, when using AMR, rather complex.

\sphinxAtStartPar
The file that RADMC\sphinxhyphen{}3D writes is called \sphinxcode{\sphinxupquote{model.vtk}}. You should be able to
open it directly from within e.g. paraview. Figures \hyperref[\detokenize{vtkoutput:fig-disk-with-vtk}]{Fig.\@ \ref{\detokenize{vtkoutput:fig-disk-with-vtk}}}
and \hyperref[\detokenize{vtkoutput:fig-modeljuhasz-with-vtk}]{Fig.\@ \ref{\detokenize{vtkoutput:fig-modeljuhasz-with-vtk}}} gives an example of how you can analyze a
complex geometry with AMR refinement with Paraview. The file \{em always\}
includes the information about the grid. In addition you can also make RADMC\sphinxhyphen{}3D
add scalar fields or vector fields.

\sphinxAtStartPar
To create a VTK file for viewing the grid only, type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{vtk\PYGZus{}grid}
\end{sphinxVerbatim}

\sphinxAtStartPar
To create a VTK file for viewing the gas density (this file then also
includes the grid of course) type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{vtk\PYGZus{}gas\PYGZus{}density}
\end{sphinxVerbatim}

\sphinxAtStartPar
Since density can span a huge range, the 10\sphinxhyphen{}log of the density (in units of
gram/cm\(^3\)) is written instead. For the gas temperature:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{vtk\PYGZus{}gas\PYGZus{}temperature}
\end{sphinxVerbatim}

\sphinxAtStartPar
which is written in Kelvin (and linearly, not log). For the dust density of
dust species 1:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{vtk\PYGZus{}dust\PYGZus{}density} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
and for dust species 2:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{vtk\PYGZus{}dust\PYGZus{}density} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
Also these densities are 10\sphinxhyphen{}log. RADMC\sphinxhyphen{}3D typically computes the dust
temperature using a Monte Carlo approach. By typing

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{vtk\PYGZus{}dust\PYGZus{}temperature} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
RADMC\sphinxhyphen{}3D will try to read the dust temperature from the file
\sphinxcode{\sphinxupquote{dust\_temperature.dat}} (if this file has been created
earlier by a \sphinxcode{\sphinxupquote{radmc3d mctherm}} call) and then create
the VTK file. You can also let RADMC\sphinxhyphen{}3D compute the temperature
directly and write it out to VTK right afterward:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{mctherm} \PYG{n}{vtk\PYGZus{}dust\PYGZus{}temperature} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you are doing line transfer you may wish to visualize the number density
of the molecules (or atoms):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{vtk\PYGZus{}molspec} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
(for molecular species 1). This number density (in cm\(^{-3}\)) is also
written in 10\sphinxhyphen{}log form.  You may also wish to visualize the polulations of
level 1 (ground state) of molecule 2:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{vtk\PYGZus{}levelpop} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
The gas velocity field can be written to VTK file by

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{vtk\PYGZus{}velocity}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is a vector field.

\sphinxAtStartPar
Note: The VTK mode works for 3\sphinxhyphen{}D cartesian and 3\sphinxhyphen{}D spherical coordinates
(thanks, Attila Juhasz, for the 3\sphinxhyphen{}D spherical mode!).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{disk_rosenfeld}.pdf}
\caption{Example of image created with Paraview, using the VTK output of RADMC\sphinxhyphen{}3D.
The model shown here is a warped disk model by Katherine Rosenfeld, in 3\sphinxhyphen{}D
cartesian coordinates with oct\sphinxhyphen{}tree AMR refinement.}\label{\detokenize{vtkoutput:id1}}\label{\detokenize{vtkoutput:fig-disk-with-vtk}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{model_juhasz_vtk_lowres}.pdf}
\caption{Example of image created with Paraview, using the VTK output of RADMC\sphinxhyphen{}3D.
The model shown here is a warped disk model by Attila Juhasz, in 3\sphinxhyphen{}D
spherical coordinates with separable refinement, but without AMR refinement.
The model is kept low\sphinxhyphen{}resolution on purpose, to show the grid structure
better.}\label{\detokenize{vtkoutput:id2}}\label{\detokenize{vtkoutput:fig-modeljuhasz-with-vtk}}\end{figure}

\sphinxstepscope


\chapter{Tips, tricks and problem hunting}
\label{\detokenize{tipsandtricks:tips-tricks-and-problem-hunting}}\label{\detokenize{tipsandtricks:chap-problem-hunting}}\label{\detokenize{tipsandtricks::doc}}

\section{Tips and tricks}
\label{\detokenize{tipsandtricks:tips-and-tricks}}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D is a large software package, and the user will in all
likelihood not understand all its internal workings. In this section we will
discuss some issues that might be useful to know when you do modeling.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Things that can drastically slow down ray\sphinxhyphen{}tracing:}

\sphinxAtStartPar
When you create images or spectra, \sphinxcode{\sphinxupquote{radmc3d}} will perform a ray\sphinxhyphen{}tracing
calculation. You may notice that sometimes this can be very fast, but for
other problems it can be very slow. This is because, depending on which
physics is switched on, different ray\sphinxhyphen{}tracing strategies must be followed. For
instance, if you use a dust opacity without scattering opacity (or if you
switch dust scattering off by setting \sphinxcode{\sphinxupquote{scattering\_mode\_max}} to 0 in the
\sphinxcode{\sphinxupquote{radmc3d.inp}} file), and you make dust continuum images, or make SEDs, this
may go very rapidly: less than a minute on a modern computer for grids of
256x256x256. However, when you include scattering, it may go slower. Why is
that? That is because at each wavelength \sphinxcode{\sphinxupquote{radmc3d}} will now have to make a
quick Monte Carlo scattering model to compute the dust scattering source
function. This costs time. And it will cost more time if you have
\sphinxcode{\sphinxupquote{nphot\_scat}} set to a high value in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file, although it
will create better images. Furthermore, if you \sphinxstyleemphasis{also} include gas lines using
the simple LTE or simple LVG methods, then things become even slower, because
each wavelength channel image is done after each other, and each time all the
populations of the molecular levels have to be re\sphinxhyphen{}computed. If dust scattering
would be switched off (which is for some wavelength domains presumably not a
bad approximation; in particular for the millimeter domain), then no
scattering Monte Carlo runs have to be done for each wavelength. Then the code
can ray\sphinxhyphen{}trace all wavelength simultaneously: each ray is traced only once, for
all wavelength simultaneously. Then the LTE/LVG level populations have to be
computed only once at each location along the ray.  So if you use dust and
lines simultaneously, it can be advantageous for speed if you can afford to
switch off the dust scattering, for instance, if you model sub\sphinxhyphen{}millimeter
lines in regions with dust grains smaller than 10 micron or so. If you must
include scattering, but your model is not so big that you may get memory
limitation problems, then you may also try the fast LTE or fast LVG modes: in
those modes the level populations are pre\sphinxhyphen{}computed before the ray\sphinxhyphen{}tracing
starts, which saves time. But that may require much memory.

\end{itemize}


\section{Bug hunting}
\label{\detokenize{tipsandtricks:bug-hunting}}
\sphinxAtStartPar
Although we of course hope that \sphinxcode{\sphinxupquote{radmc3d}} will not run into
troubles or crash, it is nevertheless possible that it will. There are
several ways by which one can hunt for bugs, and we list here a few
obvious ones:
\begin{itemize}
\item {} 
\sphinxAtStartPar
In principle the \sphinxcode{\sphinxupquote{Makefile}} should make sure that all dependencies of all
modules are correct, so that the most dependent modules are compiled last. But
during the further development of the code perhaps this may be not 100\%
guaranteed. So try do \sphinxcode{\sphinxupquote{makeclean}} followed by \sphinxcode{\sphinxupquote{make}} (or \sphinxcode{\sphinxupquote{makeinstall}}) to assure a clean make.

\item {} 
\sphinxAtStartPar
In the \sphinxcode{\sphinxupquote{Makefile}} you can add (or uncomment) the line
\sphinxcode{\sphinxupquote{BCHECK=\sphinxhyphen{}fbounds\sphinxhyphen{}check}}, if you use \sphinxcode{\sphinxupquote{gfortran}}.  Find the array
boundary check switch on your own compiler if it is not \sphinxcode{\sphinxupquote{gfortran}}.

\item {} 
\sphinxAtStartPar
Make sure that in the \sphinxcode{\sphinxupquote{main.f90}} code the variable \sphinxcode{\sphinxupquote{debug\_check\_all}} is
set to 1. This will do some on\sphinxhyphen{}the\sphinxhyphen{}fly checks in the code.

\end{itemize}


\section{Some tips for avoiding troubles and for making good models}
\label{\detokenize{tipsandtricks:some-tips-for-avoiding-troubles-and-for-making-good-models}}
\sphinxAtStartPar
Here is a set of tips that we recommend you to follow, in order to avoid
troubles with the code and to make sure that the models you make are OK.
This list is far from complete! It will be updated as we continue to
develop the code.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Make a separate directory for each model. This avoids confusion with
the many input and output files from the models.

\item {} 
\sphinxAtStartPar
When experimenting: regularly keep models that work, and continue
experimenting with a fresh model directory. If things go wrong later, you
can always fall back on an older model that \sphinxstyleemphasis{did} work well.

\item {} 
\sphinxAtStartPar
Keep model directories within a parent directory of the code, just
like it is currently organized. This ensures that each model is always
associated to the version of the code for which it was developed.  If you
update to a new version of the code, it is recommended to simply copy the
models you want to continue with to the new code directory (and edit the
\sphinxcode{\sphinxupquote{SRC}} variable in the \sphinxcode{\sphinxupquote{Makefile}} if you use the
techniques described in Section {\hyperref[\detokenize{installation:sec-special-purpose-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Making special\sphinxhyphen{}purpose modified versions of RADMC\sphinxhyphen{}3D (optional)}}}} and
Chapter {\hyperref[\detokenize{internalsetup:chap-internal-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Modifying RADMC\sphinxhyphen{}3D: Internal setup and user\sphinxhyphen{}specified radiative processes}}}}).

\item {} 
\sphinxAtStartPar
If you make a new model, try to start with as clean a directory as
possible. This avoids that you accidently have a old files hanging around,
their presence of which may cause troubles in your new model.  So if you
make a model update, make a new directory and then copy only the files
that are necesary (for instance, \sphinxcode{\sphinxupquote{problem\_setup.py}},
\sphinxcode{\sphinxupquote{dustkappa\_silicate.inp}}, \sphinxcode{\sphinxupquote{Makefile}} and other
necessary files). One way of doing this easily is to write a little perl
script or csh script that does this for you.

\item {} 
\sphinxAtStartPar
In the example model directories there is always a \sphinxcode{\sphinxupquote{Makefile}}
present, even if no local \sphinxcode{\sphinxupquote{*.f90}} files are present. The idea
is that by typing \{small make cleanall\} you can safely clean up the
model directory and restore it to pre\sphinxhyphen{}model status. This can be useful
for safely cleaning model directories so that only the model setup files
remain there. It may save enormous amounts of disk space. But of course,
it means that if you revisit the model later, you would need to redo
the Monte Carlo simulations again, for instance. It is a matter of
choice between speed of access to results on the one hand and disk space
on the other hand.

\item {} 
\sphinxAtStartPar
If you use LVG or escape probability to compute the level populations
of molecules, please be aware that you must include all levels that could
be populated, not only the levels belonging to the line you are interested
in.

\end{enumerate}


\section{Careful: Things that might go wrong}
\label{\detokenize{tipsandtricks:careful-things-that-might-go-wrong}}\label{\detokenize{tipsandtricks:sec-things-going-wrong}}
\sphinxAtStartPar
In principle RADMC\sphinxhyphen{}3D should be fine\sphinxhyphen{}tuned such that it produced reliable
results in most circumstances. But radiative transfer modeling, like all
kinds of modeling, is not an entirely trivial issue. Extreme circumstances
can lead to wrong results, if the user is not careful in doing various
sanity checks. This section gives some tips that you, the user, may wish
to do to check that the results are ok. This is not an exhaustive list!
So please remain creative yourself in coming up with good tests and checks.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Too low number of photon packages for thermal Monte Carlo}

\sphinxAtStartPar
If the number of photon packages for the thermal Monte Carlo simulation
(Section {\hyperref[\detokenize{dustradtrans:sec-dust-thermal-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{The thermal Monte Carlo simulation: computing the dust temperature}}}}) is too low, the dust
temperatures are going to be very noisy. Some cells may even have temperature
zero. This may not only lead to noisy images and spectra, but also simply
wrong results. However, deep inside optically thick clouds (or protoplanetary
disks) it will be hard to avoid this problem.  Since those regions are very
deep below the \(\tau=1\) surface, it might not be always too critical in
that case. A bit of experimenting might be necessary.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Too low number of photon packages for scattering}

\sphinxAtStartPar
When making images or spectra in which dust scattering is important, the
scattered light emissivity is computed by a quick Monte Carlo simulation
before the ray\sphinxhyphen{}tracing (see Section {\hyperref[\detokenize{dustradtrans:sec-scat-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Scattered light in images and spectra: The ‘Scattering Monte Carlo’ computation}}}}). This
requires the setting of the number of photon packages used for this (the
variable \sphinxcode{\sphinxupquote{nphot\_scat}} for images and equivalently \sphinxcode{\sphinxupquote{nphot\_spec}} for
spectra, both can be set in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file). If you see too much
‘noise’ in your scattering image, you can improve this by setting
\sphinxcode{\sphinxupquote{nphot\_scat}} to a larger value (default = 100000). If your spectrum
contains too much noise, try setting \sphinxcode{\sphinxupquote{nphot\_spec}} to a larger value
(default = 10000).

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Too optically thick cells at the surface or inner edge}

\sphinxAtStartPar
You may want to experiment with grid resolution and refinement. Strictly
speaking the transition from optically thin to optically thick, as seen both
by the radiation entering the object and by the observer, has to occur over
more than one cell. That is for very optically thick models, one may need to
introduce grid refinement in various regions. As an example: an optically
thick protoplanetary disk may have an extremely sharp thin\sphinxhyphen{}thick transition
near the inner edge. To get the spectra and images right, it is important
that these regions are resolved by the grid (note: once well inside the
optically thick interior, it is no longer necessary to resolve individual
optical mean free paths, thankfully). It should be said that in practice it
is often impossible to do this in full strictness. But you may want to at
least experiment a bit with refining the grid (using either ‘separable
refinement’, see Section {\hyperref[\detokenize{gridding:sec-separable-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{Separable grid refinement in spherical coordinates (important!)}}}}, or AMR refinement,
see Section {\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-oct-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Oct\sphinxhyphen{}tree\sphinxhyphen{}style AMR grid}}}}). An example how wrong things can go
at the inner edge of a protoplanetary disk, if the inner cells are not
assured to be optically thin through grid refinement (and possibly
additionally a bit of smoothing of the density profile too) is given in
Fig. \hyperref[\detokenize{tipsandtricks:fig-innerrim-lowres}]{Fig.\@ \ref{\detokenize{tipsandtricks:fig-innerrim-lowres}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{innerrim}.pdf}
\caption{Example of what can go wrong with radiative transfer if the inner cells of
a model are optically thick (i.e.if no grid refinement is used, see
Section {\hyperref[\detokenize{gridding:sec-separable-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{Separable grid refinement in spherical coordinates (important!)}}}}). Shown here are scattered light
images at \(\lambda=0.7\mu`m wavelength of the inner rim of a
protoplanetary disk, but with the star removed with an ideal
choronograph. The color scale is linear. The radial grid is taken to be
logarithmically spaced with :math:\)Delta R/R=0.04\textasciigrave{}.  Left image: the
inner cells are marginally optically thin \(\Delta\tau\simeq 1\),
creating a bright inner ring, as is expected. Right image: ten times
higher optical depth, making the inner cells optically thick with roughly
\(\Delta\tau\simeq 10\), resulting in a wrong image in which the
emission near the midplane is strongly reduced.  The reason for that is
that the scattering source function, due to photons scattering at the
inner 10\% of the inner cell, is diluted over the entire cell, making the
scattered light brighness 10x lower than it should be.}\label{\detokenize{tipsandtricks:id1}}\label{\detokenize{tipsandtricks:fig-innerrim-lowres}}\end{figure}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Model does not fit onto the grid (or onto the refined part of the grid)}

\sphinxAtStartPar
The grid must be large enough to contain the entire \(\tau_\lambda=1\)
surface of a model at all relevant wavelengths. If you use grid refinement,
the same is true for the \(\tau_\lambda=1\) surface being within the
refinened part of the grid. This is not trivial!  If you, for instance,
import a 3\sphinxhyphen{}D hydrodynamic model into RADMC\sphinxhyphen{}3D, then it is a common problem
that the \(\tau_\lambda=1\) surface ‘wants’ to be outside of the grid (or
outside of the higher\sphinxhyphen{}resolution part of the \(\theta\)\sphinxhyphen{}grid if you use
separable grid refinement: see Fig. \DUrole{xref,std,std-ref}{fig\sphinxhyphen{}spher\sphinxhyphen{}sep\sphinxhyphen{}ref}). For example:
if you make a * hydrodynamic* model of a protoplanetary disk in \(R\),
\(\Theta\) and \(\Phi\) coordinates, you typically want to model only
the lower 2 pressure scale heights of the disk, since that contains 99.5\% of
the mass of the disk. However, for \sphinxstyleemphasis{radiative transfer} this may not be
enough, since if the disk has an optical depth of \(\tau=10^3\), the
optically thin surface layer is less than \(0.1\%\) of the disk mass,
meaning that you need to model the lower 3 (not 2!) pressure scale
heights. Simply inserting the hydrodynamics model with the first 2 scale
heights would lead to an artifical cut\sphinxhyphen{}off of the disk. In other words, the
real \(\tau_\lambda=1\) surface ‘wants’ to be outside of the grid (or
outside of the refined part of the grid). This leads to wrong results.

\end{enumerate}


\section{Common technical problems and how to fix them}
\label{\detokenize{tipsandtricks:common-technical-problems-and-how-to-fix-them}}
\sphinxAtStartPar
When using a complex code such as RADMC\sphinxhyphen{}3D there are many ways you might
encounter a problem. Here is a list of common issues and tips how to fix them.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{After updating RADMC\sphinxhyphen{}3D to a new version, some setups don’t work anymore.}

\sphinxAtStartPar
This problem can be due to several things:
\begin{itemize}
\item {} 
\sphinxAtStartPar
When your model makes a local \sphinxcode{\sphinxupquote{radmc3d}} executable (see Section
{\hyperref[\detokenize{installation:sec-special-purpose-compile}]{\sphinxcrossref{\DUrole{std,std-ref}{Making special\sphinxhyphen{}purpose modified versions of RADMC\sphinxhyphen{}3D (optional)}}}}), for instance when you use the
\sphinxcode{\sphinxupquote{userdef\_module.f90}} to set up the model, then you may need to edit the
\sphinxcode{\sphinxupquote{SRC}} variable in the \sphinxcode{\sphinxupquote{Makefile}} again to point to the new code
directory, and type \sphinxcode{\sphinxupquote{makeclean}} followed by \sphinxcode{\sphinxupquote{make}}.

\item {} 
\sphinxAtStartPar
Are you sure to have recompiled \sphinxcode{\sphinxupquote{radmc3d}} again \sphinxstyleemphasis{and} installed it (by
going in \sphinxcode{\sphinxupquote{src/}} and typing \sphinxcode{\sphinxupquote{makeinstall}})?

\item {} 
\sphinxAtStartPar
Try going back to the old version and recheck that the model works well
there. If that works, and the above tricks don’t fix the problem, then it
may be a bug. Please contact the author.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{After updating RADMC\sphinxhyphen{}3D to a new version: the new features are not present/working.}

\sphinxAtStartPar
Maybe again the \sphinxcode{\sphinxupquote{Makefile}} issue above.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{After updating RADMC\sphinxhyphen{}3D to a new version: model based on userdef\_module fails to compile}

\sphinxAtStartPar
If you switch to a new version of the code and try to ‘make’ an earlier model
that uses the userdef\_module.f90, it might sometimes happen that the
compilation fails because some subroutine \sphinxcode{\sphinxupquote{userdef\_***}} is not known (here
\sphinxcode{\sphinxupquote{***}} is some name). Presumably what happened is that a new user\sphinxhyphen{}defined
functionality has been added to the code, and the corresponding subroutine
\sphinxcode{\sphinxupquote{userdef\_***}} has been added to the \sphinxcode{\sphinxupquote{userdef\_module.f90}}. If, however,
in your own \sphinxcode{\sphinxupquote{userdef\_module.f90}} this subroutine is not yet built in, then
the compiler can’t find this subroutine and complains. Solution: just add a
dummy subroutine to your \sphinxcode{\sphinxupquote{userdef\_module.f90}} with that name (have a look
at the \sphinxcode{\sphinxupquote{userdef\_module.f90}} in the \sphinxcode{\sphinxupquote{src/}} directory).  Then recompile and
it should now work.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{While reading an input file, RADMC\sphinxhyphen{}3D says ‘Fortran runtime error: End of file’}

\sphinxAtStartPar
This can of course have many reasons. Some common mistakes are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{amr\_grid.inp}} you may have specified the coordinates of the nx*ny*nz
grid centers instead of (nx+1)*(ny+1)*(nz+1) grid cell interfaces.

\item {} 
\sphinxAtStartPar
You may have no line feed at the end of one of the ascii input files.  Some
fortran compilers can read only lines that are officially ended with a
return or line feed. Solution: Just write an empty line at the end of such
a file.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{My changes to the main code do not take effect}

\sphinxAtStartPar
Did you type, in the \sphinxcode{\sphinxupquote{src/}} directory, the full \sphinxcode{\sphinxupquote{makeinstall}}? If you
type just \sphinxcode{\sphinxupquote{make}}, then the code is compiled but not installed as the
default code.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{My userdef\_module.f90 stuff does not work}

\sphinxAtStartPar
If you run \sphinxcode{\sphinxupquote{radmc3d}} with own userdefined stuff, then you must make sure to
run the right executable. Just typing \sphinxcode{\sphinxupquote{radmc3d}} in the shell might cause
you to run the standard compilation instead of your special\sphinxhyphen{}purpose one. Try
typing \sphinxcode{\sphinxupquote{./radmc3d}} instead, which forces the shell to use the local
executable.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{When I make images from the command line, they take very long}

\sphinxAtStartPar
If you make images with \sphinxcode{\sphinxupquote{radmc3dimage}} (plus some keywords) from the
command line, the default is that a flux\sphinxhyphen{}conserving method of ray\sphinxhyphen{}tracing is
used, which is called recursive sub\sphinxhyphen{}pixeling (see Section
{\hyperref[\detokenize{imagesspectra:sec-image-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{The issue of flux conservation: recursive sub\sphinxhyphen{}pixeling}}}}). You can make an image without sub\sphinxhyphen{}pixeling with
the command\sphinxhyphen{}line option \sphinxcode{\sphinxupquote{nofluxcons}}. That goes much faster, and also
gives nice images, but the flux (the integral over the entire image) may
not be accurate.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{My line channel maps (images) look bad}

\sphinxAtStartPar
If you have a model with non\sphinxhyphen{}zero gas velocities, and if these gas velocities
have cell\sphinxhyphen{}to\sphinxhyphen{}cell differences that are larger than or equal to the intrinsic
(thermal+microturbulent) line width, then the ray\sphinxhyphen{}tracing will not be able to
pick up signals from intermediate velocities. In other words, because of the
discrete gridding of the model, only discrete velocities are present, which
can cause numerical problems. There are two possible solutions to this
problem. One is the wavelength band method described in Section
{\hyperref[\detokenize{imagesspectra:sec-wavelength-bands}]{\sphinxcrossref{\DUrole{std,std-ref}{Heads\sphinxhyphen{}up: In reality wavelength are actually wavelength bands}}}}.  But a more systematic method is the ‘doppler
catching’ method described in Section {\hyperref[\detokenize{lineradtrans:sec-doppler-catching}]{\sphinxcrossref{\DUrole{std,std-ref}{Preventing doppler jumps: The ‘doppler catching method’}}}} (which can
be combined with the wavelength band method of Section
{\hyperref[\detokenize{imagesspectra:sec-wavelength-bands}]{\sphinxcrossref{\DUrole{std,std-ref}{Heads\sphinxhyphen{}up: In reality wavelength are actually wavelength bands}}}} to make it even more perfect).

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{My line spectra look somewhat noisy}

\sphinxAtStartPar
If you include dust continuum scattering (Section {\hyperref[\detokenize{dustradtrans:sec-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{More about scattering of photons off dust grains}}}}) then
the ray\sphinxhyphen{}tracer will perform a scattering Monte Carlo simulation at each
wavelength. If you look at lines where dust scattering is still a strong
source of emission, and if \sphinxcode{\sphinxupquote{nphot\_scat}} (Section
{\hyperref[\detokenize{dustradtrans:sec-scat-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Scattered light in images and spectra: The ‘Scattering Monte Carlo’ computation}}}}) is set to a low value, then the different random
walks of the photon packages in each wavelength channel may cause slightly
different resulting fluxes, hence the noise.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{My dust continuum images look very noisy/streaky: many ‘lines’ in the image}

\sphinxAtStartPar
There are two possible reasons:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Photon noise in the thermal Monte Carlo run:} If you have too few photon
packages for the thermal Monte Carlo computation (see Chapter
{\hyperref[\detokenize{dustradtrans:chap-dust-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Dust continuum radiative transfer}}}}), then the dust temperatures are simply not well
computed. This may give these effects. You must then increase \sphinxcode{\sphinxupquote{nphot}} in
the \sphinxcode{\sphinxupquote{radmc3d.inp}} file to increase the photon statistics for the thermal
Monte Carlo run.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Photon noise in the scattering Monte Carlo run:} If you are making an
image at a wavelength at which the disk is not emitting much thermal
radiation, then what you will see in the image is scattered light.
\sphinxcode{\sphinxupquote{RADMC\sphinxhyphen{}3D}} makes a special Monte Carlo run for scattered light before
each image. This Monte Carlo run has its own variable for setting the
number of photon packages: \sphinxcode{\sphinxupquote{nphot\_scat}}. If this value is set too low,
then you can see individual ‘photon’\sphinxhyphen{}trajectories in the image, making the
image look bad. It is important to note that this can only be remedied by
increasing \sphinxcode{\sphinxupquote{nphot\_scat}} (in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file, see Section
{\hyperref[\detokenize{dustradtrans:sec-scat-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Scattered light in images and spectra: The ‘Scattering Monte Carlo’ computation}}}}), not by setting \sphinxcode{\sphinxupquote{nphot}} (which is the
number of photon packages for the thermal Monte Carlo computation). Please
also read Section {\hyperref[\detokenize{dustradtrans:sec-single-multiple-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{Single\sphinxhyphen{}scattering vs. multiple\sphinxhyphen{}scattering}}}} for a detailed
discussion about the effects of multiple scattering and the possibility of
it leading to streaks in the images.

\end{enumerate}

\sphinxAtStartPar
However, it might also mean that something is wrong with the setup. A few
common setup\sphinxhyphen{}errors that could cause these issues are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Accidently created a way too massive object. Let us discuss this with an
example of a protoplanetary disk: suppose you created, in spherical
coordinates, not a protoplanetary disk with
\(M_{\mathrm{disk}}=0.01\,M_{\odot}\) but accidently one with
\(M_{\mathrm{disk}}=10\,M_{\odot}\). In such a case a lot of things
will go wrong. First of all the inner edge of the disk will almost
certainly behave strangely (see Fig. {\hyperref[\detokenize{tipsandtricks:fig-innerrim-lowres}]{\sphinxcrossref{\DUrole{std,std-ref}{Example of what can go wrong with radiative transfer if the inner cells of
a model are optically thick (i.e.if no grid refinement is used, see
Section sec\sphinxhyphen{}separable\sphinxhyphen{}refinement). Shown here are scattered light
images at \textbackslash{}lambda=0.7\textbackslash{}mu\textasciigrave{}m wavelength of the inner rim of a
protoplanetary disk, but with the star removed with an ideal
choronograph. The color scale is linear. The radial grid is taken to be
logarithmically spaced with :math:Delta R/R=0.04\textasciigrave{}.  Left image: the
inner cells are marginally optically thin \textbackslash{}Delta\textbackslash{}tau\textbackslash{}simeq 1,
creating a bright inner ring, as is expected. Right image: ten times
higher optical depth, making the inner cells optically thick with roughly
\textbackslash{}Delta\textbackslash{}tau\textbackslash{}simeq 10, resulting in a wrong image in which the
emission near the midplane is strongly reduced.  The reason for that is
that the scattering source function, due to photons scattering at the
inner 10\% of the inner cell, is diluted over the entire cell, making the
scattered light brighness 10x lower than it should be.}}}}). Secondly,
the surface of the disk will almost certainly be cut\sphinxhyphen{}off in the way
decribed in Section {\hyperref[\detokenize{tipsandtricks:sec-things-going-wrong}]{\sphinxcrossref{\DUrole{std,std-ref}{Careful: Things that might go wrong}}}}, in which case the
surface of the disk will be hardly illuminated by the star, because the
disk surface is then exactly conical (i.e.starlight will not be able to
impinge on the surface). This will lead to very low photon statistics at
the surface.

\end{itemize}

\end{enumerate}

\sphinxstepscope


\chapter{Main input and output files of RADMC\sphinxhyphen{}3D}
\label{\detokenize{inputoutputfiles:main-input-and-output-files-of-radmc-3d}}\label{\detokenize{inputoutputfiles:chap-input-files}}\label{\detokenize{inputoutputfiles::doc}}
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D is written in fortran\sphinxhyphen{}90. It is written in such a way that the user
prepares input files (ending in \sphinxcode{\sphinxupquote{.inp}}) for the program and then calls
\sphinxcode{\sphinxupquote{radmc3d}} with some command\sphinxhyphen{}line options. The program then reads the input
files, and based on the command\sphinxhyphen{}line options will perform a certain calculation,
and finally outputs the results to output files (ending in \sphinxcode{\sphinxupquote{.out}}) or
intermediate files (ending in \sphinxcode{\sphinxupquote{.dat}}) which need further processing. In
principle the user therefore needs to compile the program only once, and can
then use the executable from that point onward. In this chapter we will describe
the various input/output and intermediate files and their formats. Just for
clarity: the Python routines in the \sphinxcode{\sphinxupquote{python/}} directory are only meant to make
it easier for the user to prepare the \sphinxcode{\sphinxupquote{.inp}} files, and to make sense of the
\sphinxcode{\sphinxupquote{.out}} and \sphinxcode{\sphinxupquote{.dat}} files. They are not part of the main code \sphinxcode{\sphinxupquote{radmc3d}}.

\sphinxAtStartPar
A few comments on RADMC\sphinxhyphen{}3D input and output files:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Most (though not all) files start with a \sphinxstyleemphasis{format number}. This number simply
keeps track of the version of the way the information is stored the file. The
idea is that if new versions of RADMC\sphinxhyphen{}3D come out in the future, it would be
good to have the possibility that new information is added to the files. The
format number is there to tell RADMC\sphinxhyphen{}3D whether a file is the new version or
still an older version.

\item {} 
\sphinxAtStartPar
RADMC\sphinxhyphen{}3D has four types of I/O files:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Files ending with \sphinxcode{\sphinxupquote{.inp}} or \sphinxcode{\sphinxupquote{.binp}} are input files that
allow the user to specify to RADMC\sphinxhyphen{}3D which problem to solve.

\item {} 
\sphinxAtStartPar
Files ending with \sphinxcode{\sphinxupquote{.dat}} or \sphinxcode{\sphinxupquote{.bdat}}are intermediate
files that are typically created by RADMC\sphinxhyphen{}3D itself, but can also be read
by RADMC\sphinxhyphen{}3D for further processing. For instance, the dust temperature is
computed by the Monte Carlo method, but can also be read in later for
ray\sphinxhyphen{}tracing.

\item {} 
\sphinxAtStartPar
Files ending with \sphinxcode{\sphinxupquote{.out}} or \sphinxcode{\sphinxupquote{.bout}} are final products of
RADMC\sphinxhyphen{}3D, such as an image or spectrum.

\item {} 
\sphinxAtStartPar
File ending with \sphinxcode{\sphinxupquote{.info}} are small files containing some numbers that are
useful to better interpret the output files of RADMC\sphinxhyphen{}3D. They are typically
not very important for every\sphinxhyphen{}day use.

\end{enumerate}

\item {} 
\sphinxAtStartPar
For many of the I/O files RADMC\sphinxhyphen{}3D can read and write formatted (i.e. text
style: ascii) files, or binary files (i.e. C\sphinxhyphen{}style unformatted). This is
specified by the file extension. See Chapter {\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}} for more
details.

\end{itemize}


\section{INPUT: radmc3d.inp}
\label{\detokenize{inputoutputfiles:input-radmc3d-inp}}\label{\detokenize{inputoutputfiles:sec-radmc-inp}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{radmc3d.inp}} file is a namelist file with the main settings for
RADMC\sphinxhyphen{}3D. The namelist is not a standard Fortran namelist style, but a simple
\sphinxstyleemphasis{name = value} list. If a name is not specified, the default values are taken.
So if the \sphinxcode{\sphinxupquote{radmc3d.inp}} file is empty, then all settings are standard.  Note
that some of these settings can be overwritten by command\sphinxhyphen{}line options! Here
is a non\sphinxhyphen{}exhaustive list of the variables that can be set.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{incl\_dust}} (default: depends on which input files are present)

\sphinxAtStartPar
Normally RADMC\sphinxhyphen{}3D will recognize automatically whether dust continuum
emission, absorption and scattering must be included: if e.g. a file
called \sphinxcode{\sphinxupquote{dustopac.inp}} is present, it assumes that the dust
must be included. But with this flag you can explicitly tell RADMC\sphinxhyphen{}3D
whether it must be included (1) or not (0).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{incl\_lines}} (default: depends on which input files are present)

\sphinxAtStartPar
Normally RADMC\sphinxhyphen{}3D will recognize automatically whether line emission and
absorption must be included: if e.g. a file called \sphinxcode{\sphinxupquote{lines.inp}}
is present, it assumes that molecular/atomic lines must be included. But
with this flag you can explicitly tell RADMC\sphinxhyphen{}3D whether it must be
included (1) or not (0).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nphot}} or \sphinxcode{\sphinxupquote{nphot\_therm}} (default: 100000)

\sphinxAtStartPar
The number of photon packages used for the thermal Monte Carlo simulation.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nphot\_scat}} (default: 100000)

\sphinxAtStartPar
The number of photon packages for the scattering Monte Carlo simulations,
done before image\sphinxhyphen{}rendering.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nphot\_spec}} (default: 10000)

\sphinxAtStartPar
The number of photon packages for the scattering Monte Carlo simulations, done
during spectrum\sphinxhyphen{}calculation. This is actually the same functionality as for
\sphinxcode{\sphinxupquote{nphot\_scat}}, but it is used (and only used) for the spectrum and SED
calculations. The reason to have a separate value for this is that for spectra
you may not need as many photon packages as for imaging, because you anyway
integrate over the images. Many of the annoying ‘stripe noise’ in images when
using insufficiently large \sphinxcode{\sphinxupquote{nphot\_scat}} will cancel each other out in the
flux calculation. So \sphinxcode{\sphinxupquote{nphot\_spec}} is usually taken smaller than
\sphinxcode{\sphinxupquote{nphot\_scat}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nphot\_mono}} (default: 100000)

\sphinxAtStartPar
The number of photon packages for the Monte Carlo simulations for the
\sphinxcode{\sphinxupquote{mcmono}} calculation (see Section {\hyperref[\detokenize{dustradtrans:sec-dust-monochromatic-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Special\sphinxhyphen{}purpose feature: Computing the local radiation field}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iseed}} (default: \sphinxhyphen{}17933201) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
A starting value of the random seed for the Monte Carlo simulation.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ifast}} (default: 0) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
By setting this to 1 or 2 you will get a faster Monte Carlo simulation,
at the cost of being less accurate.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{enthres}} (default: 0.01) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
This is the fraction by which the energy in each cell may increase
before the temperature is recalculated in the Monte Carlo simulation.
The smaller this value, the more accurate the thermal Monte Carlo
simulation, but the more computationally costly. 0.01 has proven to be
fine.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{itempdecoup}} (default: 1)

\sphinxAtStartPar
If set to 0, then the temperatures of all coexisting dust species are
always forced to be the same. If 1, then each dust species is thermally
independent of the other.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{istar\_sphere}} (default: 0)

\sphinxAtStartPar
If 0 (=default), then all stars are treated as point\sphinxhyphen{}sources. If 1, then
all stars are treated as finite\sphinxhyphen{}size spheres. This mode is more accurate
and more realistic, but the applications are a bit more restricted.
Such finite\sphinxhyphen{}size stars are (for technical reasons) not always allowed
anywhere in the model. But for problems of circumstellar disks and envelopes
in spherical coordinates, it is recommended to set this to 1. Typically,
if a star is outside the grid (in spherical coordinates this can also be
at the origin of the coordinate system, as long as the inner radius of
the coordinate system is larger than the stellar radius!) the use of the
finite\sphinxhyphen{}size star mode is always possible. But if the star is on the grid,
there are technical limitations.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ntemp}} (default: 1000) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
The temperatures are determined in the Monte Carlo method using tabulated
pre\sphinxhyphen{}computed integrals. This saves time. This is the number of
temperatures for which this is precalculated. The temperatures are sampled
in a logarithmic way, i.e. log(temp) is linearly equally spaced between
log(temp0) and log(temp1), see below.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{temp0}} (default: 0.01) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
The lowest pre\sphinxhyphen{}calculated temperature.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{temp1}} (default: 1e5) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
The highest pre\sphinxhyphen{}calculated temperature.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scattering\_mode\_max}}

\sphinxAtStartPar
When \sphinxcode{\sphinxupquote{radmc3d}} reads the dust opacity files it checks if one or more of the
opacity files has scattering opacity included. If yes, the \sphinxcode{\sphinxupquote{scattering\_mode}}
will automatically be set to 1. It will also check if one or more includes
\sphinxstyleemphasis{anisotropic} scattering. If yes, the \sphinxcode{\sphinxupquote{scattering\_mode}} will automatically
be set to 2. But the user \sphinxstyleemphasis{may} nevertheless want to exclude anisotropic
scattering or exclude scattering altogether (for instance for testing
purposes, or if the user knows from experience that the scattering or
anisotropic nature of scattering is not important for the problem at
hand). Rather than editing the opacity files to remove the scattering and/or
Henyey\sphinxhyphen{}Greenstein \(g\)\sphinxhyphen{}factors, you can limit the value that \sphinxcode{\sphinxupquote{radmc3d}}
is allowed to make \sphinxcode{\sphinxupquote{scattering\_mode}} by setting the variable
\sphinxcode{\sphinxupquote{scattering\_mode\_max}}. If you set \sphinxcode{\sphinxupquote{scattering\_mode\_max=0}} then no matter
what opacity files you have, scattering will not be treated.  If you set
\sphinxcode{\sphinxupquote{scattering\_mode\_max=1}}, then no matter what opacity files you have,
scattering will be treated in an isotropic way.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{unformatted}} (Obsolete)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rto\_style}} (default=1)

\sphinxAtStartPar
This determines whether the output of space\sphinxhyphen{}dependent data will be in ASCII
form (\sphinxcode{\sphinxupquote{rto\_style=1}}), f77\sphinxhyphen{}unformatted form (\sphinxcode{\sphinxupquote{rto\_style=2}}, obsolete)
or binary form (\sphinxcode{\sphinxupquote{rto\_style=3}}).  See Chapter {\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}} for
details.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_tracemode}} (default: 1)

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{camera\_tracemode}}=\sphinxhyphen{}1, the images that are rendered by RADMC\sphinxhyphen{}3D will
instead by the column depth traced along each ray.  If \sphinxcode{\sphinxupquote{camera\_tracemode}}=\sphinxhyphen{}2, the images that are rendered by RADMC\sphinxhyphen{}3D will instead by the continuum
optical depth traced along each ray.  By default \sphinxcode{\sphinxupquote{camera\_tracemode}}=1,
which is the normal mode, where real images are being created.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_nrrefine}} (default: 100)

\sphinxAtStartPar
For images: to assure that flux is correctly sampled, the image pixels
will not just be rendered one ray per pixel. Instead, if necessary,
a pixel will spawn 2x2 sub\sphinxhyphen{}pixels recursively (each of which can
split again into 2x2 until the required resolution is obtained) so
as to assure that the flux in each pixel is correct. \sphinxcode{\sphinxupquote{camera\_nrrefine}} tells
how deep RADMC\sphinxhyphen{}3D is allowed to recursively refine. 100 is therefore
effectively infinite. Putting this to 0 means that you go back to
1 ray per pixel, which is fast, but may seriously misrepresent the flux
in each pixel. See Section {\hyperref[\detokenize{imagesspectra:sec-image-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{The issue of flux conservation: recursive sub\sphinxhyphen{}pixeling}}}} for more details.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_refine\_criterion}} (default: 1.0) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
Setting this value to smaller than 1 means that you refine the recursive
pixeling until a tighter criterion is met. The smaller this value, the
more accurate the fluxes in each pixel, but the longer it takes to
render. See Section {\hyperref[\detokenize{imagesspectra:sec-image-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{The issue of flux conservation: recursive sub\sphinxhyphen{}pixeling}}}} for more details.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_incl\_stars}} (default: 1)

\sphinxAtStartPar
If 0, then only the interstellar/circumstellar material is rendered
for the images and spectra. If 1, then also the stellar flux is
included in the spectra and images.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_starsphere\_nrpix}} (default: 20) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
For rectangular images and for the spectra/SEDs (but not for spectra/SEDs
created with circular pixel arrangements, see Section
{\hyperref[\detokenize{imagesspectra:sec-circularimages}]{\sphinxcrossref{\DUrole{std,std-ref}{Circular images}}}}), this number tells RADMC\sphinxhyphen{}3D how
much it should do sub\sphinxhyphen{}pixeling over the stellar surface. That is: 20 means
that at least 20 sub\sphinxhyphen{}pixels are assured over the stellar surface. This is
important for flux conservation (see Section {\hyperref[\detokenize{imagesspectra:sec-image-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{The issue of flux conservation: recursive sub\sphinxhyphen{}pixeling}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_spher\_cavity\_relres}} (default: 0.05) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
Determines the size of sub\sphinxhyphen{}pixels inside the inner grid radius of
spherical coordinates.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_localobs\_projection}} (default: 1)

\sphinxAtStartPar
(Only for local observer mode) The type of projection on the sphere of
observation.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_min\_dangle}} (default 0.05) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
Fine\sphinxhyphen{}tuning parameter for recursive subpixeling (see Section
{\hyperref[\detokenize{imagesspectra:sec-recursive-subpixeling}]{\sphinxcrossref{\DUrole{std,std-ref}{The solution: recursive sub\sphinxhyphen{}pixeling}}}}), for spherical coordinates,
assuring that not too fine subpixeling would slow down the rendering of
images or spectra too much.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_max\_dangle}} (default 0.3) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
Fine\sphinxhyphen{}tuning parameter for recursive subpixeling (see Section
{\hyperref[\detokenize{imagesspectra:sec-recursive-subpixeling}]{\sphinxcrossref{\DUrole{std,std-ref}{The solution: recursive sub\sphinxhyphen{}pixeling}}}}), for spherical coordinates,
preventing that too coarse subpixeling would reduce the accuracy.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_min\_drr}} (default 0.003) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
Fine\sphinxhyphen{}tuning parameter for recursive subpixeling, for spherical coordinates,
assuring that not too fine subpixeling would slow down the rendering of
images or spectra too much.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_diagnostics\_subpix}} (default: 0)

\sphinxAtStartPar
Setting this to 1 forces RADMC\sphinxhyphen{}3D to write out a file called
\sphinxcode{\sphinxupquote{subpixeling\_diagnostics.out}} which contains four columns, for respectivly:
\sphinxcode{\sphinxupquote{px,py,pdx,pdy}}, i.e. the pixel position and its size. This is for all
pixels, including the sub\sphinxhyphen{}pixels created during the recursive subpixeling
procedure (Section {\hyperref[\detokenize{imagesspectra:sec-recursive-subpixeling}]{\sphinxcrossref{\DUrole{std,std-ref}{The solution: recursive sub\sphinxhyphen{}pixeling}}}}). This allows the user to
find out if the recursive subpixeling went well or if certain areas were
over/under\sphinxhyphen{}resolved. This is really only meant as a diagnostic.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_secondorder}} (default: 0)

\sphinxAtStartPar
If set to 1, RADMC\sphinxhyphen{}3D will interpolate all emission/absorption quantities
to the cell corners, and then use a second order integration routine with
bilinear interpolation of the source terms to integrate the ray\sphinxhyphen{}tracing
formal transfer equations. See Section {\hyperref[\detokenize{imagesspectra:sec-second-order}]{\sphinxcrossref{\DUrole{std,std-ref}{Second order ray\sphinxhyphen{}tracing (Important information!)}}}} for more
information about the second order integration: It is recommended to
read it!

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{camera\_interpol\_jnu}} (default: 0) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
Fine\sphinxhyphen{}tuning parameter for ray\sphinxhyphen{}tracing, only used for when second order
integration is done (i.e. if \sphinxcode{\sphinxupquote{camera\_secondorder}}=1). If 0
(default), then the source function \(S_\nu\) is the one that is
interpolated on the grid, while if 1, then the emissivity \(j_\nu\) is the
one that is interpolated on the grid. The differences are minimal, but
if strange results appear (when using second order integration) then you
may want to experiment a bit with this parameter.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mc\_weighted\_photons}} (default: 1) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{mc\_weighted\_photons}}=1 (default) then in Monte Carlo simulations not
all photon packages will have the same energy (see Section
{\hyperref[\detokenize{dustradtrans:sec-photon-packages-mc}]{\sphinxcrossref{\DUrole{std,std-ref}{More about photon packages in the Monte Carlo simulations}}}}). The energy will be weighted such that each
star or emission mechanism will emit, on average, the same number of photon
packages. As an example: If you have a stellar binary consisting of an O\sphinxhyphen{}star
surrounded by a Brown Dwarf, but the Brown Dwarf is surrounded by a disk, then
although the O star is much brighter than the O\sphinxhyphen{}star, the very inner regions
of the Brown Dwarf disk is still predominantly heated by the Brown Dwarf
stellar surface, because it is much closer to that material. If you do not
have weighted photon packages, then statistically the Brown Dwarf would emit
perhaps 1 or 2 photon packages, which makes the statistics of the energy
balance in the inner disk very bad. By \sphinxcode{\sphinxupquote{mc\_weighted\_photons}}=1 both the
Brown Dwarf and the O\sphinxhyphen{}star will each emit the same number of photon packages;
just the energy of the photon packages emitted by the Brown Dwarf are much
less energetic than those from the O\sphinxhyphen{}star.  This now assures a good photon
statistics everywhere.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{optimized\_motion}} (default: 0) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{optimized\_motion}} is set to 1, then RADMC\sphinxhyphen{}3D will try to
calculate the photon motion inside cells more efficiently. This may
save computational time, but since it is still not very well tested,
please use this mode with great care! It is always safer not to use
this mode.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lines\_mode}} (default: 1)

\sphinxAtStartPar
This mode determines how the level populations for line transfer are
computed. The default is 1, which means: Local Thermodynamic Equilibrium
(LTE). For other modes, please consult Chapter {\hyperref[\detokenize{lineradtrans:chap-line-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Line radiative transfer}}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lines\_maxdoppler}} (default: 0.3) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
If the doppler catching mode is used (see Section
{\hyperref[\detokenize{lineradtrans:sec-doppler-catching}]{\sphinxcrossref{\DUrole{std,std-ref}{Preventing doppler jumps: The ‘doppler catching method’}}}}), this parameter tells how fine RADMC\sphinxhyphen{}3D
must sample along the ray, in units of the doppler width, when a line is
doppler\sphinxhyphen{}shifting along the wavelength\sphinxhyphen{}of\sphinxhyphen{}sight.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lines\_partition\_ntempint}} (default 1000) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
Number of temperature sampling points for the internally calculated
partition function for molecular/atomic lines.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lines\_partition\_temp0}} (default 0.1) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
Smallest temperature sampling point for the internally calculated
partition function for molecular/atomic lines.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lines\_partition\_temp1}} (default 1E5) \sphinxstyleemphasis{{[}Fine\sphinxhyphen{}tuning only{]}}

\sphinxAtStartPar
Largest temperature sampling point for the internally calculated
partition function for molecular/atomic lines.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lines\_show\_pictograms}} (default 0)

\sphinxAtStartPar
If 1, then print a pictogram of the levels of the molecules/atoms.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tgas\_eq\_tdust}} (default: 0)

\sphinxAtStartPar
By setting \sphinxcode{\sphinxupquote{tgas\_eq\_tdust=1}} you tell \sphinxcode{\sphinxupquote{radmc3d}} to
simply read the \sphinxcode{\sphinxupquote{dust\_temperature.dat}} file and then equate
the gas temperature to the dust temperature. If multiple dust species
are present, only the first species will be used.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subbox\_nx,subbox\_ny,subbox\_nz,subbox\_x0,subbox\_x1,subbox\_y0,subbox\_y1,subbox\_z0,subbox\_z1}}

\sphinxAtStartPar
Parameters specifying the subbox size for the subbox extraction.
See Section {\hyperref[\detokenize{toolsinside:sec-subbox}]{\sphinxcrossref{\DUrole{std,std-ref}{Making a regularly\sphinxhyphen{}spaced datacube (‘subbox’) of AMR\sphinxhyphen{}based models}}}} for details.

\end{itemize}


\section{INPUT (required): amr\_grid.inp}
\label{\detokenize{inputoutputfiles:input-required-amr-grid-inp}}\label{\detokenize{inputoutputfiles:sec-grid-input}}
\sphinxAtStartPar
This is the file that specifies what the spatial grid of the model looks
like. See Chapter {\hyperref[\detokenize{gridding:chap-gridding}]{\sphinxcrossref{\DUrole{std,std-ref}{More information about the gridding}}}}. This file is essential, because most
other \sphinxcode{\sphinxupquote{.inp}} and \sphinxcode{\sphinxupquote{.dat}} files are simple lists of numbers which do not
contain any information about the grid. All information about the grid is
contained in the \sphinxcode{\sphinxupquote{amr\_grid.inp}}, also for non\sphinxhyphen{}AMR regular grids. Note that
in the future we will also allow for unstructured grids. The corresponding grid
files will then be named differently.

\sphinxAtStartPar
There are three possible AMR grid styles:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Regular grid: No mesh refinement. This is grid style 0.

\item {} 
\sphinxAtStartPar
Oct\sphinxhyphen{}tree\sphinxhyphen{}style AMR (‘Adaptive Mesh Refinement’, although for now it
is not really ‘adaptive’). This is grid style 1.

\item {} 
\sphinxAtStartPar
Layer\sphinxhyphen{}style AMR. This is grid style 10.

\end{itemize}


\subsection{Regular grid}
\label{\detokenize{inputoutputfiles:regular-grid}}\label{\detokenize{inputoutputfiles:sec-amr-grid-regular}}
\sphinxAtStartPar
For a regular grid, without grid refinement, the \sphinxcode{\sphinxupquote{amr\_grid.inp}} looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{l+m+mi}{0}                                        \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Grid} \PYG{n}{style} \PYG{p}{(}\PYG{n}{regular} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{coordsystem}
\PYG{n}{gridinfo}
\PYG{n}{incl\PYGZus{}x}       \PYG{n}{incl\PYGZus{}y}       \PYG{n}{incl\PYGZus{}z}
\PYG{n}{nx}           \PYG{n}{ny}           \PYG{n}{nz}
\PYG{n}{xi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{n}{xi}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{n}{xi}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{n}{xi}\PYG{p}{[}\PYG{n}{nx}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{yi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{n}{yi}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{n}{yi}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{n}{yi}\PYG{p}{[}\PYG{n}{ny}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{zi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{n}{zi}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{n}{zi}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{n}{zi}\PYG{p}{[}\PYG{n}{nz}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The meaning of the entries are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat}}: The format number, at present 1. For
unformatted files this must be 4\sphinxhyphen{}byte integer.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{coordsystem}}: If \sphinxcode{\sphinxupquote{coordsystem \textless{} 100}} the coordinate system is
cartesian. If \sphinxcode{\sphinxupquote{100 \textless{}= coordsystem \textless{} 200}} the coordinate system is spherical
(polar). Cylindrical coordinates have not yet been built in in this
version. For unformatted files this must be 4\sphinxhyphen{}byte integer.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gridinfo}}: If \sphinxcode{\sphinxupquote{gridinfo==1}} there will be
abundant grid information written into this file, possibly useful for
post\sphinxhyphen{}processing routines. Typically this is redundant information, so it
is advised to set \sphinxcode{\sphinxupquote{gridinfo=0}} to save disk space. In the
following we will assume that \sphinxcode{\sphinxupquote{gridinfo=0}}. For unformatted
files this must be 4\sphinxhyphen{}byte integer.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{incl\_x,incl\_y,incl\_z}}: These are either 0 or
1. If 0 then this dimension is not active (so upon grid refinement no
refinement in this dimension is done). If 1 this dimension is fully
active, even if the number of base grid cells in this direction is just
1. Upon refinement the cell will also be splitted in this dimension. For
unformatted files these numbers must be 4\sphinxhyphen{}byte integer.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nx,ny,nz}}: These are the number of grid cells on the
base grid in each of these dimensions. For unformatted files these numbers
must be 4\sphinxhyphen{}byte integer.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{xi{[}1{]}...xi{[}nx+1{]}}}: The edges of the cells of the base grid in
x\sphinxhyphen{}direction. For \sphinxcode{\sphinxupquote{nx}} grid cells we have \sphinxcode{\sphinxupquote{nx+1}} cell walls, hence \sphinxcode{\sphinxupquote{nx+1}}
cell wall positions. For unformatted files these numbers must be 8\sphinxhyphen{}byte reals
(=double precision).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{yi{[}1{]}...yi{[}ny+1{]}}}: Same as above, but now for
y\sphinxhyphen{}direction.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zi{[}1{]}...zi{[}nz+1{]}}}: Same as above, but now for
z\sphinxhyphen{}direction.

\end{itemize}

\sphinxAtStartPar
Example of a simple 2x2x2 regular grid in cartesian coordinates:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{2}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}  \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1.}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}  \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1.}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}  \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1.}
\end{sphinxVerbatim}


\subsection{Oct\sphinxhyphen{}tree\sphinxhyphen{}style AMR grid}
\label{\detokenize{inputoutputfiles:oct-tree-style-amr-grid}}\label{\detokenize{inputoutputfiles:sec-amr-grid-oct-tree}}
\sphinxAtStartPar
For a grid with oct\sphinxhyphen{}tree style grid refinement (see Section
{\hyperref[\detokenize{gridding:sec-oct-tree-amr}]{\sphinxcrossref{\DUrole{std,std-ref}{Oct\sphinxhyphen{}tree Adaptive Mesh Refinement}}}}), the \sphinxcode{\sphinxupquote{amr\_grid.inp}} looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{l+m+mi}{1}                                        \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Grid} \PYG{n}{style} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{=} \PYG{n}{Oct}\PYG{o}{\PYGZhy{}}\PYG{n}{tree}\PYG{p}{)}
\PYG{n}{coordsystem}
\PYG{n}{gridinfo}
\PYG{n}{incl\PYGZus{}x}       \PYG{n}{incl\PYGZus{}y}       \PYG{n}{incl\PYGZus{}z}
\PYG{n}{nx}           \PYG{n}{ny}           \PYG{n}{nz}
\PYG{n}{levelmax}     \PYG{n}{nleafsmax}    \PYG{n}{nbranchmax}     \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{n}{line} \PYG{n}{only} \PYG{k}{if} \PYG{n}{grid} \PYG{n}{style} \PYG{o}{==} \PYG{l+m+mi}{1}
\PYG{n}{xi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{n}{xi}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{n}{xi}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{n}{xi}\PYG{p}{[}\PYG{n}{nx}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{yi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{n}{yi}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{n}{yi}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{n}{yi}\PYG{p}{[}\PYG{n}{ny}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{zi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{n}{zi}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{n}{zi}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{n}{zi}\PYG{p}{[}\PYG{n}{nz}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{=}\PYG{n}{leaf}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{=}\PYG{n}{branch} \PYG{p}{(}\PYG{n}{only} \PYG{k}{if} \PYG{n}{amrstyle}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{=}\PYG{n}{leaf}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{=}\PYG{n}{branch} \PYG{p}{(}\PYG{n}{only} \PYG{k}{if} \PYG{n}{amrstyle}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{=}\PYG{n}{leaf}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{=}\PYG{n}{branch} \PYG{p}{(}\PYG{n}{only} \PYG{k}{if} \PYG{n}{amrstyle}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{=}\PYG{n}{leaf}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{=}\PYG{n}{branch} \PYG{p}{(}\PYG{n}{only} \PYG{k}{if} \PYG{n}{amrstyle}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{=}\PYG{n}{leaf}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{=}\PYG{n}{branch} \PYG{p}{(}\PYG{n}{only} \PYG{k}{if} \PYG{n}{amrstyle}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{=}\PYG{n}{leaf}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{=}\PYG{n}{branch} \PYG{p}{(}\PYG{n}{only} \PYG{k}{if} \PYG{n}{amrstyle}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{=}\PYG{n}{leaf}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{=}\PYG{n}{branch} \PYG{p}{(}\PYG{n}{only} \PYG{k}{if} \PYG{n}{amrstyle}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{=}\PYG{n}{leaf}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{=}\PYG{n}{branch} \PYG{p}{(}\PYG{n}{only} \PYG{k}{if} \PYG{n}{amrstyle}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{=}\PYG{n}{leaf}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{=}\PYG{n}{branch} \PYG{p}{(}\PYG{n}{only} \PYG{k}{if} \PYG{n}{amrstyle}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The keywords have the same meaning as before, but in addition we have:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{(0/1)}}: \sphinxstyleemphasis{NOTE: Only for} \sphinxcode{\sphinxupquote{amrstyle==1}}. These are numbers that are either 0
or 1. If 0, this means the current cell is a leaf (= a cell that is not
refined and is therefore a ‘true’ cell). If 1, the current cell is a branch
with 2 (in 1\sphinxhyphen{}D), 4 (in 2\sphinxhyphen{}D) or 8 (in 3\sphinxhyphen{}D) daughter cells. In that case the
next (0/1) numbers are for these daughter cells. In other words, we
immediately recursively follow the tree. The order in which this happens is
logical. In 3\sphinxhyphen{}D the first daughter cell is (1,1,1), then (2,1,1), then
(1,2,1), then (2,2,1), then (1,1,2), then (2,1,2), then (1,2,2) and finally
(2,2,2), where the first entry represents the x\sphinxhyphen{}direction, the second the
y\sphinxhyphen{}direction and the third the z\sphinxhyphen{}direction. If one or more of the daughter
cells is also refined (i.e. has a value 1), then first this sub\sphinxhyphen{}tree is
followed before continuing with the rest of the daughter cells. If we finally
return to the base grid at some point, the next (0/1) number is for the next
base grid cell (again possibly going into this tree if the value is 1). The
order in which the base grid is scanned in this way is from \sphinxcode{\sphinxupquote{1}} to \sphinxcode{\sphinxupquote{nx}} in
the innermost loop, from \sphinxcode{\sphinxupquote{1}} to \sphinxcode{\sphinxupquote{ny}} in the middle loop and from \sphinxcode{\sphinxupquote{1}} to
\sphinxcode{\sphinxupquote{nz}} in the outermost loop. For unformatted files these numbers must be
4\sphinxhyphen{}byte integers, one record per number.

\end{itemize}

\sphinxAtStartPar
Example of a simple 1x1x1 grid which is refined into 2x2x2 and for
which the (1,2,1) cell is refined again in 2x2x2:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}
\PYG{l+m+mi}{10} \PYG{l+m+mi}{100} \PYG{l+m+mi}{100}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}  \PYG{l+m+mf}{1.}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}  \PYG{l+m+mf}{1.}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}  \PYG{l+m+mf}{1.}
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{0}
\end{sphinxVerbatim}


\subsection{Layer\sphinxhyphen{}style AMR grid}
\label{\detokenize{inputoutputfiles:layer-style-amr-grid}}\label{\detokenize{inputoutputfiles:sec-amr-grid-layered}}
\sphinxAtStartPar
For a grid with layer\sphinxhyphen{}style grid refinement (see Section
{\hyperref[\detokenize{gridding:sec-layered-amr}]{\sphinxcrossref{\DUrole{std,std-ref}{Layered Adaptive Mesh Refinement}}}}), the \sphinxcode{\sphinxupquote{amr\_grid.inp}} looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{l+m+mi}{10}                                       \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Grid} \PYG{n}{style} \PYG{p}{(}\PYG{l+m+mi}{10} \PYG{o}{=} \PYG{n}{layer}\PYG{o}{\PYGZhy{}}\PYG{n}{style}\PYG{p}{)}
\PYG{n}{coordsystem}
\PYG{n}{gridinfo}
\PYG{n}{incl\PYGZus{}x}       \PYG{n}{incl\PYGZus{}y}       \PYG{n}{incl\PYGZus{}z}
\PYG{n}{nx}           \PYG{n}{ny}           \PYG{n}{nz}
\PYG{n}{nrlevels}     \PYG{n}{nrlayers}                    \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{n}{line} \PYG{n}{only} \PYG{k}{if} \PYG{n}{grid} \PYG{n}{style} \PYG{o}{==} \PYG{l+m+mi}{10}
\PYG{n}{xi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{n}{xi}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{n}{xi}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{n}{xi}\PYG{p}{[}\PYG{n}{nx}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{yi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{n}{yi}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{n}{yi}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{n}{yi}\PYG{p}{[}\PYG{n}{ny}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{zi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{n}{zi}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{n}{zi}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}       \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{n}{zi}\PYG{p}{[}\PYG{n}{nz}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{parentid}     \PYG{n}{ix}  \PYG{n}{iy}  \PYG{n}{iz}   \PYG{n}{nx}  \PYG{n}{ny}  \PYG{n}{nz}
\PYG{n}{parentid}     \PYG{n}{ix}  \PYG{n}{iy}  \PYG{n}{iz}   \PYG{n}{nx}  \PYG{n}{ny}  \PYG{n}{nz}
\PYG{n}{parentid}     \PYG{n}{ix}  \PYG{n}{iy}  \PYG{n}{iz}   \PYG{n}{nx}  \PYG{n}{ny}  \PYG{n}{nz}
\PYG{n}{parentid}     \PYG{n}{ix}  \PYG{n}{iy}  \PYG{n}{iz}   \PYG{n}{nx}  \PYG{n}{ny}  \PYG{n}{nz}
\PYG{o}{.}
\PYG{o}{.}
\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The keywords have the same meaning as before, but in addition we have:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nrlevels}}: How many levels you plan to go, where
\sphinxcode{\sphinxupquote{nrlevels==0}} means no refinement, \sphinxcode{\sphinxupquote{nrlevels==1}} means one level of refinement
(factor of 2 in resolution), etc.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nrlayers}}: How many layers do you have, with \sphinxcode{\sphinxupquote{nrlayers==0}}
means no refinement, \sphinxcode{\sphinxupquote{nrlayers==1}} means one layer of refinement (factor of
2 in resolution), etc.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{parentid}}: (For each layer) The parent layer for this
layer. \sphinxcode{\sphinxupquote{parentid==0}} means parent is base grid. First layer has \sphinxcode{\sphinxupquote{id==1}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ix,iy,iz}}: (For each layer) The location in the parent
layer where the current layer starts.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nx,ny,nz}}: (For each layer) The size of the layer as measured in units of
the the parent layer. So the actual size of the current layer will be (in
3\sphinxhyphen{}D): \sphinxcode{\sphinxupquote{2*nx,2*ny,2*nz}}. In 2\sphinxhyphen{}D, with only the x\sphinxhyphen{} and y\sphinxhyphen{} dimensions active,
we have a size of \sphinxcode{\sphinxupquote{2*nx,2*ny}} with of course size 1 in z\sphinxhyphen{}direction.

\end{itemize}

\sphinxAtStartPar
As you can see, this is a much easier and more compact way to specify
mesh refinement. But it is also less ‘adaptive’, as it is always organized
in square/cubic patches. But it is much easier to handle for the user than
full oct\sphinxhyphen{}tree refinement.

\sphinxAtStartPar
Note that this layer\sphinxhyphen{}style refinement is in fact, internally, translated
into the oct\sphinxhyphen{}tree refinement. But you, as the user, will not notice any
of that. The code will input and output entirely in layer style.

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE:} The layers must be specify in increasing refinement level!  So
the first layer (layer 1) must have the base grid (layer 0) as its
parent. The second layer can have either the base grid (layer 0) or the
first layer (layer 1) as parent, etc. In other words: the parent layer
must always already have been specified before.

\sphinxAtStartPar
Example of a simple 2\sphinxhyphen{}D 4x4 grid which has a refinement patch in the middle
of again 4x4 cells (=2x2 on the parent grid), and a patch of 2x2 (=1x1 on
the parent grid) starting in the upper left corner:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{100}
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{0}
\PYG{l+m+mi}{4}  \PYG{l+m+mi}{4}  \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1}  \PYG{l+m+mi}{2}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{2.}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{2.}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5} \PYG{l+m+mf}{0.5}
\PYG{l+m+mi}{0}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{1}
\PYG{l+m+mi}{0}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
This has just one level of refinement, but two patches at level 1.

\sphinxAtStartPar
Anothe example: two recursive layers. Again start with a 2\sphinxhyphen{}D 4x4 grid,
now refine it in the middle with again a 4x4 sub\sphinxhyphen{}grid (=2x2 on the parent
grid = layer 0) and then again a deeper layer of 4x4 (=2x2 on the
parent grid = layer 1) this time starting in the corner:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{100}
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{0}
\PYG{l+m+mi}{4}  \PYG{l+m+mi}{4}  \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2}  \PYG{l+m+mi}{2}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{2.}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{0.} \PYG{l+m+mf}{1.} \PYG{l+m+mf}{2.}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5} \PYG{l+m+mf}{0.5}
\PYG{l+m+mi}{0}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that with this layer\sphinxhyphen{}style grid, the input data will have to be speficied
layer\sphinxhyphen{}by\sphinxhyphen{}layer: first the base grid, then the first layer, then the second
etc. This is worked out in detail for \sphinxcode{\sphinxupquote{dust\_density.inp}} in Section
{\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}. This will include redundant data, because you specify the
data on the entire base grid, also the cells that later will be replaced by a
layer. Same is true for any layer that has sub\sphinxhyphen{}layers. The data that is
specified in these regions will be simply ignored. But for simplicity we do
still require it to be present, so that irrespective of the deeper layers, the
data in any layer (including the base grid, which is layer number 0) is simply
organized as a simple data cube. This redundancy makes the input and output
files larger than strictly necessary, but it is much easier to handle as each
layer is a datacube. For memory/hardisk\sphinxhyphen{}friendly storage you must use the
oct\sphinxhyphen{}tree refinement instead. The layers are meant to make the AMR much more
accessible, but are somewhat more memory consuming.


\section{INPUT (required for dust transfer): dust\_density.inp}
\label{\detokenize{inputoutputfiles:input-required-for-dust-transfer-dust-density-inp}}\label{\detokenize{inputoutputfiles:sec-dustdens}}
\sphinxAtStartPar
This is the file that contains the dust densities. It is merely a list of
numbers. Their association to grid cells is via the file \sphinxcode{\sphinxupquote{amr\_grid.inp}} (see
Chapter {\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}} for the binary version of this file, which is more
compact).  Each dust species will have its own density distribution, completely
independently of the others. That means that at each position in space several
dust species can exist, and the density of these can be fully freely
specified. The structure of this file is as follows. For formatted style
(\sphinxcode{\sphinxupquote{dust\_density.inp}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{nrcells}
\PYG{n}{nrspec}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}
\PYG{n}{density}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}
\PYG{n}{density}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{n}{nrspec}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{nrspec}} is the number of independent dust species densities
that will be given here. It can be 1 or larger. If it is 1, then of course
the \sphinxcode{\sphinxupquote{density{[}1,ispec=2{]}}} and following lines are not present
in the file. The \sphinxcode{\sphinxupquote{nrcells}} is the number of cells. For different
kinds of grids this can have different meaning. Moreover, for different
kinds of grids the order in which the density values are given is also
different.  So let us now immediately make the following distinction (See
Chapter {\hyperref[\detokenize{gridding:chap-gridding}]{\sphinxcrossref{\DUrole{std,std-ref}{More information about the gridding}}}} on the different kinds of grids):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{For regular grid and oct\sphinxhyphen{}tree AMR grids:}

\sphinxAtStartPar
The value of \sphinxcode{\sphinxupquote{nrcells}} denotes the number of \sphinxstyleemphasis{true} cells,
excluding the cells that are in fact the parents of 2x2x2 subcells; i.e.
the sum of the volumes of all true cells (=leafs) adds up to the volume of
the total grid). The order of these numbers is always the same ‘immediate
recursive subtree entry’ as in the \sphinxcode{\sphinxupquote{amr\_grid.inp}}
(Section {\hyperref[\detokenize{inputoutputfiles:sec-grid-input}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): amr\_grid.inp}}}}).

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{For layer\sphinxhyphen{}style AMR grids:}

\sphinxAtStartPar
The value of \sphinxcode{\sphinxupquote{nrcells}} denotes the number of values that are specified. This
is generally a bit more than the true number of cells specified in the
oct\sphinxhyphen{}tree style AMR (see above). In the layer\sphinxhyphen{}style AMR mode you specify the
dust density (or any other value) first at all cells of the base grid (whether
a cell is refined or not does not matter), the at all cells of the first
layer, then the second layer etc. Each layer is a regular (sub\sphinxhyphen{})grid, so the
order of the values is simply the standard order (same as for regular
grids). This means, however, that the values of the density in the regular
grid cells that are replaced by a layer are therefore redundant. See Section
{\hyperref[\detokenize{gridding:sec-layer-amr-redundancy}]{\sphinxcrossref{\DUrole{std,std-ref}{On the ‘successively regular’ kind of data storage, and its slight redundancy}}}} for a discussion of this redundancy. The main
advantage of this layer\sphinxhyphen{}style grid refinement is that the input and output
always takes place on \sphinxstyleemphasis{regular} grids and subgrids (=layers). This is much
easier to handle than the complexities of the oct\sphinxhyphen{}tree AMR.

\end{itemize}


\subsection{Example: \sphinxstyleliteralintitle{\sphinxupquote{dust\_density.inp}} for a regular grid}
\label{\detokenize{inputoutputfiles:example-dust-density-inp-for-a-regular-grid}}
\sphinxAtStartPar
Now let us look at an example of a \sphinxcode{\sphinxupquote{dust\_density.inp}} file,
starting with one for the simplified case of a regular 3\sphinxhyphen{}D grid (see
Sections {\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-regular}]{\sphinxcrossref{\DUrole{std,std-ref}{Regular grid}}}} and {\hyperref[\detokenize{gridding:sec-regular-grid}]{\sphinxcrossref{\DUrole{std,std-ref}{Regular grids}}}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{nrcells}
\PYG{n}{nrspec}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}
\PYG{n}{density}\PYG{p}{[}\PYG{n}{nx}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}
\PYG{n}{density}\PYG{p}{[}\PYG{n}{nz}\PYG{p}{,}\PYG{n}{ny}\PYG{p}{,}\PYG{n}{nz}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}
\PYG{n}{density}\PYG{p}{[}\PYG{n}{nz}\PYG{p}{,}\PYG{n}{ny}\PYG{p}{,}\PYG{n}{nz}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{n}{nrspec}\PYG{p}{]}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{base_amr}.pdf}
\caption{Example of a regular 2\sphinxhyphen{}D grid with \sphinxcode{\sphinxupquote{nx}}=4 and \sphinxcode{\sphinxupquote{ny}}=3 (as
Fig. \hyperref[\detokenize{gridding:fig-regular-grid}]{Fig.\@ \ref{\detokenize{gridding:fig-regular-grid}}}), with the order of the cells shown as
numbers in the cells.}\label{\detokenize{inputoutputfiles:id1}}\label{\detokenize{inputoutputfiles:fig-regular-grid-numbered}}\end{figure}


\subsection{Example: \sphinxstyleliteralintitle{\sphinxupquote{dust\_density.inp}} for an oct\sphinxhyphen{}tree refined grid}
\label{\detokenize{inputoutputfiles:example-dust-density-inp-for-an-oct-tree-refined-grid}}
\sphinxAtStartPar
For the case when you have an oct\sphinxhyphen{}tree refined grid (see Sections
{\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-oct-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Oct\sphinxhyphen{}tree\sphinxhyphen{}style AMR grid}}}} and {\hyperref[\detokenize{gridding:sec-oct-tree-amr}]{\sphinxcrossref{\DUrole{std,std-ref}{Oct\sphinxhyphen{}tree Adaptive Mesh Refinement}}}}), the order of the
numbers is the same as the order of the cells as specified in the
\sphinxcode{\sphinxupquote{amr\_grid.(u)inp}} file (Section {\hyperref[\detokenize{inputoutputfiles:sec-grid-input}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): amr\_grid.inp}}}}).  Let us take the
example of a simple 1x1x1 grid which is refined into 2x2x2 and for which the
(1,2,1) cell is refined again in 2x2x2 (this is exactly the same example as
shown in Section {\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-oct-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Oct\sphinxhyphen{}tree\sphinxhyphen{}style AMR grid}}}}, and for which the
\sphinxcode{\sphinxupquote{amr\_grid.inp}} is given in that section). Let us also assume that we have only
one dust species. Then the \sphinxcode{\sphinxupquote{dust\_density.inp}} file would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{l+m+mi}{15}                                       \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{n}{x2x2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{n}{x2x2} \PYG{o}{=} \PYG{l+m+mi}{15}
\PYG{l+m+mi}{1}                                        \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Let} \PYG{n}{us} \PYG{n}{take} \PYG{n}{just} \PYG{n}{one} \PYG{n}{dust} \PYG{n}{spec}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}                           \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{the} \PYG{n}{first} \PYG{n}{base} \PYG{n}{grid} \PYG{n}{cell}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}                     \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{the} \PYG{n}{first} \PYG{n}{refined} \PYG{n}{cell}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}                     \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{the} \PYG{n}{last} \PYG{n}{refined} \PYG{n}{cell}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}                           \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{the} \PYG{n}{last} \PYG{n}{base} \PYG{n}{grid} \PYG{n}{cell}
\end{sphinxVerbatim}

\sphinxAtStartPar
A more complex example is shown in Fig. {\hyperref[\detokenize{inputoutputfiles:fig-oct-tree-amr-numbered}]{\sphinxcrossref{\DUrole{std,std-ref}{Example of a 2\sphinxhyphen{}D grid with oct\sphinxhyphen{}tree refinement (as
Fig. fig\sphinxhyphen{}oct\sphinxhyphen{}tree\sphinxhyphen{}amr) with the order of the cells shown as numbers in
the cells.}}}}.
An unformatted version is also available, in the standard way (see above).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{oct_tree_amr}.pdf}
\caption{Example of a 2\sphinxhyphen{}D grid with oct\sphinxhyphen{}tree refinement (as
Fig. {\hyperref[\detokenize{gridding:fig-oct-tree-amr}]{\sphinxcrossref{\DUrole{std,std-ref}{Example of a 2\sphinxhyphen{}D grid with oct\sphinxhyphen{}tree refinement. The base grid has nx=4
and ny=3. Three levels of refinement are added to this base grid.}}}}) with the order of the cells shown as numbers in
the cells.}\label{\detokenize{inputoutputfiles:id2}}\label{\detokenize{inputoutputfiles:fig-oct-tree-amr-numbered}}\end{figure}


\subsection{Example: \sphinxstyleliteralintitle{\sphinxupquote{dust\_density.inp}} for a layer\sphinxhyphen{}style refined grid}
\label{\detokenize{inputoutputfiles:example-dust-density-inp-for-a-layer-style-refined-grid}}
\sphinxAtStartPar
For the case when you have an layer\sphinxhyphen{}style refined grid (see Sections
{\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-layered}]{\sphinxcrossref{\DUrole{std,std-ref}{Layer\sphinxhyphen{}style AMR grid}}}} and {\hyperref[\detokenize{gridding:sec-layered-amr}]{\sphinxcrossref{\DUrole{std,std-ref}{Layered Adaptive Mesh Refinement}}}}) you specify the
density in a series of regular boxes (=layers). The first box is the base
grid, the second the first layer, the third the second layer etc.  The value
\sphinxcode{\sphinxupquote{nrcells}} now tells the combined sizes of the all the boxes. If we
take the second example of Section {\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-layered}]{\sphinxcrossref{\DUrole{std,std-ref}{Layer\sphinxhyphen{}style AMR grid}}}}: a simple 2\sphinxhyphen{}D
4x4 grid which has a refinement patch (=layer) in the middle of again 4x4
cells, and again one patch of 4x4 this time, however, starting in the upper
left corner (see the \sphinxcode{\sphinxupquote{amr\_grid.inp}} file given in Section
{\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-layered}]{\sphinxcrossref{\DUrole{std,std-ref}{Layer\sphinxhyphen{}style AMR grid}}}}), then the \sphinxcode{\sphinxupquote{dust\_density.inp}} file
has the following form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{l+m+mi}{48}                                       \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{n}{x4} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{n}{x4} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{n}{x4} \PYG{o}{=} \PYG{l+m+mi}{48}
\PYG{l+m+mi}{1}                                        \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Let} \PYG{n}{us} \PYG{n}{take} \PYG{n}{just} \PYG{n}{one} \PYG{n}{dust} \PYG{n}{spec}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{n}{a} \PYG{n}{redundant} \PYG{n}{value}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{n}{a} \PYG{n}{redundant} \PYG{n}{value}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{n}{a} \PYG{n}{redundant} \PYG{n}{value}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{n}{a} \PYG{n}{redundant} \PYG{n}{value}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{n}{a} \PYG{n}{redundant} \PYG{n}{value}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{n}{a} \PYG{n}{redundant} \PYG{n}{value}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{n}{a} \PYG{n}{redundant} \PYG{n}{value}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}                   \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{This} \PYG{n}{a} \PYG{n}{redundant} \PYG{n}{value}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
An unformatted version is also available, in the standard way (see above).

\sphinxAtStartPar
It is clear that 48 is now the total number of values to be read, which is
16 values for layer 0 (= base grid), 16 values for layer 1 and 16 values
for layer 2. It is also clear that some values are redundant (they can
have any value, does not matter). But it at least assures that each data
block is a simple regular data block, which is easier to handle. Note that
these values (marked as redundant in the above example) \sphinxstyleemphasis{must} be
present in the file, but they can have any value you like (typically 0).

\sphinxAtStartPar
Note that if you have multiple species of dust then we will still have
48 as the value of \sphinxcode{\sphinxupquote{nrcells}}. The number of values to be read,
if you have 2 dust species, is then simply 2*\sphinxcode{\sphinxupquote{nrcells}} = 2*48 = 96.


\section{INPUT/OUTPUT: dust\_temperature.dat}
\label{\detokenize{inputoutputfiles:input-output-dust-temperature-dat}}
\sphinxAtStartPar
The dust temperature file is an intermediate result of RADMC\sphinxhyphen{}3D and follows from
the thermal Monte Carlo simulation. The name of this file is
\sphinxcode{\sphinxupquote{dust\_temperature.dat}} (see Chapter {\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}} for the binary
version of this file, which is more compact). It can be used by the user for
other purposes (e.g. determination of chemical reaction rates), but also by
RADMC\sphinxhyphen{}3D itself when making ray\sphinxhyphen{}traced images and/or spectra. The user can also
produce his/her own \sphinxcode{\sphinxupquote{dust\_temperature.dat}} file (without invoking the Monte
Carlo computation) if she/he has her/his own way of computing the dust
temperature.

\sphinxAtStartPar
The structure of this file is identical to that of \sphinxcode{\sphinxupquote{dust\_density.inp}} (Section
{\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}), but with density replaced by temperature. We refer to
section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}} for the details.


\section{INPUT (mostly required): stars.inp}
\label{\detokenize{inputoutputfiles:input-mostly-required-stars-inp}}\label{\detokenize{inputoutputfiles:sec-stars}}
\sphinxAtStartPar
This is the file that specifies the number of stars, their positions,
radii, and spectra. Stars are sources of netto energy. For the dust
continuum Monte Carlo simulation these are a source of photon packages.
This file exists only in formatted (ascii) style. Its structure is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
iformat                           \PYGZlt{}=== Put this to 2 !
nstars        nlam
rstar[1]      mstar[1]      xstar[1]      ystar[1]      zstar[1]
  .             .              .             .             .
  .             .              .             .             .
rstar[nstars  mstar[nstars] xstar[nstars] ystar[nstars] zstar[nstars]
lambda[1]
  .
  .
lambda[nlam]
flux[1,star=1]
  .
  .
flux[nlam,star=1]
flux[1,star=2]
  .
  .
flux[nlam,star=2]
  .
  .
  .
  .
flux[nlam,star=nstar]
\end{sphinxVerbatim}

\sphinxAtStartPar
which is valid only if \sphinxcode{\sphinxupquote{iformat==2}}. The meaning of the variables:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat}}: The format number, at present better keep it at 2.
If you put it to 1, the list of wavelengths (see below) will instead be
a list of frequencies in Herz.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nstars}}: The number of stars you wish to specify.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nlam}}: The number of frequency points for the stellar
spectra. At present this must be identical to the number of walvelength
points in the file \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} (see Section {\hyperref[\detokenize{inputoutputfiles:sec-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): wavelength\_micron.inp}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rstar{[}i{]}}}: The radius of star \(i\) in centimeters.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mstar{[}i{]}}}: The mass of star \(i\) in grams. This is not
important for the current version of RADMC\sphinxhyphen{}3D, but may be in the
future.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{xstar{[}i{]}}}: The \sphinxcode{\sphinxupquote{x}}\sphinxhyphen{}coordinate of star \(i\) in centimeters.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ystar{[}i{]}}}: The \sphinxcode{\sphinxupquote{y}}\sphinxhyphen{}coordinate of star \(i\) in centimeters.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zstar{[}i{]}}}: The \sphinxcode{\sphinxupquote{z}}\sphinxhyphen{}coordinate of star \(i\) in centimeters.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lambda{[}i{]}}}: Wavelength point \(i\) (where \(i\in
[1,\mathrm{nlam}]\)) in microns. This must be identical (!) to the equivalent
point in the file \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): wavelength\_micron.inp}}}}). If not, an error occurs.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flux{[}i,star=n{]}}}: The flux \(F_\nu\) at wavelength point \(i\) for
star \(n\) in units of
\(\mathrm{erg}\,\mathrm{cm}^{-2},\mathrm{s}^{-1},\mathrm{Hz}^{-1}\) as
seen from a distance of 1 parsec = \(3.08572\times 10^{18}\) cm (for
normalization).

\end{itemize}

\sphinxAtStartPar
Sometimes it may be sufficient to assume simple blackbody spectra
for these stars. If for any of the stars the first (!) flux number
(\sphinxcode{\sphinxupquote{flux{[}1,star=n{]}}}) is negative, then the absolute value of this number
is taken to be the blackbody temperature of the star, and no further values
for this star are read. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{1}            \PYG{l+m+mi}{100}
\PYG{l+m+mf}{6.96e10}      \PYG{l+m+mf}{1.99e33}        \PYG{l+m+mf}{0.}      \PYG{l+m+mf}{0.}    \PYG{l+m+mf}{0.}
\PYG{l+m+mf}{0.1}
  \PYG{o}{.}
  \PYG{o}{.}
\PYG{l+m+mf}{1000.}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5780.}
\end{sphinxVerbatim}

\sphinxAtStartPar
will make one star, at the center of the coordinate system, with one solar
radius, one solar mass, on a wavelength grid ranging from 0.1 micron to 1000
micron (100 wavelength points) and with a blackbody spectrum with a
temperature equal to the effective temperature of the sun.

\sphinxAtStartPar
Note: The position of a star can be both inside and outside of the
computational domain.


\section{INPUT (optional): stellarsrc\_templates.inp}
\label{\detokenize{inputoutputfiles:input-optional-stellarsrc-templates-inp}}\label{\detokenize{inputoutputfiles:sec-stellarsrc-templates}}
\sphinxAtStartPar
This is the file that specifies the template spectra for the smooth stellar
source distributions. See Section {\hyperref[\detokenize{stars:sec-distrib-of-stars}]{\sphinxcrossref{\DUrole{std,std-ref}{Distributions of zillions of stars}}}}.
The file exists only in formatted (ascii) style. Its structure is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
iformat                           \PYGZlt{}=== Put this to 2 !
ntempl
nlam
lambda[1]
  .
  .
lambda[nlam]
flux[1,templ=1]
  .
  .
flux[nlam,templ=1]
flux[1,templ=2]
  .
  .
flux[nlam,templ=2]
  .
  .
  .
  .
flux[nlam,templ=ntempl]
\end{sphinxVerbatim}

\sphinxAtStartPar
which is valid only if \sphinxcode{\sphinxupquote{iformat==2}}. The meaning of the variables:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat}}: The format number, at present better keep it at 2.
If you put it to 1, the list of wavelengths (see below) will instead be
a list of frequencies in Herz.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ntempl}}: The number of stellar templates you wish to specify.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nlam}}: The number of frequency points for the stellar
template spectra. At present this must be identical to the number of
walvelength points in the file \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} (see
Section {\hyperref[\detokenize{inputoutputfiles:sec-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): wavelength\_micron.inp}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lambda{[}i{]}}}: Wavelength point \(i\) (where \(i\in [1,\mathrm{nlam}]\))
in microns. This must be identical (!) to the
equivalent point in the file \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} (see
Section {\hyperref[\detokenize{inputoutputfiles:sec-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): wavelength\_micron.inp}}}}). If not, an error occurs.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flux{[}i,templ=n{]}}}: The ‘flux’ at wavelength \(i\) for
stellar template \(n\). The units are somewhat tricky. It is given in units
of erg / sec / Hz / gram\sphinxhyphen{}of\sphinxhyphen{}star. So multiply this by the density of
stars in units of gram\sphinxhyphen{}of\sphinxhyphen{}star / \(\mathrm{cm}^3\), and divide by 4*pi to get the
stellar source function in units of erg / src / Hz / \(\mathrm{cm}^3\) / steradian.

\end{itemize}

\sphinxAtStartPar
Sometimes it may be sufficient to assume simple blackbody spectra
for these stellar sources. If for any of the stellar sources the first (!)
flux number (\sphinxcode{\sphinxupquote{flux{[}1,templ=n{]}}}) is negative, then the absolute
value of this number is taken to be the blackbody temperature of the stellar
source, and the following two numbers are interpreted as the stellar radius
and stellar mass respectively. From that, RADMC\sphinxhyphen{}3D will then internally
compute the stellar template. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{100}
\PYG{l+m+mf}{0.1}
  \PYG{o}{.}
  \PYG{o}{.}
\PYG{l+m+mf}{1000.}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5780.}
\PYG{l+m+mf}{6.9600000e+10}
\PYG{l+m+mf}{1.9889200e+33}
\end{sphinxVerbatim}

\sphinxAtStartPar
will tell RADMC\sphinxhyphen{}3D that there is just one stellar template, assumed to have
a blackbody spectrum with solar effective temperature. Each star of this
template has one solar radius, one solar mass.


\section{INPUT (optional): stellarsrc\_density.inp}
\label{\detokenize{inputoutputfiles:input-optional-stellarsrc-density-inp}}\label{\detokenize{inputoutputfiles:sec-stellarsrc-density}}
\sphinxAtStartPar
This is the file that contains the smooth stellar source densities. If you
have the file \sphinxcode{\sphinxupquote{stellarsrc\_templates.inp}} specified (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-stellarsrc-templates}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (optional): stellarsrc\_templates.inp}}}}) then you \sphinxstyleemphasis{must} also specify \sphinxcode{\sphinxupquote{stellarsrc\_density.inp}} (or its binary form, see Chapter
{\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}}).  The format of this file is very similar to
\sphinxcode{\sphinxupquote{dust\_density.inp}} (Section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}), but instead
different dust species, we have different templates.  For the rest we refer
to Section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}} for the format.  Just replace \sphinxcode{\sphinxupquote{ispec}} (the dust species) with \sphinxcode{\sphinxupquote{itempl}} (the template).


\section{INPUT (optional): external\_source.inp}
\label{\detokenize{inputoutputfiles:input-optional-external-source-inp}}\label{\detokenize{inputoutputfiles:sec-ext-src-inp}}
\sphinxAtStartPar
This is the file that specifies the spectrum and intensity of the
external radiation field, i.e. the ‘interstellar radiation field’
(see Section {\hyperref[\detokenize{stars:sec-external-source}]{\sphinxcrossref{\DUrole{std,std-ref}{The interstellar radiation field: external source of energy}}}}). Its structure is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
iformat                           \PYGZlt{}=== Put this to 2 !
nlam
lambda[1]
  .
  .
lambda[nlam]
Intensity[1]
  .
  .
Intensity[nlam]
\end{sphinxVerbatim}

\sphinxAtStartPar
which is valid only if \sphinxcode{\sphinxupquote{iformat==2}}. The meaning of the variables:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat}}: The format number, at present better keep it at 2.
If you put it to 1, the list of wavelengths (see below) will instead be
a list of frequencies in Herz.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nlam}}: The number of frequency points for the stellar
template spectra. At present this must be identical to the number of
walvelength points in the file \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} (see
Section {\hyperref[\detokenize{inputoutputfiles:sec-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): wavelength\_micron.inp}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lambda{[}i{]}}}: Wavelength point \(i\) (where \(i\in [1,\mathrm{nlam}]\))
in microns. This must be identical (!) to the
equivalent point in the file \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} (see
Section {\hyperref[\detokenize{inputoutputfiles:sec-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): wavelength\_micron.inp}}}}). If not, an error occurs.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Intensity{[}i{]}}}: The intensity of the radiation field at
wavelength \(i\) in units of erg / \(\mathrm{cm}^2\) / sec / Hz / steradian.

\end{itemize}


\section{INPUT (optional): heatsource.inp}
\label{\detokenize{inputoutputfiles:input-optional-heatsource-inp}}\label{\detokenize{inputoutputfiles:sec-heatsource}}
\sphinxAtStartPar
This file, if present (it is an optional file!), gives the internal heat
source of the gas\sphinxhyphen{}dust mixture in every cell. For formatted style
(\sphinxcode{\sphinxupquote{heatsource.inp}}) the structure of this file is as follows.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{nrcells}
\PYG{n}{heatsource}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}
\PYG{n}{heatsource}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
As with most input/output files of RADMC\sphinxhyphen{}3D, you can also specify the input
data in binary form (\sphinxcode{\sphinxupquote{heatsource.binp}}), see Chapter
{\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}}.

\sphinxAtStartPar
The physical unit of \sphinxcode{\sphinxupquote{heatsource}} is
\(\mathrm{erg}\,\mathrm{cm}^{-3}\,\mathrm{s}^{-1}\). The total luminosity of
the heat source would then be the sum over all cells of \sphinxcode{\sphinxupquote{heatsource}} times the cell volume.


\section{INPUT (required): wavelength\_micron.inp}
\label{\detokenize{inputoutputfiles:input-required-wavelength-micron-inp}}\label{\detokenize{inputoutputfiles:sec-wavelengths}}
\sphinxAtStartPar
This is the file that sets the discrete wavelength points for the continuum
radiative transfer calculations. Note that this is not the same as the
wavelength grid used for e.g. line radiative transfer.  See Section
{\hyperref[\detokenize{inputoutputfiles:sec-camera-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (optional): camera\_wavelength\_micron.inp}}}} and/or Chapter {\hyperref[\detokenize{lineradtrans:chap-line-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Line radiative transfer}}}} for
that. This file is only in formatted (ascii) style. It’s structure is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nlam}
\PYG{k}{lambda}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
  \PYG{o}{.}
  \PYG{o}{.}
\PYG{k}{lambda}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
where
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nlam}}: The number of frequency points for the stellar
spectra.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lambda{[}i{]}}}: Wavelength point \(i\) (where \(i\in [1,\mathrm{nlam}]\)) in microns.

\end{itemize}

\sphinxAtStartPar
The list of wavelengths can be in increasing order or decreasing order, but
must be monotonically increasing/decreasing.

\sphinxAtStartPar
\sphinxstyleemphasis{IMPORTANT:} It is important to keep in mind that the wavelength
coverage must include the wavelengths at which the stellar spectra have most
of their energy, and at which the dust cools predominantly.  This in
practice means that this should go all the way from 0.1 \(\mu\)m to 1000
\(\mu\)m, typically logarithmically spaced (i.e. equally spaced in
\(\log(\lambda)\)). A smaller coverage will cause serious problems in the Monte
Carlo run and dust temperatures may then be severely miscalculated. Note
that the 0.1 \(\mu\)m is OK for stellar temperatures below 10000 K. For higher
temperatures a shorter wavelength lower limit must be used.


\section{INPUT (optional): camera\_wavelength\_micron.inp}
\label{\detokenize{inputoutputfiles:input-optional-camera-wavelength-micron-inp}}\label{\detokenize{inputoutputfiles:sec-camera-wavelengths}}
\sphinxAtStartPar
The wavelength points in the \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} file are the
global continuum wavelength points. On this grid the continuum transfer is
done. However, there may be various reasons why the user may want to
generate spectra on a different (usually more finely spaced) wavelength
grid, or make an image at a wavelength that is not available in the global
continuum wavelength grid. Rather than redoing the entire model with a
different \sphinxcode{\sphinxupquote{wavelength\_micron.inp}}, which may involve a lot of
reorganization and recomputation, the user can specify a file called \sphinxcode{\sphinxupquote{camera\_wavelength\_micron.inp}}. If this file exists, it will be read into
RADMC\sphinxhyphen{}3D, and the user can now ask RADMC\sphinxhyphen{}3D to make images in those
wavelength or make a spectrum in those wavelengths.

\sphinxAtStartPar
If the user wants to make images or spectra of a model that involves gas
lines (such as atomic lines or molecular rotational and/or ro\sphinxhyphen{}vibrational
lines), the use of a \sphinxcode{\sphinxupquote{camera\_wavelength\_micron.inp}} file allows
the user to do the line+dust transfer (gas lines plus the continuum) on this
specific wavelength grid. For line transfer there are also other ways by
which the user can specify the wavelength grid (see Chapter
{\hyperref[\detokenize{lineradtrans:chap-line-transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Line radiative transfer}}}}), and it is left to the user to choose which method
to use.

\sphinxAtStartPar
The structure of the \sphinxcode{\sphinxupquote{camera\_wavelength\_micron.inp}} file is
identical to that of \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-wavelengths}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required): wavelength\_micron.inp}}}}).

\sphinxAtStartPar
Note that there are also various other ways by which the user can let
RADMC\sphinxhyphen{}3D choose wavelength points, many of which may be even simpler
and more preferable than the method described here. See Section
{\hyperref[\detokenize{imagesspectra:sec-set-camera-frequencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}}}}.


\section{INPUT (required for dust transfer): dustopac.inp and dustkappa\_*.inp or dustkapscatmat\_*.inp or dust\_optnk\_*.inp}
\label{\detokenize{inputoutputfiles:input-required-for-dust-transfer-dustopac-inp-and-dustkappa-inp-or-dustkapscatmat-inp-or-dust-optnk-inp}}\label{\detokenize{inputoutputfiles:sec-opacities}}
\sphinxAtStartPar
These files specify the dust opacities to be used. More than one can be
specified, meaning that there will be more than one co\sphinxhyphen{}existing dust
species. Each of these species will have its own dust density specified
(see Section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}}). The opacity of each species is specified
in a separate file for each species. The \sphinxcode{\sphinxupquote{dustopac.inp}} file tells which
file to read for each of these species.


\subsection{The dustopac.inp file}
\label{\detokenize{inputoutputfiles:the-dustopac-inp-file}}\label{\detokenize{inputoutputfiles:sec-dustopac-inp-file}}
\sphinxAtStartPar
The file \sphinxcode{\sphinxupquote{dustopac.inp}} has the following structure, where an example
of 2 separate dust species is used:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                          \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Put} \PYG{n}{this} \PYG{n}{to} \PYG{l+m+mi}{2}
\PYG{n}{nspec}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{inputstyle}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{iquantum}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}                      \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Put} \PYG{n}{to} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{this} \PYG{n}{example}
\PYG{o}{\PYGZlt{}}\PYG{n}{name} \PYG{n}{of} \PYG{n}{dust} \PYG{n}{species} \PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{inputstyle}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{iquantum}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}                      \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Put} \PYG{n}{to} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{this} \PYG{n}{example}
\PYG{o}{\PYGZlt{}}\PYG{n}{name} \PYG{n}{of} \PYG{n}{dust} \PYG{n}{species} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
where:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat}}: Currently the format number is 2, and in this manual
we always assume it is 2.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nspec}}: The number of dust species that will be loaded.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inputstyle{[}i{]}}}: This number tells in which form the dust
opacity of dust species \(i\) is to be read:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{1} Use the \sphinxcode{\sphinxupquote{dustkappa\_*.inp}} input file
style (see Section {\hyperref[\detokenize{inputoutputfiles:sec-dustkappa-files}]{\sphinxcrossref{\DUrole{std,std-ref}{The dustkappa\_*.inp files}}}}).

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{10} Use the \sphinxcode{\sphinxupquote{dustkapscatmat\_*.inp}} input
file style (see Section {\hyperref[\detokenize{inputoutputfiles:sec-dustkapscatmat-files}]{\sphinxcrossref{\DUrole{std,std-ref}{The dustkapscatmat\_*.inp files}}}}).

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iquantum{[}i{]}}}: For normal thermal grains this is 0. If,
however, this grain species is supposed to be treated as a quantum\sphinxhyphen{}heated
grain, then non\sphinxhyphen{}zero values are to be specified. \sphinxstyleemphasis{NOTE: At the moment
the quantum heating is not yet implemented. Will be done in the
future, if users request it. Until then, please set this to 0!}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textless{}name of dust species i\textgreater{}}}: This is the name of the
dust species (without blank spaces). This name is then glued to the base
name of the opacity file (see above). For instance, if the name is
\sphinxcode{\sphinxupquote{enstatite}}, and \sphinxcode{\sphinxupquote{inputstyle==1}}, then the file to be
read is \sphinxcode{\sphinxupquote{dustkappa\_enstatite.inp}}.

\end{itemize}


\subsection{The dustkappa\_*.inp files}
\label{\detokenize{inputoutputfiles:the-dustkappa-inp-files}}\label{\detokenize{inputoutputfiles:sec-dustkappa-files}}
\sphinxAtStartPar
If you wish to use dust opacities that include the mass\sphinxhyphen{}weighted absorption
opacity \(\kappa_{\mathrm{abs}}\), the (optionally) mass\sphinxhyphen{}weighted scattering
opacity \(\kappa_{\mathrm{scat}}\), and (optionally) the anisotropy factor \(g\)
for scattering, you can do this with a file \sphinxcode{\sphinxupquote{dustkappa\_*.inp}} (set input style to 1 in
\sphinxcode{\sphinxupquote{dustopac.inp}}, see Section {\hyperref[\detokenize{inputoutputfiles:sec-dustopac-inp-file}]{\sphinxcrossref{\DUrole{std,std-ref}{The dustopac.inp file}}}}). With this kind of
opacity input file, scattering is included either isotropically or using the
Henyey\sphinxhyphen{}Greenstein function.  Using an opacity file of this kind does \sphinxstyleemphasis{not}
allow for full realistic scattering phase functions nor for
polarization. For that, you need \sphinxcode{\sphinxupquote{dustkapscatmat\_*.inp}}
files (see Section {\hyperref[\detokenize{inputoutputfiles:sec-dustkapscatmat-files}]{\sphinxcrossref{\DUrole{std,std-ref}{The dustkapscatmat\_*.inp files}}}}). Please refer to Section
{\hyperref[\detokenize{dustradtrans:sec-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{More about scattering of photons off dust grains}}}} for more information about how RADMC\sphinxhyphen{}3D treats
scattering.

\sphinxAtStartPar
If for dust species \sphinxcode{\sphinxupquote{\textless{}name\textgreater{}}} the \sphinxcode{\sphinxupquote{inputstyle}} in the \sphinxcode{\sphinxupquote{dustopac.inp}} file
is set to 1, then the file \sphinxcode{\sphinxupquote{dustkappa\_\textless{}name\textgreater{}.inp}} is sought and read. The
structure of this file is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Any amount of arbitrary}
\PYG{c+c1}{\PYGZsh{} comment lines that tell which opacity this is.}
\PYG{c+c1}{\PYGZsh{} Each comment line must start with an \PYGZsh{} or ; or ! character}
\PYG{n}{iformat}                     \PYG{o}{\PYGZlt{}}\PYG{o}{==} \PYG{n}{This} \PYG{n}{example} \PYG{o+ow}{is} \PYG{k}{for} \PYG{n}{iformat}\PYG{o}{==}\PYG{l+m+mi}{3}
\PYG{n}{nlam}
\PYG{k}{lambda}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{n}{kappa\PYGZus{}abs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}       \PYG{n}{kappa\PYGZus{}scat}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}      \PYG{n}{g}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
   \PYG{o}{.}                  \PYG{o}{.}                  \PYG{o}{.}              \PYG{o}{.}
   \PYG{o}{.}                  \PYG{o}{.}                  \PYG{o}{.}              \PYG{o}{.}
\PYG{k}{lambda}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}    \PYG{n}{kappa\PYGZus{}abs}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}   \PYG{n}{kappa\PYGZus{}scat}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}    \PYG{n}{g}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The meaning of these entries is:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat}}: If \sphinxcode{\sphinxupquote{iformat==1}}, then only the lambda and
kappa\_abs colums are present. In that case the scattering opacity is
assumed to be 0, i.e. a zero albedo is assumed. If \sphinxcode{\sphinxupquote{iformat==2}} also
kappa\_scat is read (third column). If \sphinxcode{\sphinxupquote{iformat==3}} (which is what is used in
the above example) then \sphinxstyleemphasis{also} the anisotropy factor \(g\) is included.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nlam}}: The number of wavelength points in this file. This
can be any number, and does not have to be the same as those of the
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}}. It is typically advisable to have a rather
large number of wavelength points.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lambda{[}i{]}}}: The wavelength point \(i\) in micron. This does
not have to be (and indeed typically is not) the same as the values in the
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}} file. Also for each opacity this list of
wavelengths can be different (and can be a different quantity of points).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kappa\_abs{[}i{]}}}: The absorption opacity \(\kappa_{\mathrm{abs}}\) in units of \(\mathrm{cm}^2\) per gram of dust.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kappa\_scat{[}i{]}}}: The scattering opacity \(\kappa_{\mathrm{abs}}\) in units of \(\mathrm{cm}^2\)
per gram of dust. Note that this column should only be included if
\sphinxcode{\sphinxupquote{iformat==2}} or higher.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{g{[}ilam{]}}}: The mean scattering angle
\(\langle\cos(\theta)\rangle\), often called \(g\). This will be used by
RADMC\sphinxhyphen{}3D in the Henyey\sphinxhyphen{}Greenstein scattering phase function. Note that
this column should only be included if \sphinxcode{\sphinxupquote{iformat==3}} or higher.

\end{itemize}

\sphinxAtStartPar
Once this file is read, the opacities will be mapped onto the global
wavelength grid of the \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} file. Since this mapping
always involve uncertainties and errors, a file \sphinxcode{\sphinxupquote{dustkappa\_*.inp\_used}} is created which lists the opacity how it
is remapped onto the global wavelength grid. This is only for you as the
user, so that you can verify what RADMC\sphinxhyphen{}3D has internally done. Note that if
the upper or lower edges of the wavelength domain of the \sphinxcode{\sphinxupquote{dustkappa\_*.inp}} file is within the domain of the \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} grid, some extrapolation will have to be done.  At
short wavelength this will simply be constant extrapolation while at long
wavelength a powerlaw extrapolation is done. Have a look at the \sphinxcode{\sphinxupquote{dustkappa\_*.inp\_used}} file to see how RADMC\sphinxhyphen{}3D has done this
in your particular case.


\subsection{The dustkapscatmat\_*.inp files}
\label{\detokenize{inputoutputfiles:the-dustkapscatmat-inp-files}}\label{\detokenize{inputoutputfiles:sec-dustkapscatmat-files}}
\sphinxAtStartPar
If you wish to treat scattering in a more realistic way than just the
Henyey\sphinxhyphen{}Greenstein non\sphinxhyphen{}polarized way, then you must provide RADMC\sphinxhyphen{}3D with
more information than is present in the \sphinxcode{\sphinxupquote{dustkappa\_xxx.inp}}
files: RADMC\sphinxhyphen{}3D will need the full scattering Müller matrix for all angles
of scattering (see e.g. the books by Mishchenko, or by Bohren \& Huffman or
by van de Hulst). For \sphinxstyleemphasis{randomly oriented particles} only 6 of these
matrix elements can be non\sphinxhyphen{}zero: \(Z_{11}\), \(Z_{12}=Z_{21}\), \(Z_{22}\),
\(Z_{33}\), \(Z_{34}=-Z_{43}\), \(Z_{44}\), where 1,2,3,4 represent the I,Q,U,V
Stokes parameters. Moreover, for randomly oriented particles there is only 1
scattering angle involved: the angle between the incoming and outgoing
radiation of the scattering event. This means that we must give RADMC\sphinxhyphen{}3D,
(for every wavelength and for a discrete set of scattering angles) a list of
values of these 6 matrix elements. These can be provided in a file
\sphinxcode{\sphinxupquote{dustkapscatmat\_xxx.inp}} (set input style to 10 in \sphinxcode{\sphinxupquote{dustopac.inp}}, see Section {\hyperref[\detokenize{inputoutputfiles:sec-dustopac-inp-file}]{\sphinxcrossref{\DUrole{std,std-ref}{The dustopac.inp file}}}}) which comes *  instead of* the \sphinxcode{\sphinxupquote{dustkappa\_xxx.inp}} file. Please refer to
Section {\hyperref[\detokenize{dustradtrans:sec-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{More about scattering of photons off dust grains}}}} for more information about how RADMC\sphinxhyphen{}3D treats
scattering.

\sphinxAtStartPar
If for dust species \sphinxcode{\sphinxupquote{\textless{}name\textgreater{}}} the \sphinxcode{\sphinxupquote{inputstyle}} in the
\sphinxcode{\sphinxupquote{dustopac.inp}} file is set to 10, then the file
\sphinxcode{\sphinxupquote{dustkapscatmat\_\textless{}name\textgreater{}.inp}}
is sought and read. The structure of this file is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Any amount of arbitrary}
\PYG{c+c1}{\PYGZsh{} comment lines that tell which opacity this is.}
\PYG{c+c1}{\PYGZsh{} Each comment line must start with an \PYGZsh{} or ; or ! character}
\PYG{n}{iformat}            \PYG{o}{\PYGZlt{}}\PYG{o}{==} \PYG{n}{Format} \PYG{n}{number} \PYG{n}{must} \PYG{n}{be} \PYG{l+m+mi}{1}
\PYG{n}{nlam}
\PYG{n}{nang}               \PYG{o}{\PYGZlt{}}\PYG{o}{==} \PYG{n}{A} \PYG{n}{reasonable} \PYG{n}{value} \PYG{o+ow}{is} \PYG{l+m+mi}{181} \PYG{p}{(}\PYG{n}{e}\PYG{o}{.}\PYG{n}{g}\PYG{o}{.} \PYG{n}{angle} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{1.0}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}\PYG{l+m+mf}{180.0}\PYG{p}{)}

\PYG{k}{lambda}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{n}{kappa\PYGZus{}abs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}       \PYG{n}{kappa\PYGZus{}scat}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}     \PYG{n}{g}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
   \PYG{o}{.}                  \PYG{o}{.}                  \PYG{o}{.}             \PYG{o}{.}
   \PYG{o}{.}                  \PYG{o}{.}                  \PYG{o}{.}             \PYG{o}{.}
\PYG{k}{lambda}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}    \PYG{n}{kappa\PYGZus{}abs}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}   \PYG{n}{kappa\PYGZus{}scat}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}   \PYG{n}{g}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}

\PYG{n}{angle\PYGZus{}in\PYGZus{}degrees}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
   \PYG{o}{.}
   \PYG{o}{.}
\PYG{n}{angle\PYGZus{}in\PYGZus{}degrees}\PYG{p}{[}\PYG{n}{nang}\PYG{p}{]}

\PYG{n}{Z\PYGZus{}11}  \PYG{n}{Z\PYGZus{}12}  \PYG{n}{Z\PYGZus{}22}  \PYG{n}{Z\PYGZus{}33}  \PYG{n}{Z\PYGZus{}34}  \PYG{n}{Z\PYGZus{}44}   \PYG{p}{[}\PYG{n+nb}{all} \PYG{k}{for} \PYG{n}{ilam}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o+ow}{and} \PYG{n}{iang}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{Z\PYGZus{}11}  \PYG{n}{Z\PYGZus{}12}  \PYG{n}{Z\PYGZus{}22}  \PYG{n}{Z\PYGZus{}33}  \PYG{n}{Z\PYGZus{}34}  \PYG{n}{Z\PYGZus{}44}   \PYG{p}{[}\PYG{n+nb}{all} \PYG{k}{for} \PYG{n}{ilam}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o+ow}{and} \PYG{n}{iang}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{Z\PYGZus{}11}  \PYG{n}{Z\PYGZus{}12}  \PYG{n}{Z\PYGZus{}22}  \PYG{n}{Z\PYGZus{}33}  \PYG{n}{Z\PYGZus{}34}  \PYG{n}{Z\PYGZus{}44}   \PYG{p}{[}\PYG{n+nb}{all} \PYG{k}{for} \PYG{n}{ilam}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o+ow}{and} \PYG{n}{iang}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{]}
 \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}
 \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}
\PYG{n}{Z\PYGZus{}11}  \PYG{n}{Z\PYGZus{}12}  \PYG{n}{Z\PYGZus{}22}  \PYG{n}{Z\PYGZus{}33}  \PYG{n}{Z\PYGZus{}34}  \PYG{n}{Z\PYGZus{}44}   \PYG{p}{[}\PYG{n+nb}{all} \PYG{k}{for} \PYG{n}{ilam}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o+ow}{and} \PYG{n}{iang}\PYG{o}{=}\PYG{n}{nang}\PYG{p}{]}

\PYG{n}{Z\PYGZus{}11}  \PYG{n}{Z\PYGZus{}12}  \PYG{n}{Z\PYGZus{}22}  \PYG{n}{Z\PYGZus{}33}  \PYG{n}{Z\PYGZus{}34}  \PYG{n}{Z\PYGZus{}44}   \PYG{p}{[}\PYG{n+nb}{all} \PYG{k}{for} \PYG{n}{ilam}\PYG{o}{=}\PYG{l+m+mi}{2} \PYG{o+ow}{and} \PYG{n}{iang}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
 \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}
 \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}
\PYG{n}{Z\PYGZus{}11}  \PYG{n}{Z\PYGZus{}12}  \PYG{n}{Z\PYGZus{}22}  \PYG{n}{Z\PYGZus{}33}  \PYG{n}{Z\PYGZus{}34}  \PYG{n}{Z\PYGZus{}44}   \PYG{p}{[}\PYG{n+nb}{all} \PYG{k}{for} \PYG{n}{ilam}\PYG{o}{=}\PYG{l+m+mi}{2} \PYG{o+ow}{and} \PYG{n}{iang}\PYG{o}{=}\PYG{n}{nang}\PYG{p}{]}

\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{n}{Z\PYGZus{}11}  \PYG{n}{Z\PYGZus{}12}  \PYG{n}{Z\PYGZus{}22}  \PYG{n}{Z\PYGZus{}33}  \PYG{n}{Z\PYGZus{}34}  \PYG{n}{Z\PYGZus{}44}   \PYG{p}{[}\PYG{n+nb}{all} \PYG{k}{for} \PYG{n}{ilam}\PYG{o}{=}\PYG{n}{nlam} \PYG{o+ow}{and} \PYG{n}{iang}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
 \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}
 \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}     \PYG{o}{.}
\PYG{n}{Z\PYGZus{}11}  \PYG{n}{Z\PYGZus{}12}  \PYG{n}{Z\PYGZus{}22}  \PYG{n}{Z\PYGZus{}33}  \PYG{n}{Z\PYGZus{}34}  \PYG{n}{Z\PYGZus{}44}   \PYG{p}{[}\PYG{n+nb}{all} \PYG{k}{for} \PYG{n}{ilam}\PYG{o}{=}\PYG{n}{nlam} \PYG{o+ow}{and} \PYG{n}{iang}\PYG{o}{=}\PYG{n}{nang}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The meaning of these entries is:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat}}: For now this value should remain 1.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nlam}}: The number of wavelength points in this file. This
can be any number, and does not have to be the same as those of the
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}}. It is typically advisable to have a rather
large number of wavelength points.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nang}}: The number of scattering angle sampling points.
This should be large enough that a proper integration over scattering angle
can be carried out reliably. A reasonable value is 181, so that (for
a regular grid in scattering angle \(\theta\)) you have as scattering angles
\(\theta=0,1,2,\cdots,180\) (in degrees). But if you have extremely forward\sphinxhyphen{}
or backward peaked scattering, then maybe even 181 is not enough.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lambda{[}ilam{]}}}: The wavelength point \sphinxcode{\sphinxupquote{ilam}} in micron. This does
not have to be (and indeed typically is not) the same as the values in the
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}} file. Also for each opacity this list of
wavelengths can be different (and can be a different quantity of points).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{angle\_in\_degrees{[}iang{]}}}: The scattering angle
sampling point \sphinxcode{\sphinxupquote{iang}} in degrees (0 degrees is perfect forward scattering,
180 degrees is perfect backscattering). There should be \sphinxcode{\sphinxupquote{nang}}
such points, where \sphinxcode{\sphinxupquote{angle\_in\_degrees{[}1{]}}} must be 0 and
\sphinxcode{\sphinxupquote{angle\_in\_degrees{[}nang{]}}} must be 180. In between the angle
grid can be anything, as long as it is monotonic.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kappa\_abs{[}ilam{]}}}: The absorption opacity \(\kappa_{\mathrm{abs}}\)
in units of \(\mathrm{cm}^2\) per gram of dust.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kappa\_scat{[}ilam{]}}}: The scattering opacity
\(\kappa_{\mathrm{scat}}\) in units of \(\mathrm{cm}^2\) per gram of dust. RADMC\sphinxhyphen{}3D can
(and will) in fact calculate \(\kappa_{\mathrm{scat}}\) from the scattering
matrix elements. It will then check (for every wavelength) if that is the
same as the value listed here. If the difference is small, it will simply
adjust the \sphinxcode{\sphinxupquote{kappa\_scat{[}ilam{]}}} value internally to get a
perfect match. If it is larger than 1E\sphinxhyphen{}4 then it will, in addition to
adjusting, make a warning. if it is larger than 1E\sphinxhyphen{}1, it will abort. Note
that the fewer angles are used, the worse the match will be because the
integration over angle will be worse.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{g{[}ilam{]}}}: The mean scattering angle
\(\langle\cos(\theta)\rangle\), often called \(g\). RADMC\sphinxhyphen{}3D can (and will) in
fact calculate \(g\) from the scattering matrix elements. Like with
\sphinxcode{\sphinxupquote{kappa\_scat{[}ilam{]}}} it will adjust if the difference is not
too large and it will complain or abort if the difference is larger than
some limit.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Z\_\{xx\}}} These are the scattering matrix elements
in units of \(\mathrm{cm}^2\, \mathrm{g}^{-1}\,\mathrm{ster}^{-1}\) (i.e. they are angular
differential cross sections). See Section {\hyperref[\detokenize{dustradtrans:sec-scattering}]{\sphinxcrossref{\DUrole{std,std-ref}{More about scattering of photons off dust grains}}}} for
more details.

\end{itemize}

\sphinxAtStartPar
NOTE: This only allows the treatment of \sphinxstyleemphasis{randomly oriented particles}. RADMC\sphinxhyphen{}3D
does not, for now, have the capability of treating scattering off fixed\sphinxhyphen{}oriented
particles. In fact, for oriented particles it would be impractical to
use dust opacity files of this kind, since we would then have at least \sphinxstyleemphasis{three}
scattering angles, which would require huge table. In that case it would be
presumably necessary to compute the matrix elements on\sphinxhyphen{}the\sphinxhyphen{}fly.

\sphinxAtStartPar
Note that the scattering\sphinxhyphen{}angle grid of the \sphinxcode{\sphinxupquote{dustkapscatmat\_xxx.inp}} files can
be chosen non\sphinxhyphen{}regular, e.g. to put a more finely spaced grid close to
\(\theta=0\) (forward scattering) and \(\theta=\pi\) (backscattering).
This can be useful for large grains and/or short wavelengths, where forward
scattering can be extremely strongly peaked. Since multiple dust species can
each have a different scattering \(\theta\)\sphinxhyphen{}grid, it requires you to give an
additional file to \sphinxcode{\sphinxupquote{RADMC\sphinxhyphen{}3D}} that represents the scattering
\(\theta\)\sphinxhyphen{}grid for all grains. This file is called
\sphinxcode{\sphinxupquote{scattering\_angular\_grid.inp}}. The format is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}            \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Format} \PYG{n}{number}\PYG{p}{,} \PYG{n}{must} \PYG{n}{be} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{181}          \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Nr} \PYG{n}{of} \PYG{n}{theta} \PYG{n}{grid} \PYG{n}{points}
\PYG{l+m+mf}{0.0}          \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{First} \PYG{n}{angle} \PYG{p}{(}\PYG{o+ow}{in} \PYG{n}{degrees}\PYG{p}{)}\PYG{o}{.} \PYG{n}{Must} \PYG{n}{be} \PYG{l+m+mi}{0}
\PYG{l+m+mf}{1.0}
\PYG{l+m+mf}{2.0}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mf}{179.0}
\PYG{l+m+mf}{180.0}        \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Last} \PYG{n}{angle} \PYG{p}{(}\PYG{o+ow}{in} \PYG{n}{degrees}\PYG{p}{)}\PYG{o}{.} \PYG{n}{Must} \PYG{n}{be} \PYG{l+m+mi}{180}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE:} This file is not compulsory. If it is not given, then
\sphinxcode{\sphinxupquote{RADMC\sphinxhyphen{}3D}} will make its own internal scattering angle grid.


\section{OUTPUT: spectrum.out}
\label{\detokenize{inputoutputfiles:output-spectrum-out}}\label{\detokenize{inputoutputfiles:sec-output-spectrum-out}}
\sphinxAtStartPar
Any spectrum that is made with RADMC\sphinxhyphen{}3D will be either called
\sphinxcode{\sphinxupquote{spectrum.out}} or \sphinxcode{\sphinxupquote{spectrum\_\textless{}somename\textgreater{}.out}} and will have
the following structure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                      \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{For} \PYG{n}{now} \PYG{n}{this} \PYG{o+ow}{is} \PYG{l+m+mi}{1}
\PYG{n}{nlam}

\PYG{k}{lambda}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}       \PYG{n}{flux}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
   \PYG{o}{.}              \PYG{o}{.}
   \PYG{o}{.}              \PYG{o}{.}
\PYG{k}{lambda}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}   \PYG{n}{flux}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
where:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat}}: This format number is currently set to 1.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nlam}}: The number of wavelength points in this spectrum.
This does not necessarily have to be the same as those in the
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}} file. It can be any number.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lambda{[}i{]}}}: Wavelength in micron.  This does not necessarily
have to be the same as those in the \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} file.
The wavelength grid of a spectrum file can be completely independent
of all other wavelength grids. For standard SED computations for the
continuum typically these will be indeed the same as those in the
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}} file. But for line transfer or for
spectra based on the \sphinxcode{\sphinxupquote{camera\_wavelength\_micron.inp}} they are
not.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flux{[}i{]}}}: Flux in units of
\(\mathrm{erg}\,\mathrm{s}^{-1}\,\mathrm{cm}^{-2}\,\mathrm{Hz}^{-1}\)
at this
wavelength as measured at a standard distance of 1 parsec (just as a way
of normalization).

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{NOTE: Maybe in the future a new iformat version will be possible
where more telescope information is given in the spectrum file.}


\section{OUTPUT: image.out or image\_****.out}
\label{\detokenize{inputoutputfiles:output-image-out-or-image-out}}\label{\detokenize{inputoutputfiles:sec-image-out}}
\sphinxAtStartPar
Any images that are produced by RADMC\sphinxhyphen{}3D will be written in a file called
\sphinxcode{\sphinxupquote{image.out}}. The file has the following structure (for the case
without Stokes parameters):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                      \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{For} \PYG{n}{now} \PYG{n}{this} \PYG{o+ow}{is} \PYG{l+m+mi}{1} \PYG{p}{(}\PYG{o+ow}{or} \PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{local} \PYG{n}{observer} \PYG{n}{mode}\PYG{p}{)}
\PYG{n}{im\PYGZus{}nx}        \PYG{n}{im\PYGZus{}ny}
\PYG{n}{nlam}
\PYG{n}{pixsize\PYGZus{}x}    \PYG{n}{pixsize\PYGZus{}y}
\PYG{k}{lambda}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{k}{lambda}\PYG{p}{[}\PYG{n}{nlam}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{n}{image}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{image}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
  \PYG{o}{.}
  \PYG{o}{.}
\PYG{n}{image}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{n}{im\PYGZus{}nx}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{image}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
  \PYG{o}{.}
  \PYG{o}{.}
\PYG{n}{image}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{n}{im\PYGZus{}nx}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{image}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{n}{im\PYGZus{}ny}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
  \PYG{o}{.}
  \PYG{o}{.}
  \PYG{o}{.}
\PYG{n}{image}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{n}{im\PYGZus{}nx}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{n}{im\PYGZus{}ny}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{n}{nlam}\PYG{p}{]}

\PYG{n}{image}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
  \PYG{o}{.}
  \PYG{o}{.}
  \PYG{o}{.}
  \PYG{o}{.}
\PYG{n}{image}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{n}{im\PYGZus{}nx}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{n}{im\PYGZus{}ny}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{n}{nlam}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
In most cases the nr of images (nr of wavelengths) is just 1, meaning only
one image is written (i.e. the img=2, …. img=nlam are not there, only
the img=1). The meaning of the various entries is:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat}}: This format number is currently set to 1

\end{itemize}

\sphinxAtStartPar
for images from an observer at infinity (default) and 2 for a local observer.
Note: For full\sphinxhyphen{}Stokes images it is 3, but then also the data changes a
bit, see below.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{im\_nx,im\_ny}}: The number of pixels in x and in y
direction of the image.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nlam}}: The number of images at different wavelengths that

\end{itemize}

\sphinxAtStartPar
are in this file. You can make a series of images at different wavelengths
in one go, and write them in this file. The wavelength belonging to each of
these images is listed below. The \sphinxcode{\sphinxupquote{nlam}} can be any number from 1 to
however large you want. Mostly one typically just makes an images at one
wavelength, meaning \sphinxcode{\sphinxupquote{nlam}}=1.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pixsize\_x,pixsize\_y}}: The size of the pixels in cm (for an observer at
infinity) or radian (for local observer mode).  This means that for the
observer\sphinxhyphen{}at\sphinxhyphen{}infinity mode (default) the size is given in model units (distance
within the 3\sphinxhyphen{}D model) and the user can, for any distance, convert this into
arcseconds: pixel size in arcsec = ( pixel size in cm / 1.496E13) / (distance
in parsec). The pixel size is the full size from the left of the pixel to the
right of the pixel (or from bottom to top).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lambda{[}i{]}}}: Wavelengths in micron belonging to the various images in this
file. In case \sphinxcode{\sphinxupquote{nlam}}=1 there will be here just a single number. Note that
this set of wavelengths can be completely independent of all other wavelength
grids.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{image{[}ix,iy,img{]}}}: Intensity in the image at pixel \sphinxcode{\sphinxupquote{ix}}, \sphinxcode{\sphinxupquote{iy}} at
wavelength \sphinxcode{\sphinxupquote{img}} (of the above listed wavelength points) in units of
\(\mathrm{erg}\,\mathrm{s}^{-1}\,\mathrm{cm}^{-2}\,\mathrm{Hz}^{-1}\,\mathrm{ster}^{-1}\).
\sphinxstyleemphasis{Important:}
The pixels are ordered from left to right (i.e. increasing \(x\)) in the
inner loop, and from bottom to top (i.e. increasing \(y\)) in the outer
loop.

\end{itemize}

\sphinxAtStartPar
You can also make images with full Stokes parameters. For this you must have
dust opacities that include the full scattering matrix, \sphinxstyleemphasis{and} you must
add the keyword \sphinxcode{\sphinxupquote{stokes}} to the \sphinxcode{\sphinxupquote{radmc3dimage}} command
on the command\sphinxhyphen{}line. In that case the \sphinxcode{\sphinxupquote{image.out}} file has the
following form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                      \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{For} \PYG{n}{Stokes} \PYG{n}{this} \PYG{o+ow}{is} \PYG{l+m+mi}{3}
\PYG{n}{im\PYGZus{}nx}        \PYG{n}{im\PYGZus{}ny}
\PYG{n}{nlam}
\PYG{n}{pixsize\PYGZus{}x}    \PYG{n}{pixsize\PYGZus{}y}
\PYG{k}{lambda}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{k}{lambda}\PYG{p}{[}\PYG{n}{nlam}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{n}{image\PYGZus{}I}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{image\PYGZus{}Q}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{image\PYGZus{}U}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{image\PYGZus{}V}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
  \PYG{o}{.}
  \PYG{o}{.}
\PYG{n}{image\PYGZus{}I}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{n}{im\PYGZus{}nx}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{(}\PYG{o+ow}{and} \PYG{n}{so} \PYG{n}{forth} \PYG{k}{for} \PYG{n}{Q} \PYG{n}{U} \PYG{o+ow}{and} \PYG{n}{V}\PYG{p}{)}
\PYG{n}{image\PYGZus{}I}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{(}\PYG{o+ow}{and} \PYG{n}{so} \PYG{n}{forth} \PYG{k}{for} \PYG{n}{Q} \PYG{n}{U} \PYG{o+ow}{and} \PYG{n}{V}\PYG{p}{)}
  \PYG{o}{.}
  \PYG{o}{.}
\PYG{n}{image\PYGZus{}I}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{n}{im\PYGZus{}nx}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{(}\PYG{o+ow}{and} \PYG{n}{so} \PYG{n}{forth} \PYG{k}{for} \PYG{n}{Q} \PYG{n}{U} \PYG{o+ow}{and} \PYG{n}{V}\PYG{p}{)}
\PYG{n}{image\PYGZus{}I}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{n}{im\PYGZus{}ny}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{(}\PYG{o+ow}{and} \PYG{n}{so} \PYG{n}{forth} \PYG{k}{for} \PYG{n}{Q} \PYG{n}{U} \PYG{o+ow}{and} \PYG{n}{V}\PYG{p}{)}
  \PYG{o}{.}
  \PYG{o}{.}
  \PYG{o}{.}
\PYG{n}{image\PYGZus{}I}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{n}{im\PYGZus{}nx}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{n}{im\PYGZus{}ny}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{n}{nlam}\PYG{p}{]} \PYG{p}{(}\PYG{o+ow}{and} \PYG{n}{so} \PYG{n}{forth} \PYG{k}{for} \PYG{n}{Q} \PYG{n}{U} \PYG{o+ow}{and} \PYG{n}{V}\PYG{p}{)}

\PYG{n}{image\PYGZus{}I}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{(}\PYG{o+ow}{and} \PYG{n}{so} \PYG{n}{forth} \PYG{k}{for} \PYG{n}{Q} \PYG{n}{U} \PYG{o+ow}{and} \PYG{n}{V}\PYG{p}{)}
  \PYG{o}{.}
  \PYG{o}{.}
  \PYG{o}{.}
  \PYG{o}{.}
\PYG{n}{image\PYGZus{}I}\PYG{p}{[}\PYG{n}{ix}\PYG{o}{=}\PYG{n}{im\PYGZus{}nx}\PYG{p}{,}\PYG{n}{iy}\PYG{o}{=}\PYG{n}{im\PYGZus{}ny}\PYG{p}{,}\PYG{n}{img}\PYG{o}{=}\PYG{n}{nlam}\PYG{p}{]} \PYG{p}{(}\PYG{o+ow}{and} \PYG{n}{so} \PYG{n}{forth} \PYG{k}{for} \PYG{n}{Q} \PYG{n}{U} \PYG{o+ow}{and} \PYG{n}{V}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
That is: instead of 1 number per line we now have 4 numbers per line, which
are the four Stokes parameters. Note that \sphinxcode{\sphinxupquote{iformat}}=3 to indicate
that we have now all four Stokes parameters in the image.


\section{INPUT: (minor input files)}
\label{\detokenize{inputoutputfiles:input-minor-input-files}}\label{\detokenize{inputoutputfiles:sec-minor-input-files}}
\sphinxAtStartPar
There is a number of lesser important input files, or input files that are
only read under certain circumstances (for instance when certain command
line options are given). Here they are described.


\subsection{The \sphinxstyleliteralintitle{\sphinxupquote{color\_inus.inp}} file (required with comm\sphinxhyphen{}line option ‘loadcolor’)}
\label{\detokenize{inputoutputfiles:the-color-inus-inp-file-required-with-comm-line-option-loadcolor}}\label{\detokenize{inputoutputfiles:sec-color-inus}}
\sphinxAtStartPar
The file \sphinxcode{\sphinxupquote{color\_inus.inp}} will only be read by RADMC\sphinxhyphen{}3D if on the command line
the option \sphinxcode{\sphinxupquote{loadcolor}} or \sphinxcode{\sphinxupquote{color}} is specified, and if the main action is
\sphinxcode{\sphinxupquote{image}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                      \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{For} \PYG{n}{now} \PYG{n}{this} \PYG{o+ow}{is} \PYG{l+m+mi}{1}
\PYG{n}{nlam}
\PYG{n}{ilam}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
  \PYG{o}{.}
  \PYG{o}{.}
\PYG{n}{ilam}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat}}: This format number is currently set to 1.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nlam}}: Number of wavelength indices specified here.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ilam{[}i{]}}}: The wavelength index for image i (the wavelength
index refers to the list of wavelengths in the \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} file.

\end{itemize}


\subsection{INPUT: \sphinxstyleliteralintitle{\sphinxupquote{aperture\_info.inp}}}
\label{\detokenize{inputoutputfiles:input-aperture-info-inp}}\label{\detokenize{inputoutputfiles:sec-aperture-info-file}}
\sphinxAtStartPar
If you wish to make spectra with wavelength\sphinxhyphen{}dependent collecting area, i.e.
aperture (see Section {\hyperref[\detokenize{imagesspectra:sec-aperture}]{\sphinxcrossref{\DUrole{std,std-ref}{Can one specify more realistic ‘beams’?}}}}), then you must prepare the file
\sphinxcode{\sphinxupquote{aperture\_info.inp}}. Here is its structure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                      \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{For} \PYG{n}{now} \PYG{n}{this} \PYG{o+ow}{is} \PYG{l+m+mi}{1}
\PYG{n}{nlam}
\PYG{k}{lambda}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}      \PYG{n}{rcol\PYGZus{}as}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
  \PYG{o}{.}            \PYG{o}{.}
  \PYG{o}{.}            \PYG{o}{.}
\PYG{k}{lambda}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}   \PYG{n}{rcol\PYGZus{}as}\PYG{p}{[}\PYG{n}{nlam}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
with
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iformat}}: This format number is currently set to 1.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nlam}}: Number of wavelength indices specified here. This
does \sphinxstyleemphasis{not} have to be the same as the number of wavelength of a
spectrum or the number of wavelengths specified in the file
\sphinxcode{\sphinxupquote{wavelength\_micron.inp}}. It can be any number.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lambda{[}i{]}}}: Wavelength sampling point, in microns. You can use
a course grid, as long as the range of wavelengths is large enough to
encompass all wavelengths you may wish to include in spectra.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rcol\_as{[}i{]}}}: The radius of the circular image mask used for
the aperture model, in units of arcsec.

\end{itemize}


\section{For developers: some details on the internal workings}
\label{\detokenize{inputoutputfiles:for-developers-some-details-on-the-internal-workings}}
\sphinxAtStartPar
There are several input files that can be quite large. Reading these files
into RADMC\sphinxhyphen{}3D memory can take time, so it is important not to read files
that are not required for the execution of the particular command at
hand. For instance, if a model exists in which both dust and molecular
lines are included, but RADMC\sphinxhyphen{}3D is called to merely make a continuum
SED (which in RADMC\sphinxhyphen{}3D never includes the lines), then it would be a
waste of time to let RADMC\sphinxhyphen{}3D read all the gas velocity and temperature
data and level population data into memory if they are not used.

\sphinxAtStartPar
To avoid unnecessary reading of large files the reading of these files is
usually organized in a ‘read when required’ way. Any subroutine in the code
that relies on e.g. line data to be present in memory can simply call the
routine \sphinxcode{\sphinxupquote{read\_lines\_all(action)}} with argument \sphinxcode{\sphinxupquote{action}} being 1,
i.e.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{call} \PYG{n}{read\PYGZus{}lines\PYGZus{}all}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This routine will check if the data are present: if no, it will read them,
if yes, it will return without further action. This means that you can call
\sphinxcode{\sphinxupquote{read\_lines\_all(1)}} as often as you want: the line data will be read
once, and only once. If you look through the code you will therefore find
that many \sphinxcode{\sphinxupquote{read\_***}} routines are called abundantly, whenever the
program wants to make sure that certain data is present. The advantage is
then that the programmer does not have to have a grand strategy for when
which data must be read in memory: he/she simply inserts a call to the read
routines for all the data she/he needs at that particular point in the
program, (always with action=1), and it will organize itself. If certain
data is nowhere needed, they will not be read.

\sphinxAtStartPar
All these \sphinxcode{\sphinxupquote{read\_***}} routines with argument \sphinxcode{\sphinxupquote{action}} can also
be called with \sphinxcode{\sphinxupquote{action=2}}. This will force the routine to (re\sphinxhyphen{})read
these data. But this is rarely needed.

\sphinxstepscope


\chapter{Binary I/O files}
\label{\detokenize{binaryio:binary-i-o-files}}\label{\detokenize{binaryio:chap-binary-io}}\label{\detokenize{binaryio::doc}}

\section{Overview}
\label{\detokenize{binaryio:overview}}\label{\detokenize{binaryio:sec-unformatted-overview}}
\sphinxAtStartPar
By default all input and output files of RADMC\sphinxhyphen{}3D are in ASCII (i.e.text)
form. This makes it easier to verify if the files are ok. Also, it is easier
to produce files with the right format and read the output of RADMC\sphinxhyphen{}3D. The
disadvantage is that ASCII files are substantially larger than strictly
required to store their information content. For large models, i.e.models
with many grid points, this may lead to unpractically large files.

\sphinxAtStartPar
RADMC\sphinxhyphen{}3D supports a more compact data format: binary data. In this form, a
double precision variable occupies just 8 bytes, while a single precision
variable occupies just 4 bytes.

\sphinxAtStartPar
Unfortunately, Fortran\sphinxhyphen{}90 and Fortran\sphinxhyphen{}95 did, for a long time, not support true
binary files. Instead they offered ‘f77\sphinxhyphen{}unformatted’ files, which uses
‘records’, and is harder to read than true binary files. Recently, however, many
Fortran\sphinxhyphen{}90 and Fortran\sphinxhyphen{}95 compilers have introduced a true binary format, which
is called ‘streaming access’. It is, actually, a Fortran\sphinxhyphen{}2003 feature, but has
been retroactively implemented into Fortran\sphinxhyphen{}90 and Fortran\sphinxhyphen{}95. The gfortran and
g95 compilers have it. Also the ifort compiler has it. Presumably others as
well.

\sphinxAtStartPar
RADMC\sphinxhyphen{}3D offers a binary I/O capability. A file containing three double
precision variables will have a length of exactly 24 bytes. Files with this
format will have extensions such as \sphinxcode{\sphinxupquote{.binp}}, \sphinxcode{\sphinxupquote{.bdat}} or \sphinxcode{\sphinxupquote{.bout}}.

\sphinxAtStartPar
Here is a (presumably incomplete) list of files that have binary versions:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
Name
&
\sphinxAtStartPar
ascii
&
\sphinxAtStartPar
binary
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dust\_density}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.inp}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.binp}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dust\_temperature}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.inp}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.binp}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dust\_temperature}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.dat}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.bdat}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gas\_density}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.inp}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.binp}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gas\_temperature}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.inp}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.binp}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{electron\_numdens}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.inp}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.binp}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ion\_numdens}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.inp}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.binp}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{levelpop\_***}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.dat}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.bdat}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{numberdens\_***}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.inp}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.binp}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gas\_velocity}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.inp}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.binp}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{microturbulence}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.inp}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.binp}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stellarsrc\_density}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.inp}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.binp}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mean\_intensity}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.out}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.bout}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{heatsource}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.inp}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.binp}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{How to switch to binary (or back to ascii)}
\label{\detokenize{binaryio:how-to-switch-to-binary-or-back-to-ascii}}\label{\detokenize{binaryio:sec-switch-to-binary}}
\sphinxAtStartPar
Specifying whether RADMC\sphinxhyphen{}3D should use ASCII or binary \sphinxstyleemphasis{input} is easy: It will
simply look which extension each input file has, and read it accordingly. If you
present RADMC\sphinxhyphen{}3D file input files with extension \sphinxcode{\sphinxupquote{.binp}}, it will read these
files as binaries.

\sphinxAtStartPar
More tricky is how to tell RADMC\sphinxhyphen{}3D to use binary files on \sphinxstyleemphasis{output}. By default,
RADMC\sphinxhyphen{}3D will always write ASCII style (\sphinxcode{\sphinxupquote{.out}} and \sphinxcode{\sphinxupquote{.dat}}). However, if
you add the following line to the \sphinxcode{\sphinxupquote{radmc3d.inp}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rto\PYGZus{}style} \PYG{o}{=} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\sphinxAtStartPar
it will instead use binary output (\sphinxcode{\sphinxupquote{.bout}} and \sphinxcode{\sphinxupquote{.bdat}}). And, for
completeness (though it is the default anyway), if you set \sphinxcode{\sphinxupquote{rto\_style=1}}
RADMC\sphinxhyphen{}3D will write output in ASCII form. Note that \sphinxcode{\sphinxupquote{rto\_style = 2}} is
the old Fortran unformatted data format, which is deprecated.

\sphinxAtStartPar
For the binary form of output you can also tell RADMC\sphinxhyphen{}3D to use single\sphinxhyphen{}precision
for the main data, to produce smaller output files. This is done by adding the
following line to the \sphinxcode{\sphinxupquote{radmc3d.inp}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rto\PYGZus{}single} \PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
By default RADMC\sphinxhyphen{}3D will always output double precision in the binary format.

\sphinxAtStartPar
\sphinxstyleemphasis{Note:} Images are still outputted in ascii even if you have \sphinxcode{\sphinxupquote{rto\_style=3}}. This is because images are rarely files of huge size, and ascii files are
easier to analyze and check. However, sometimes images can be still quite big
(e.g.if you make multi\sphinxhyphen{}frequency images). Then it might still be useful to
output binary. If you want to also have the images in binary format, you must
set

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{writeimage\PYGZus{}unformatted} \PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file, \sphinxstyleemphasis{or} you add a keyword \sphinxstyleemphasis{imageunform}.


\section{Binary I/O file format of RADMC\sphinxhyphen{}3D}
\label{\detokenize{binaryio:binary-i-o-file-format-of-radmc-3d}}\label{\detokenize{binaryio:sec-binary-io}}
\sphinxAtStartPar
The general format of the files listed in Section
{\hyperref[\detokenize{binaryio:sec-unformatted-overview}]{\sphinxcrossref{\DUrole{std,std-ref}{Overview}}}} is similar to the ASCII versions, just binary
this time. There is \sphinxstyleemphasis{one} additional number in the binary version: Right after
the format number comes an integer that gives the precision of the main
data. This number is either 4, meaning that the main data consists of 4\sphinxhyphen{}byte
floating point numbers (i.e.single precision), or 8, meaning that the main
data consists of 8\sphinxhyphen{}byte floating point numbers (i.e.double precision). Other
than that additional number, the order of the data is the same.

\sphinxAtStartPar
The following rules apply:
\begin{itemize}
\item {} 
\sphinxAtStartPar
With the exception of the \sphinxcode{\sphinxupquote{amr\_grid.binp}} file (see below),
all integers are 8\sphinxhyphen{}byte integers.

\item {} 
\sphinxAtStartPar
Floating point numbers for the main data (i.e.the data that
represents the space\sphinxhyphen{}dependent variables) are either 4\sphinxhyphen{}byte (single) or
8\sphinxhyphen{}byte (double) precision numbers. Which of the two is specified in the
second integer of the file (the integer right after the format number,
see above).

\item {} 
\sphinxAtStartPar
All other floating point numbers are double precision (i.e.8\sphinxhyphen{}byte
floats).

\item {} 
\sphinxAtStartPar
For AMR\sphinxhyphen{}grids the \sphinxcode{\sphinxupquote{amr\_grid.binp}} file contains a huge list
of 0 or 1 numbers (see Section {\hyperref[\detokenize{inputoutputfiles:sec-amr-grid-oct-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{Oct\sphinxhyphen{}tree\sphinxhyphen{}style AMR grid}}}}). Since it is
silly to use 8\sphinxhyphen{}byte integers for numbers that are either 0 or 1, the
numbers in this list are 1\sphinxhyphen{}byte integers (bytes).

\end{itemize}

\sphinxAtStartPar
Example: According to Section {\hyperref[\detokenize{inputoutputfiles:sec-dustdens}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dust\_density.inp}}}} the ASCII file
\sphinxcode{\sphinxupquote{dust\_density.inp}} file has the following format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{nrcells}
\PYG{n}{nrspec}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}
\PYG{n}{density}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}
\PYG{n}{density}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{n}{nrspec}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
According to the above listed rules the binary file \sphinxcode{\sphinxupquote{dust\_density.binp}} file
then has the following format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{iformat}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{precis}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{nrcells}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{nrspec}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{density}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{density}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{n}{nrspec}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
where the \sphinxcode{\sphinxupquote{\textless{}int8:precis=8\textgreater{}}} means that this is an 8\sphinxhyphen{}byte integer that we call
‘precis’ (the name is irrelevant here), and it has value 8, and
\sphinxcode{\sphinxupquote{\textless{}dbl8:density{[}1,ispec=1{]}\textgreater{}}} means that this is a double\sphinxhyphen{}precision number
(8\sphinxhyphen{}byte float). In other words: the first 8 bytes of the file contain the format
number (which is 1 at present). The second 8 bytes contain the number 8, telling
that the main data (i.e.the \sphinxcode{\sphinxupquote{density}} data) are double precision
variables. The third set of 8 bytes gives the number of cells, while the fourth
set gives the number of dust species. The data of \sphinxcode{\sphinxupquote{density}} starts as of the
33rd byte of the file. If you want to compress the file even further, and you
are satisfied with single\sphinxhyphen{}precision data, then the file would look like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{iformat}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{precis}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{nrcells}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{nrspec}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{density}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{density}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{density}\PYG{p}{[}\PYG{n}{nrcells}\PYG{p}{,}\PYG{n}{ispec}\PYG{o}{=}\PYG{n}{nrspec}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Another example: According to Section {\hyperref[\detokenize{dustradtrans:sec-dust-monochromatic-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Special\sphinxhyphen{}purpose feature: Computing the local radiation field}}}}
RADMC\sphinxhyphen{}3D can compute the mean intensity of radiation at each grid point at a set
of pre\sphinxhyphen{}defined frequencies, and write this out to an ASCII file called
\sphinxcode{\sphinxupquote{mean\_intensity.out}}. The contents of this file are:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iformat}                                  \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Typically} \PYG{l+m+mi}{2} \PYG{n}{at} \PYG{n}{present}
\PYG{n}{nrcells}
\PYG{n}{nfreq}                                    \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Nr} \PYG{n}{of} \PYG{n}{frequencies}
\PYG{n}{freq\PYGZus{}1} \PYG{n}{freq\PYGZus{}2} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{freq\PYGZus{}nfreq}             \PYG{o}{\PYGZlt{}}\PYG{o}{==}\PYG{o}{=} \PYG{n}{List} \PYG{n}{of} \PYG{n}{frequencies} \PYG{o+ow}{in} \PYG{n}{Hz}
\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{n}{nrcells}\PYG{p}{]}
\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{n}{nrcells}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{meanint}\PYG{p}{[}\PYG{n}{nfreq}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{meanint}\PYG{p}{[}\PYG{n}{nfreq}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{meanint}\PYG{p}{[}\PYG{n}{nfreq}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{n}{nrcells}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
By setting \sphinxcode{\sphinxupquote{rto\_style=3}} in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file, however, RADMC\sphinxhyphen{}3D will
instead produce a binary file called \sphinxcode{\sphinxupquote{mean\_intensity.bout}}, which has the
contents:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{iformat}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{precis}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{nrcells}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{nfreq}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{freq\PYGZus{}1}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{freq\PYGZus{}2}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{freq\PYGZus{}nfreq}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{n}{nrcells}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{n}{nrcells}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{n}{nfreq}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{n}{nfreq}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{n}{nfreq}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{n}{nrcells}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you also set \sphinxcode{\sphinxupquote{rto\_single=1}} in the \sphinxcode{\sphinxupquote{radmc3d.inp}} file, then you
will get:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{iformat}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{precis}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{nrcells}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{int8}\PYG{p}{:}\PYG{n}{nfreq}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{freq\PYGZus{}1}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{freq\PYGZus{}2}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{dbl8}\PYG{p}{:}\PYG{n}{freq\PYGZus{}nfreq}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{n}{nrcells}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{n}{nrcells}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{n}{nfreq}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{n}{nfreq}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{flt4}\PYG{p}{:}\PYG{n}{meanint}\PYG{p}{[}\PYG{n}{nfreq}\PYG{p}{,}\PYG{n}{icell}\PYG{o}{=}\PYG{n}{nrcells}\PYG{p}{]}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that only the mean intensity data (the main data) are single precision
floats.

\sphinxstepscope


\chapter{Command\sphinxhyphen{}line options}
\label{\detokenize{clioptions:command-line-options}}\label{\detokenize{clioptions:chap-command-line-options}}\label{\detokenize{clioptions::doc}}
\sphinxAtStartPar
This chapter deals with all the possible command\sphinxhyphen{}line options one can
give when calling the \sphinxcode{\sphinxupquote{radmc3d}} code.


\section{Main commands}
\label{\detokenize{clioptions:main-commands}}
\sphinxAtStartPar
In addition to the radmc3d.inp file, which contains many ‘steering’ parameters,
one can (and even must) give RADMC\sphinxhyphen{}3D also command\sphinxhyphen{}line options. The most
important (and compulsory) options are the ‘command’ what RADMC\sphinxhyphen{}3D should do.
At the moment you can choose from:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mctherm}}: Runs RADMC\sphinxhyphen{}3D for computing the dust
temperatures using the Monte Carlo method.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{spectrum}}: Runs RADMC\sphinxhyphen{}3D for making a spectrum based
on certain settings. This option requires further command\sphinxhyphen{}line
specifications. See chapter {\hyperref[\detokenize{imagesspectra:chap-images-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making images and spectra}}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sed}}: Runs RADMC\sphinxhyphen{}3D for making a SED based on certain
settings. This option requires further command\sphinxhyphen{}line specifications.  Note
that a SED is like a spectrum, but for continuum processes only (no
lines). See chapter {\hyperref[\detokenize{imagesspectra:chap-images-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making images and spectra}}}} for more details.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{image}}: Runs RADMC\sphinxhyphen{}3D for making an image.  This option
requires further command\sphinxhyphen{}line specifications. See chapter
{\hyperref[\detokenize{imagesspectra:chap-images-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making images and spectra}}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{movie}}: Like \sphinxcode{\sphinxupquote{image}}, but now for a series of different
vantage points. Useful for making movies in one go, without having to call
RADMC\sphinxhyphen{}3D time and again. \sphinxstyleemphasis{NOTE: This command is still under
development}. See chapter {\hyperref[\detokenize{imagesspectra:chap-images-spectra}]{\sphinxcrossref{\DUrole{std,std-ref}{Making images and spectra}}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcmono}}: (Only expect use). Runs RADMC\sphinxhyphen{}3D for computing
the local radiation field at each location in the model. This is only
useful for when you wish to couple RADMC\sphinxhyphen{}3D to models of chemistry or so,
which need the local radiation field. See Section
{\hyperref[\detokenize{dustradtrans:sec-dust-monochromatic-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Special\sphinxhyphen{}purpose feature: Computing the local radiation field}}}}.

\end{itemize}

\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{radmc3d} \PYG{n}{mctherm}
\end{sphinxVerbatim}

\sphinxAtStartPar
runs the RADMC\sphinxhyphen{}3D code for computing the dust temperatures everywhere using the
Monte Carlo method.

\sphinxAtStartPar
There are also some additional commands that may be useful for diagnostics:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subbox\_****}}: where **** is one of the following:
\sphinxcode{\sphinxupquote{dust\_density}}, \sphinxcode{\sphinxupquote{dust\_temperature}}. But other
quantities will follow in later versions. See Section {\hyperref[\detokenize{toolsinside:sec-subbox}]{\sphinxcrossref{\DUrole{std,std-ref}{Making a regularly\sphinxhyphen{}spaced datacube (‘subbox’) of AMR\sphinxhyphen{}based models}}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{linelist}}: Write a list of all the lines included in
this model.

\end{itemize}


\section{Additional arguments: general}
\label{\detokenize{clioptions:additional-arguments-general}}
\sphinxAtStartPar
Here is a list of command line options, on top of the above listed main
commands (Note: We’ll try to be complete, but as the code develops we may
forget to list new options here):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{setthreads}} {[}for MC{]} The next number sets the number of OpenMP parallel threads
to be used.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{npix}}: {[}for images{]} The next number specifies the number of
pixels in both x and y direction, assuming a square image.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{npixx}}: {[}for images{]} The next number specifies the number of
pixels in x direction only.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{npixy}}: {[}for images{]} The next number specifies the number of
pixels in y direction only.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nrrefine}}: {[}for images and spectra{]} Specifies a maximum depth of
refinement of the pixels (see Section {\hyperref[\detokenize{imagesspectra:sec-image-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{The issue of flux conservation: recursive sub\sphinxhyphen{}pixeling}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fluxcons}}: {[}for images and spectra{]} Puts nrrefine (see above) to
a large value to assue flux conservation (see Section {\hyperref[\detokenize{imagesspectra:sec-image-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{The issue of flux conservation: recursive sub\sphinxhyphen{}pixeling}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{norefine}}: {[}for images and spectra{]} Puts
nrrefine (see above) to 0 so that each pixel of the image corresponds only
to 1 ray. This is fast but not reliable and therefore not recommended (see
Section {\hyperref[\detokenize{imagesspectra:sec-image-refinement}]{\sphinxcrossref{\DUrole{std,std-ref}{The issue of flux conservation: recursive sub\sphinxhyphen{}pixeling}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nofluxcons}}: {[}for images and spectra{]} As
\sphinxcode{\sphinxupquote{norefine}} above.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{noscat}}: This option makes RADMC\sphinxhyphen{}3D ignore the
dust scattering process (though not the scattering extinction!) in the
images, spectra and Monte Carlo simulations. For images and spectra this
means that no scattering Monte Carlo run has to be performed before each
image ray tracing (see Section {\hyperref[\detokenize{dustradtrans:sec-scat-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Scattered light in images and spectra: The ‘Scattering Monte Carlo’ computation}}}}). This can speed
up the making of images or spectra enormously. This is even more so if you
make images/spectra of gas lines with LTE, LVG or ESCP methods, because if
no scattering Monte Carlo needs to be made, ray\sphinxhyphen{}tracing can be done
multi\sphinxhyphen{}frequency for each ray, and the populations can be calculated once
in each cell, and used for all frequencies. That can speed up the line
rendering enormously \textendash{} of course at the cost of not including dust
scattering. For lines in the infrared and submillimeter, if no large
grains are present, this is usually OK, because small grains (smaller than
about 1 micron) have very low scattering albedos in the infrared and
submillimeter.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ilambda}} or \sphinxcode{\sphinxupquote{inu}}: {[}for images{]} Specify the index of the wavelength
from the \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} file for which a ray\sphinxhyphen{}trace image should be
made.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{color}}: {[}for images{]} Allows you to make multiple
images (each at a different wavelength) in one go. This will make RADMC\sphinxhyphen{}3D
read the file \sphinxcode{\sphinxupquote{color\_inus.inp}} (see Section
{\hyperref[\detokenize{inputoutputfiles:sec-minor-input-files}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: (minor input files)}}}}) which is a list of indices \sphinxcode{\sphinxupquote{i}}
referring to the \sphinxcode{\sphinxupquote{wavelength\_micron.inp}} file for which the
images should be made. See Section {\hyperref[\detokenize{imagesspectra:sec-set-camera-frequencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}}}} for
details.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{loadcolor}}: {[}for images{]} Same as \sphinxcode{\sphinxupquote{color}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{loadlambda}}: {[}for images{]} Allows you to make multiple images (each at a
different wavelength) in one go. This will make RADMC\sphinxhyphen{}3D read the file
\sphinxcode{\sphinxupquote{camera\_wavelength\_micron.inp}} to read the precise wavelength points at which you wish
to make the images. In contrast to \sphinxcode{\sphinxupquote{loadcolor}}, which only allows you to
pick from the global set of wavelength used by the Monte Carlo simulation (in
the file \sphinxcode{\sphinxupquote{wavelength\_micron.inp}}), with the
\sphinxcode{\sphinxupquote{camera\_wavelength\_micron.inp}} files you can
specify any wavelength you want, and any number of them. See Section
{\hyperref[\detokenize{imagesspectra:sec-set-camera-frequencies}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying custom\sphinxhyphen{}made sets of wavelength points for the camera}}}} for details.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sizeau}}: {[}for images and spectra{]} The next number
specifies the image size in model space in units of AU (=1.496E13
cm). This image size is measured from the image left to
right and top to bottom. This gives always square images. This image
size in au is observer distance independent. The corresponding image
size in arcsec is: image size in arcsec = image size in AU /
(distance in parsec).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sizepc}}: {[}for images and spectra{]} Same as \sphinxcode{\sphinxupquote{sizeau}}, but
now in parsec units.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zoomau}}: {[}for images and spectra{]} The next four numbers set the image
window precisely by specifying the xleft, xright, ybottom, ytop of the image
in units of AU. The zero point of the image (the direction of the 2\sphinxhyphen{}D image
point located at (0.0,0.0) in image coordinates) stays the same (i.e. it aims
toward the 3\sphinxhyphen{}D point in model space given by \sphinxcode{\sphinxupquote{pointau}} or \sphinxcode{\sphinxupquote{pointpc}}). In
this way you can move the image window left or with or up or down without
having to change the \sphinxcode{\sphinxupquote{pointau}} or \sphinxcode{\sphinxupquote{pointpc}} 3\sphinxhyphen{}D locations. Also for local
perspective images it is different if you move the image window in the image
plane, or if you actually change the direction in which you are looking (for
images from infinity this is the same). \sphinxstyleemphasis{Note:} If you use this option
without the \sphinxcode{\sphinxupquote{truepix}} option RADMC\sphinxhyphen{}3D will always make square pixels by
adapting \sphinxcode{\sphinxupquote{npixx}} or \sphinxcode{\sphinxupquote{npixy}} such that together with the \sphinxcode{\sphinxupquote{zoomau}} image
size you get approximately square pixels. Furthermore, if \sphinxcode{\sphinxupquote{truezoom}} is not
set, RADMC\sphinxhyphen{}3D will alleviate the remaining tiny deviation from square pixel
shape by slightly (!) adapting the \sphinxcode{\sphinxupquote{zoomau}} window to obtain exactly square
pixels.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zoompc}}: {[}for images and spectra{]} Same as \sphinxcode{\sphinxupquote{zoomau}}, but
now the four numbers are given in units of parsec.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{truepix}}: {[}for images and spectra{]} If with \sphinxcode{\sphinxupquote{zoomau}} or \sphinxcode{\sphinxupquote{zoompc}} the
image window is not square then when specifying \sphinxcode{\sphinxupquote{npix}} one gets non\sphinxhyphen{}square
pixels. Without the \sphinxcode{\sphinxupquote{truepix}} option RADMC\sphinxhyphen{}3D will adapt the \sphinxcode{\sphinxupquote{npixx}} or
\sphinxcode{\sphinxupquote{npixy}} number, and subsequently modify the zoom window a bit such that the
pixels are square. With the \sphinxcode{\sphinxupquote{truepix}} option RADMC\sphinxhyphen{}3D will not change
\sphinxcode{\sphinxupquote{npixx}} nor \sphinxcode{\sphinxupquote{npixy}} and will allow non\sphinxhyphen{}square pixels to form.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{truezoom}}: {[}for images and spectra{]} If set, RADMC\sphinxhyphen{}3D will always assure
that the exact zoom window (specified with \sphinxcode{\sphinxupquote{zoomau}} or \sphinxcode{\sphinxupquote{zoompc}})
will be used, i.e. if \sphinxcode{\sphinxupquote{truepix}} is \sphinxstyleemphasis{not} set but \sphinxcode{\sphinxupquote{truezoom}}
is set, RADMC\sphinxhyphen{}3D will only (!) adapt \sphinxcode{\sphinxupquote{npixx}} or \sphinxcode{\sphinxupquote{npixy}} to get
\sphinxstyleemphasis{approximately} square pixels.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pointau}}: {[}for images and spectra{]} The subsequent three
numbers specify a 3\sphinxhyphen{}D location in model space toward which the camera is
pointing for images and spectra.  The (0,0) coordinate in the image plane
corresponds by definition to a ray going right through this 3\sphinxhyphen{}D point.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pointpc}}: {[}for images and spectra{]} Same as \sphinxcode{\sphinxupquote{pointau}} but
now in units of parsec.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{incl}}: {[}for images and spectra{]} For the case when the camera
is at infinity (i.e. at a large distance so that no local perspective has
to be taken into account) this inclination specifies the direction toward
which the camera for images and spectra is positioned. Incl = 0 means
toward the positive \(z\)\sphinxhyphen{}axis (in cartesian space), incl=90 means toward a
position in the \(x\)\sphinxhyphen{}\(y\)\sphinxhyphen{}plane and incl=180 means toward the negative
\(z\)\sphinxhyphen{}axis. The angle is given in degrees.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{phi}}: {[}for images and spectra{]} Like \sphinxcode{\sphinxupquote{incl}}, but now the remaining
angle, also given in degrees. Examples: \sphinxcode{\sphinxupquote{incl}}=90 and \sphinxcode{\sphinxupquote{phi}}=0 means
that the observer is located at infinity toward the negative \(y\) axis;
\sphinxcode{\sphinxupquote{incl}}=90 and \sphinxcode{\sphinxupquote{phi}}=90 means that the observer is located at infinity
toward the negative \(x\) axis; \sphinxcode{\sphinxupquote{incl}}=90 and \sphinxcode{\sphinxupquote{phi}}=180 means that
the observer is located at infinity toward the positive \(y\) axis
(looking back in negative \(y\) direction). Rotation of the observer
around the object around the \(z\)\sphinxhyphen{}axis goes in clockwise direction. The
starting point of this rotation is such that for \sphinxcode{\sphinxupquote{incl}}=0 and \sphinxcode{\sphinxupquote{phi=0}}
the \((x,y)\) in the image plane correspond to the \((x,y)\) in the
3\sphinxhyphen{}D space, with \(x\) pointing toward the right and \(y\) pointing
upward. Examples: if we fix the position of the observer at for instance
\sphinxcode{\sphinxupquote{incl}}=0 (i.e. we look at the object from the top from the positive
\(z\)\sphinxhyphen{}axis at infinity downward), then increasing \sphinxcode{\sphinxupquote{phi}} means rotating
the object counter\sphinxhyphen{}clockwise in the image plane.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{posang}}: {[}for images{]} This rotates the camera itself around
the \((0,0)\) point in the image plane.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{imageunform}}: Write out images in binary format

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{imageformatted}}: Write out images in text form (default)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tracetau}}: {[}for images{]} If this option is set, then instead
of ray\sphinxhyphen{}tracing a true image, the camera will compute the optical depth
at the wavelength given by e.g. \sphinxcode{\sphinxupquote{inu}} and puts this into an image
output as if it were a true image. Can be useful for analysis of models.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tracecolumn}}: {[}for images{]} Like \sphinxcode{\sphinxupquote{tracetau}} but instead of the optical
depth the simple column depth is computed in
\(\mathrm{g}/\mathrm{cm}^2\). \sphinxstyleemphasis{NOTE: for now only the column depth of the
dust.}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tracenormal}}: {[}for images: Default{]} Only if you specified
\sphinxcode{\sphinxupquote{tracetau}} or \sphinxcode{\sphinxupquote{tracecolumn}} before, and you are in child mode,
you may sometimes want to reset to normal imaging mode.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{apert}} or \sphinxcode{\sphinxupquote{useapert}}: {[}for
images/spectra{]} Use the image\sphinxhyphen{}plane aperture information from the file
\sphinxcode{\sphinxupquote{aperture\_info.inp}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{noapert}}: {[}for images/spectra{]} Do \sphinxstyleemphasis{not} use an image\sphinxhyphen{}plane aperture.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{diag\_subpix}}: {[}for images/spectra{]} write \sphinxcode{\sphinxupquote{subpixeling\_diagnostics.out}}
file, which contains the locations of all the pixels used, including the
subpixels (see Section {\hyperref[\detokenize{imagesspectra:sec-recursive-subpixeling}]{\sphinxcrossref{\DUrole{std,std-ref}{The solution: recursive sub\sphinxhyphen{}pixeling}}}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nphot\_therm}}: {[}for MC{]} The nr of photons for the thermal
Monte Carlo simulation. But it is better to use the \sphinxcode{\sphinxupquote{radmc3d.inp}} for this
(see Section {\hyperref[\detokenize{inputoutputfiles:sec-radmc-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: radmc3d.inp}}}}), because then you can see afterward with
which photon statistics the run was done.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nphot\_scat}}: {[}for MC{]} The nr of photons for the
scattering Monte Carlo simulation done before each image (and thus also in
the spectrum). But it is better to use the \sphinxcode{\sphinxupquote{radmc3d.inp}} for
this (see Section {\hyperref[\detokenize{inputoutputfiles:sec-radmc-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: radmc3d.inp}}}}), because then you can see afterward
with which photon statistics the run was done.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nphot\_mcmono}}: {[}for MC{]} The nr of photons for
the monochromatic Monte Carlo simulation. But it is better to use the
\sphinxcode{\sphinxupquote{radmc3d.inp}} for this (see Section {\hyperref[\detokenize{inputoutputfiles:sec-radmc-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: radmc3d.inp}}}}),
because then you can see afterward with which photon statistics the run
was done.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{countwrite}}: {[}for MC{]} The nr of photons between
‘sign of life’ outputs in a Monte Carlo run. Default is 1000. That means
that if you have \sphinxcode{\sphinxupquote{nrphot=10000000}} you will see ten\sphinxhyphen{}thousand
times something like \sphinxcode{\sphinxupquote{Photonnr: 19000}} on your screen. Can
be annoying. By adding \sphinxcode{\sphinxupquote{countwrite 100000}} to the command
line, you will only see a message every 100000 photon packages.

\end{itemize}


\section{Switching on/off of radiation processes}
\label{\detokenize{clioptions:switching-on-off-of-radiation-processes}}
\sphinxAtStartPar
You can switch certain radiative processes on or off with the following
command\sphinxhyphen{}line options (though often the \sphinxcode{\sphinxupquote{radmc3d.inp}} file also allows this):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inclstar}}: {[}for images and spectra{]} Include stars in
spectrum or images.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nostar}}: {[}for images and spectra{]} Do \sphinxstyleemphasis{not} include stars
in spectrum or images. Only the circumstellar / interstellar material is
imaged as if a perfect coronograph is used.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inclline}}: Include line emission and extinction
in the ray tracing (for images and spectra).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{noline}}: Do not include line emission and extinction
in the ray tracing (for images and spectra).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{incldust}}: Include dust emission, extinction and
(unless it is switched off) dust scattering in ray tracing (for images and
spectra).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nodust}}: Do not include dust emission, extinction and
scattering in ray tracing (for images and spectra).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maxnrscat 0}}: (if dust is included) Do not include
scattering in the images/spectra created by the camera. With \sphinxcode{\sphinxupquote{maxnrscat 1}}
you limit the scattering in the images/spectra to single\sphinxhyphen{}scattering.
With \sphinxcode{\sphinxupquote{maxnrscat 2}} to double scattering, etc. Can be useful to
figure out the relative importance of single vs multiple scattering.

\end{itemize}

\sphinxstepscope


\chapter{Which options are mutually incompatible?}
\label{\detokenize{optionscompat:which-options-are-mutually-incompatible}}\label{\detokenize{optionscompat:chap-table-possibilities}}\label{\detokenize{optionscompat::doc}}
\sphinxAtStartPar
For algorithmic reasons not all options / coordinate systems and all grids
are compatible with each other. Here is an overview of which options/methods
work when. Note that only options/methods for which this is a possible issue
are listed.


\section{Coordinate systems}
\label{\detokenize{optionscompat:coordinate-systems}}
\sphinxAtStartPar
Some coordinate systems exclude certain possibilities. Here is a list.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxAtStartPar
Option/Method:
&
\sphinxAtStartPar
Cart 3D
&
\sphinxAtStartPar
Sph 3D
&
\sphinxAtStartPar
Sph 2D (axisymm)
&
\sphinxAtStartPar
Sph 1D
\\
\hline
\sphinxAtStartPar
Second order ray\sphinxhyphen{}tracing
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
\\
\hline
\sphinxAtStartPar
Isotropic scattering
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
\\
\hline
\sphinxAtStartPar
An\sphinxhyphen{}isotropic scattering for thermal Monte Carlo
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
\\
\hline
\sphinxAtStartPar
An\sphinxhyphen{}isotropic scattering for monochromatic Monte Carlo
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
\\
\hline
\sphinxAtStartPar
An\sphinxhyphen{}isotropic scattering for images and spectra
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
no
\\
\hline
\sphinxAtStartPar
Full Stokes scattering for thermal Monte Carlo
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
\\
\hline
\sphinxAtStartPar
Full Stokes scattering for monochromatic Monte Carlo
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
\\
\hline
\sphinxAtStartPar
Full Stokes scattering for images and spectra
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
no
\\
\hline
\sphinxAtStartPar
Gas lines
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
\\
\hline
\sphinxAtStartPar
Gas lines and Doppler\sphinxhyphen{}shift line catching
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
no
&
\sphinxAtStartPar
no
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Scattering off dust grains}
\label{\detokenize{optionscompat:scattering-off-dust-grains}}
\sphinxAtStartPar
The inclusion of the effect of scattering off dust grains in images and spectra
typically requires a separate Monte Carlo computation for each image. This is
done automatically by RADMC\sphinxhyphen{}3D. But it means that there are some technical
limitations.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline

\sphinxAtStartPar
Option/Method:
&
\sphinxAtStartPar
No scattering
&
\sphinxAtStartPar
Isotropic approximation
&
\sphinxAtStartPar
Full anisotropic/Stokes scattering
\\
\hline
\sphinxAtStartPar
Fast multi\sphinxhyphen{}frequency ray tracing for spectra (auto)
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
no
&
\sphinxAtStartPar
no
\\
\hline
\sphinxAtStartPar
Multiple images at different vantage point at once
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
\\
\hline
\sphinxAtStartPar
Local observer
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
no
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Local observer mode}
\label{\detokenize{optionscompat:local-observer-mode}}
\sphinxAtStartPar
The local observer mode (Sect. {\hyperref[\detokenize{imagesspectra:sec-local-observer}]{\sphinxcrossref{\DUrole{std,std-ref}{For public outreach work: local observers inside the model}}}}) is a special mode
for putting the observer in the near\sphinxhyphen{}field of the object, or even right in
the middle of the object. It is not meant to be really for science use
(though it can be used for it, to a certain extent), but instead for
public outreach stuff. However, it is kept relatively basic, because to
make this mode compatible with all the functions of RADMC\sphinxhyphen{}3D would require
much more development and that is not worth it at the moment. So here are
the restrictions:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
Option/Method:
&
\sphinxAtStartPar
Local observer mode
\\
\hline
\sphinxAtStartPar
Dust isotropic scattering
&
\sphinxAtStartPar
yes
\\
\hline
\sphinxAtStartPar
Dust an\sphinxhyphen{}isotropic scattering
&
\sphinxAtStartPar
no
\\
\hline
\sphinxAtStartPar
Multiple images at different vantage point at once
&
\sphinxAtStartPar
yes
\\
\hline
\sphinxAtStartPar
Second\sphinxhyphen{}order ray\sphinxhyphen{}tracing
&
\sphinxAtStartPar
yes
\\
\hline
\sphinxAtStartPar
Doppler\sphinxhyphen{}catching of lines
&
\sphinxAtStartPar
no
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\chapter{Acquiring opacities from the WWW}
\label{\detokenize{opacitieswww:acquiring-opacities-from-the-www}}\label{\detokenize{opacitieswww:chap-acquiring-opacities}}\label{\detokenize{opacitieswww::doc}}
\sphinxAtStartPar
Opacities are the basic ingredients necessary for any model with
RADMC\sphinxhyphen{}3D. The example models in this package contain example opacities, but
for professional usage of RADMC\sphinxhyphen{}3D it may be necessary to get specific
opacity data from the web. These opacity data are usually in a wide variety
of formats. To enable RADMC\sphinxhyphen{}3D to read them usually requires a conversion
into RADMC\sphinxhyphen{}3D\sphinxhyphen{}readable form (see Section {\hyperref[\detokenize{inputoutputfiles:sec-opacities}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT (required for dust transfer): dustopac.inp and dustkappa\_*.inp or dustkapscatmat\_*.inp or dust\_optnk\_*.inp}}}} for dust
opacities and Section {\hyperref[\detokenize{lineradtrans:sec-molecule-xxx-inp}]{\sphinxcrossref{\DUrole{std,std-ref}{INPUT: Molecular/atomic data: The molecule\_XXX.inp file(s)}}}} for gas line opacities).

\sphinxAtStartPar
To make it easier for the user to create RADMC\sphinxhyphen{}3D\sphinxhyphen{}readable input files
from opacity data downloaded from the web, we now feature a new directory
\sphinxcode{\sphinxupquote{opac/}} in the RADMC\sphinxhyphen{}3D distribution in which, for several of
the most common WWW databases, we provide Python routines for the conversion.
Please read the \sphinxcode{\sphinxupquote{README\_*}} files in this directory and its
subdirectories for details.

\sphinxAtStartPar
Note also that Carsten Dominik made a very nice and easy\sphinxhyphen{}to\sphinxhyphen{}use tool to
generate dust opacities on the Linux/Mac command line. It is called
\sphinxcode{\sphinxupquote{optool}}, and can be found on github at
\sphinxurl{https://github.com/cdominik/optool} .
It can produce RADMC\sphinxhyphen{}3D\sphinxhyphen{}ready dust opacity files.

\sphinxstepscope


\chapter{Version tracker: Development history}
\label{\detokenize{versiontracker:version-tracker-development-history}}\label{\detokenize{versiontracker:chap-development-history}}\label{\detokenize{versiontracker::doc}}
\sphinxAtStartPar
This version overview is very rough, and has only been started as of version
0.25.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.25}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Second order integration, based on a vertex\sphinxhyphen{}based grid (as opposed to
the usual cell\sphinxhyphen{}based grid), implemented. This gives much smoother images,
and you don’t see the blocky cell structure anymore in the images. It
requires extra memory, though. See Section {\hyperref[\detokenize{imagesspectra:sec-second-order}]{\sphinxcrossref{\DUrole{std,std-ref}{Second order ray\sphinxhyphen{}tracing (Important information!)}}}}.

\item {} 
\sphinxAtStartPar
The number of photons for scattering Monte Carlo (i.e. the small MC
run done before each image, if dust scattering is active) can now be
chosen to be smaller for when you make a spectrum instead of an
image. Reason: Since you anyway integrate over the images for a
spectrum, you do not need the image to ‘look nice’, i.e. you can
afford more photon noise. You can set this in \sphinxcode{\sphinxupquote{radmc3d.inp}} by
setting \sphinxcode{\sphinxupquote{nphot\_spec=10000}}, for instance. See Section
{\hyperref[\detokenize{dustradtrans:sec-scat-monte-carlo}]{\sphinxcrossref{\DUrole{std,std-ref}{Scattered light in images and spectra: The ‘Scattering Monte Carlo’ computation}}}}.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.26}
\begin{itemize}
\item {} 
\sphinxAtStartPar
For line transfer: Added the ‘doppler catching’ method to the
code. This prevents bad numerical artifacts in images/spectra of regions
with large velocity gradients, where the doppler\sphinxhyphen{}shift between two
neighboring cells exceeds the intrinsic line width of the material in
the cell. See Section {\hyperref[\detokenize{lineradtrans:sec-doppler-catching}]{\sphinxcrossref{\DUrole{std,std-ref}{Preventing doppler jumps: The ‘doppler catching method’}}}}.

\item {} 
\sphinxAtStartPar
NOTE: Up to, and including, version \sphinxcode{\sphinxupquote{0.26\_23.02.11}} this
method (and for that matter any second order integration of line
transfer) was not stable when strong shocks or contact discontinuities
were encountered. This was because interpolation of the source function
\(S_\nu\equiv j_\nu/\alpha_\nu\) was done. Experimentation showed that
interpolation of the emissivity \(j_\nu\) is much more stable. As of
version \sphinxcode{\sphinxupquote{0.26\_27.02.11}} this is fixed.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.27}
\begin{itemize}
\item {} 
\sphinxAtStartPar
For line transfer: Implemented the possibility to use a Voigt line
profile instead of just a Gaussian. This was implemented by Thomas
Peters, and slightly modified by CPD. It uses the Voigt approximation by
Humlicek JQSRT 27, 437 (1982) as programmed by Schreier, JQSRT 48, 743
(1992). It requires a user\sphinxhyphen{}defined subroutine \sphinxcode{\sphinxupquote{userdef\_compute\_lorentz\_delta()}}
that sets the value of the Lorentz
profile delta. This implementation is not yet documented, and may still
be subject to modification.

\item {} 
\sphinxAtStartPar
Implemented the ‘Large Velocity Gradient’ (LVG) method (also
called the Sobolev method) of approximate non\sphinxhyphen{}LTE line transfer.

\item {} 
\sphinxAtStartPar
Implemented the optically thin populations method.

\item {} 
\sphinxAtStartPar
Implemented the possibility of reading linelist molecular data
instead of full molecular data. \sphinxstyleemphasis{Still needs testing.}

\item {} 
\sphinxAtStartPar
Finally implemented the positive \sphinxcode{\sphinxupquote{lines\_mode}} modes,
i.e. in which the level populations are computed and stored globally
before the ray\sphinxhyphen{}tracing. This has been latently in the code somewhat, but
unfinished. Now it is implemented. The advantage is: it may be under
some conditions much faster than the on\sphinxhyphen{}the\sphinxhyphen{}fly computation of the
populations during the ray\sphinxhyphen{}tracing (the negative \sphinxcode{\sphinxupquote{lines\_mode}}
modes). Also it allows you to write the populations to file, so that you
can examine them. Disadvantage: It is memory hungry.

\item {} 
\sphinxAtStartPar
The level subset capacilities are now limited to only the storage of
the levels in the global arrays (for positive \sphinxcode{\sphinxupquote{lines\_mode}} modes),
and to the lines that will appear in
images/spectra. For the rest, the full set of levels are always used
from now on.

\item {} 
\sphinxAtStartPar
Added a directory ‘\sphinxcode{\sphinxupquote{opac/}}‘ which contains programs
for generating your own dust opacities using optical constants from the
web, and for generating your own molecular/atomic input data files using
data from several web pages. The data from the web are not included, but
there are README files that point you to the web sites.

\item {} 
\sphinxAtStartPar
Tested the ‘fisheye’ fulldome (OMNIMAX) projection. It seems to
work! Thanks to Mario Flock.

\item {} 
\sphinxAtStartPar
Several small (and bigger) bugfixes
\begin{itemize}
\item {} 
\sphinxAtStartPar
Fixed bug that showed up when no dust is included.

\item {} 
\sphinxAtStartPar
Fixed bug that caused RADMC\sphinxhyphen{}3D to crash when using no stars.

\item {} 
\sphinxAtStartPar
Fixed bug that caused RADMC\sphinxhyphen{}3D to crash when making images at very
short wavelengths with nearly zero thermal emission.

\item {} 
\sphinxAtStartPar
Fixed bug in the AMR module when using second order integration or
the doppler catching method with certain kinds of AMR\sphinxhyphen{}arrangements of
cells.

\item {} 
\sphinxAtStartPar
Fixed many bugs when using a ‘piece of a cake’ model, i.e.
using spherical coordinates in 3\sphinxhyphen{}D, but having the \(\phi\)\sphinxhyphen{}grid going
not over the full \(0-2\pi\) range but e.g. just from 0 to \(\pi/4\). It
is rather rare that one really wants to use such grids (certainly not
for real physical models, I presume), but for visualization of data it
might be useful: for instance for visualizing a 3\sphinxhyphen{}D disk MHD model,
which is cut open so you can see also to the midplane. Now it
works. Thanks to Mario Flock.

\item {} 
\sphinxAtStartPar
Fixed bug with the aperture mode for spectra. Thanks to Daniel Harsono.

\item {} 
\sphinxAtStartPar
Fixed many bugs in linelist mode; now it works. Thanks to Attila
Juhasz.

\item {} 
\sphinxAtStartPar
Fixed a bug in LVG mode that caused it to fail when AMR was used.
Thanks to Anika Schmiedeke.

\item {} 
\sphinxAtStartPar
Fixed a tiny bug in \sphinxcode{\sphinxupquote{idl/radmc3dfits.pro}}: filename was
unused. Thanks to Stella Offner.

\item {} 
\sphinxAtStartPar
Retroactive bugfix from version 0.28 (see below): LVG and AMR mode.

\end{itemize}

\sphinxAtStartPar
For details and for smaller bugfixes, read the \sphinxcode{\sphinxupquote{src/Radmc\_3D\_LOG.txt}} document.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.28}
\begin{itemize}
\item {} 
\sphinxAtStartPar
A number of people complained that even without AMR the code
requires a huge amount of memory. That is because even if no AMR is
used, the cells are connected via the AMR tree. Since the AMR cells
contain information about which are the neighboring cells, and each cell
has 6 neighbors, and slots for 8 child\sphinxhyphen{}cells (which are unused in case
of a regular grid) this wastes a lot of memory space. The first big
improvement in version 0.28 is that, from now on, the AMR tree is only
set up and used if the grid indeed has refinement. If RADMC\sphinxhyphen{}3D notices
that the grid is regular, it will not allocate space for the AMR tree,
and everywhere in the code where the cell\sphinxhyphen{}management is done the code
will switch to regular grid mode. There is now a flag \sphinxcode{\sphinxupquote{amr\_tree\_present}}
that says whether the AMR tree is present or
not. Throughout the code there are now if\sphinxhyphen{}statements to switch between
using or not\sphinxhyphen{}using the AMR tree. This may make the code a tiny bit
slower, but this is only a minor reduction of speed. But as a result it
should now be much easier to load huge regular grid models into memory.

\item {} 
\sphinxAtStartPar
A small (but potentially nasty) bug was found and fixed for the case
when you use LVG mode on a grid with AMR\sphinxhyphen{}refinements. For the regular
grid case (even in version 0.27, when it still used the AMR tree) this
bug should not have caused problems, but perhaps you might want to check
nevertheless. Note: This bug is now also retroactively fixed in version
0.27. See, as always, \sphinxcode{\sphinxupquote{src/Radmc\_3D\_LOG.txt}} for details.

\item {} 
\sphinxAtStartPar
Added the possibility to visualize the location (along the line of
sight) of the \(\tau=1\) surface (or any \(\tau=\tau_s\) surface for that
matter). See new Section {\hyperref[\detokenize{imagesspectra:sec-tausurf}]{\sphinxcrossref{\DUrole{std,std-ref}{Visualizing the \textbackslash{}tau=1 surface}}}}. This can be very useful
for getting a 3\sphinxhyphen{}D feeling for \sphinxstyleemphasis{where} certain emission comes from.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.29}
\begin{itemize}
\item {} 
\sphinxAtStartPar
The big change in this version is that the whole stuff with the
global storage of level populations has been improved. In earlier
versions of RADMC\sphinxhyphen{}3D, either the populations of \sphinxstyleemphasis{all} levels of a
molecule were stored globally (potentially requiring huge amounts of
memory), or you would have to select a ‘subset’ of levels to store
globally. This subset selection had to be done by the user
(‘manually’, so to speak). You would have had to think a\sphinxhyphen{}priori which
lines you wish to model, and which levels they connect, and then, in the
\sphinxcode{\sphinxupquote{lines.inp}} file you would have to select these levels by
hand. That was cumbersome and prone to error. To avoid having to do this
you could use ‘on\sphinxhyphen{}the\sphinxhyphen{}fly’ calculation of populations (by making the
\sphinxcode{\sphinxupquote{lines\_mode}} negative), but that sometimes caused the code to
become terribly slow. \sphinxstyleemphasis{Now this is dramatically improved:} From now
on you can forget about the ‘on\sphinxhyphen{}the\sphinxhyphen{}fly’ calculation of populations.
Just use the ‘normal’ way by which RADMC\sphinxhyphen{}3D first calculates the
populations and then starts the ray\sphinxhyphen{}tracing. The subset\sphinxhyphen{}selection is now
done automatically by RADMC\sphinxhyphen{}3D, based on which wavelengths you want to
make the image(s) or spectra for (see Section
{\hyperref[\detokenize{lineradtrans:sec-calcstore-levpop}]{\sphinxcrossref{\DUrole{std,std-ref}{Background information: Calculation and storage of level populations}}}}). Now the on\sphinxhyphen{}the\sphinxhyphen{}fly methods are no longer
default and should not be used, unless absolutely necessary. Also the
‘manual’ subset selection is no longer necessary (though still
possible if absolutely desired).

\item {} 
\sphinxAtStartPar
Added the subbox and sample capabilities to the level populations.
See Sections {\hyperref[\detokenize{toolsinside:sec-subbox}]{\sphinxcrossref{\DUrole{std,std-ref}{Making a regularly\sphinxhyphen{}spaced datacube (‘subbox’) of AMR\sphinxhyphen{}based models}}}} and {\hyperref[\detokenize{toolsinside:sec-sampling}]{\sphinxcrossref{\DUrole{std,std-ref}{Alternative to subbox: arbitrary sampling of AMR\sphinxhyphen{}based models}}}}. Note that, in
order to make it easier to identify which levels were written to file,
the file formats of \sphinxcode{\sphinxupquote{***\_subbox.out}} and \sphinxcode{\sphinxupquote{***\_sample.out}} have been
slightly modified: A list of identification
numbers is added before the main data. For the dust temperature and dust
density this list is simply 1 2 3 4 …  (dust species 1, dust species
2, dust species 3 …), which is trivial. For the level populations
(e.g. the file \sphinxcode{\sphinxupquote{levelpop\_co\_subbox.out}} and \sphinxcode{\sphinxupquote{levelpop\_co\_sample.out}}
for the CO molecule) this list is, however,
essential when not all levels were computed (see Section
{\hyperref[\detokenize{lineradtrans:sec-calcstore-levpop}]{\sphinxcrossref{\DUrole{std,std-ref}{Background information: Calculation and storage of level populations}}}}). So if only level 4 and level 8 are stored,
then the identification list is 4 8.

\item {} 
\sphinxAtStartPar
Fixed a bug which caused the code to crash when you put a star
substantially far outside of the domain and try to make an image or
spectrum. Thanks, Erika Hamden, for the bug report.

\item {} 
\sphinxAtStartPar
Fixed a bug that prevented the \sphinxcode{\sphinxupquote{lines\_mode=50}} mode from
working. Now it works, and we can ask RADMC\sphinxhyphen{}3D to read the level
populations from file (rather than calculating them internally).  Also a
new section was added to this manual describing this option (Section
{\hyperref[\detokenize{lineradtrans:sec-nonlte-read-levelpop}]{\sphinxcrossref{\DUrole{std,std-ref}{Non\sphinxhyphen{}LTE Transfer: Reading the level populations from file}}}}).

\item {} 
\sphinxAtStartPar
Added VTK output options (see chapter {\hyperref[\detokenize{vtkoutput:chap-vtk-output}]{\sphinxcrossref{\DUrole{std,std-ref}{Visualization with VTK tools (e.g. Paraview or VisIt)}}}}) for
allowing 3\sphinxhyphen{}D visualization of your model setups using e.g. Paraview, a
freely available visualization tool.

\item {} 
\sphinxAtStartPar
Fixed a bug that occurred sometimes if a spectrum was made at
inclination 90 and phi 90. Thanks Stella Offner for reporting this bug.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.30}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Fixed bugs in the Henyey\sphinxhyphen{}Greenstein scattering mode.

\item {} 
\sphinxAtStartPar
Introduced the new binary I/O feature: No more hassle with
f77\sphinxhyphen{}unformatted records! The new binary mode is much simpler and more
straightforward. This will help reducing the file sizes for large models.
See Chapter {\hyperref[\detokenize{binaryio:chap-binary-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary I/O files}}}}.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.31}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Added the possibility, in cartesian coordinates, to ‘close the
box’, in the sense of making the domain boundaries thermal walls.
Each of the 6 boundaries can be set separately, so you can also have
just one thermall wall. Also the temperatures can be set separately
for each of the 6 boundaries. See Section {\hyperref[\detokenize{gridding:sec-thermal-boundaries}]{\sphinxcrossref{\DUrole{std,std-ref}{Thermal boundaries in Cartesian coordinates}}}}.

\item {} 
\sphinxAtStartPar
Added two new coordinate systems:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Cartesian 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel (the only remaining active coordinate
is \(z\)). The \(x\) and \(y\) dimensions are infinitely extended and
have translational symmetry. The photons can, however, travel in
full 3\sphinxhyphen{}D as always. See Section {\hyperref[\detokenize{gridding:sec-1d-plane-parallel}]{\sphinxcrossref{\DUrole{std,std-ref}{1\sphinxhyphen{}D Plane\sphinxhyphen{}parallel models}}}}.

\item {} 
\sphinxAtStartPar
Cartesian 2\sphinxhyphen{}D pencil\sphinxhyphen{}parallel (the two remaining active coordinate
are \(y\) and \(z\)). The \(x\) dimension is infinitely extended and
has translational symmetry. The photons can, however, travel in
full 3\sphinxhyphen{}D as always.

\item {} 
\sphinxAtStartPar
For the 1\sphinxhyphen{}D plane\sphinxhyphen{}parallel mode it is possible to include parallel
beams of radiative flux impinging on the 1\sphinxhyphen{}D atmosphere.

\item {} 
\sphinxAtStartPar
Attila Juhasz has improved the VTK output: Now it also supports
3\sphinxhyphen{}D spherical coordinates. Thanks, Attila!

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.32}

\sphinxAtStartPar
This is an intermediate version in which some stuff for the near\sphinxhyphen{}future
modus of polarization is implemented.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.33}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Some minor technical changes to the doppler\sphinxhyphen{}catching integration of
lines (storing the upper and lower level population instead of the
jnubase and anubase variables).

\item {} 
\sphinxAtStartPar
Added the classical escape probability to the LVG mode (see Section
{\hyperref[\detokenize{lineradtrans:sec-lvg}]{\sphinxcrossref{\DUrole{std,std-ref}{Non\sphinxhyphen{}LTE Transfer: The Large Velocity Gradient (LVG) + Escape Probability (EscProb) method}}}} for details).

\item {} 
\sphinxAtStartPar
Sped up the filling of the matrix of the statistical equilibrium
equation.

\item {} 
\sphinxAtStartPar
Vastly improved the LVG (and esc prob) method: Instead of the simple
‘lambda iteration style’ iteration as it was before, the \(A_{ik}\) is
now multiplied with \(\beta_{ik}\) (the escape probability of the line
i\sphinxhyphen{}\textgreater{}k) and the \(J_{ik}\) is replaced by
\(J_{ik}^{\mathrm{background}}\). This means that the solution is almost
instant, requiring only 2 or 3 iterations.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.34}

\sphinxAtStartPar
Implemented the Modified Random Walk method, based on Min, Dullemond,
Dominik, de Koter \& Hovenier (2009) A\&A 497, 155, and simplified by
Robitaille (2010) A\&A 520, 70. But beware: Still in the testing
phase! By default it is switched off.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.35}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Implemented polarized scattering off randomly oriented
particles. But beware: Still in the testing phase!

\item {} 
\sphinxAtStartPar
Fixed a bug in the modified random walk method (thanks to Daniel
Harsono for spotting the problem and thanks to Attila Juhasz for
finding the fix!)

\item {} 
\sphinxAtStartPar
Fixed two bugs that made it impossible to use second order
integration with axially symmetric spherical coordinates and/or
a finite\sphinxhyphen{}size star (thanks to Rolf Kuiper for reporting the bug).

\item {} 
\sphinxAtStartPar
Added the \sphinxcode{\sphinxupquote{sloppy}} command line option to spectrum and
image making in spherical coordinates. This was necessary because
RADMC\sphinxhyphen{}3D is always trying to make 100\% sure that all cells are picked
up by the subpixels. In spherical coordinates these cells can be
extremely non\sphinxhyphen{}cubic (they can be extremely flat or needle\sphinxhyphen{}like), which
means that under some projections RADMC\sphinxhyphen{}3D feels obliged to do extreme
sub\sphinxhyphen{}pixeling, which can make image\sphinxhyphen{} and spectrum\sphinxhyphen{}making extremely slow.
By adding the \sphinxcode{\sphinxupquote{sloppy}}  keyword on the command line, RADMC\sphinxhyphen{}3D
will limit it’s pubpixeling which could speed up the calculation very
much (but of course at your own risk!).

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.38}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Implemented OpenMP parallellization of the thermal Monte Carlo (by
Adriana Pohl). Still beta\sphinxhyphen{}version.

\item {} 
\sphinxAtStartPar
Bugfix in the mean intensity computation (mcmono) mode (thanks to Gwendoline Stephan).

\item {} 
\sphinxAtStartPar
Bugfix in the mean intensity computation (mcmono) mode (thanks to Seokho Lee).

\item {} 
\sphinxAtStartPar
Major bugfix in aperture mode (thanks to So ren Frimann).

\item {} 
\sphinxAtStartPar
Unformatted image format is from now on C\sphinxhyphen{}style binary instead of
F77\sphinxhyphen{}style unformatted.

\item {} 
\sphinxAtStartPar
The viewimage tool is now ported to Qt by Farzin Sereshti, meaning
that you can now use viewimage without having an IDL license. Viewimage
is a very powerful tool to interactively make and view images of your
model at different wavelengths and viewing angles. It can be found
in the directory \sphinxcode{\sphinxupquote{viewimage\_QT\_GUI/}}.

\item {} 
\sphinxAtStartPar
A Python package for RADMC\sphinxhyphen{}3D was developed by Attila Juhasz. It is
included as of RADMC\sphinxhyphen{}3D version 0.38 in the directory \sphinxcode{\sphinxupquote{python/}}.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.39}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Polarization mode is incompatible with mirror mode (in spherical
coordinates). An error message is now included to catch this.

\item {} 
\sphinxAtStartPar
Minor bugfix in \sphinxcode{\sphinxupquote{pick\_randomfreq\_db()}} (thanks to Seokho Lee).

\item {} 
\sphinxAtStartPar
Optimization of the OpenMP parallellization and extension of the
OpenMP parallellization to the Scattering Monte Carlo computation (both
by Farzin Sereshti).

\item {} 
\sphinxAtStartPar
Bugfix in \sphinxcode{\sphinxupquote{amrray\_module.f90}}: Sometimes one got ‘Photon
outside of cell’ error due to a numerical precision round\sphinxhyphen{}off
error. This bug is now (mostly?) fixed.

\item {} 
\sphinxAtStartPar
Bugfix in \sphinxcode{\sphinxupquote{sources\_module.f90}}: When using second order
integration (or doppler catching) for line transfer in spherical
coordinates, the line doppler shift was not transformed to spherical
coordinates. This is now fixed.

\item {} 
\sphinxAtStartPar
Several bugfixes in the modified random walk method by
John Ramsey. The method crashed for extreme optical depth problems
due to out\sphinxhyphen{}of\sphinxhyphen{}cell events. Still not 100\% perfect, but better.

\item {} 
\sphinxAtStartPar
John Ramsey also proposed two small fixes to the Planck function
routines so that the events of overflow are caught. Note: This might
change the results (in a tiny way: at the machine precision level) to
the extent that a model run by an old version might not yield the same
values to machine precision, but the differences should not matter in
any meaningful way.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.40}
\begin{itemize}
\item {} 
\sphinxAtStartPar
The RADMC\sphinxhyphen{}3D package is now ‘officially’ converting from IDL to
Python wrappers. The Python modules were already there since a long time
(thanks to Attila Juhasz!). But as of version 0.40 we will no longer
update/maintain the IDL scripts (though they remain there and should
remain working), and instead use python as the main setup and analysis
tools for RADMC\sphinxhyphen{}3D. The full conversion will still take some time, but
should be finished by the end of version 0.40.

\item {} 
\sphinxAtStartPar
Under some circumstances the simple 2x2 pixel plus sub\sphinxhyphen{}pixeling
method for making spectra (default method) can be dangerous. For some
grid geometries this can lead to under\sphinxhyphen{}resolving of the images that are
integrated to obtain the flux, leading to a too low flux.  So as of now
15.09.2016 the spectra and SEDs are always by default made with 100x100
images (and sub\sphinxhyphen{}pixeling of course). One can set the number of pixels
with npix. So if you do \sphinxcode{\sphinxupquote{radmc3dsednostarnpix2}} you get
the original behavior again.

\item {} 
\sphinxAtStartPar
Bugfix in \sphinxcode{\sphinxupquote{montecarlo\_module.f90}}:
The internal heat source method (which is still being tested)
had a bug. The bug manifested itself for optically thin cells with
non\sphinxhyphen{}negligible internal heat production. The energy was not immediately
added to the cell. It only got added upon re\sphinxhyphen{}absorption of that photon
package. Now this is fixed.

\item {} 
\sphinxAtStartPar
I now added some documentation for the heat source method, which
is useful for e.g. disk viscous accretion heating.

\item {} 
\sphinxAtStartPar
Bugfix in \sphinxcode{\sphinxupquote{montecarlo\_module.f90}}: When using mirror
symmetry in spherical coordinates in the \(\theta\)\sphinxhyphen{}coordinate
(i.e. modeling only the upper part of the disk and letting RADMC\sphinxhyphen{}3D
assume that the lower part is identical), the distributed source
luminosity was computed only for the top quadrant, and wasn’t multiplied
by 2. For most applications this does not cause problems, but for the
heat source (see above), for continuous stellar sources and for the
thermal origin of the isotropic scattering luminosity (for non\sphinxhyphen{}isotropic
scattering, mirror symmetry was not allowed anyway), this could lead to
a factor of 2 underestimation (only if mirror symmetry was used, i.e.
if the \(\theta\) coordinate was going only up to \(\pi/2\)). This is now
fixed. To test if the fix works one can simply make the same model
again, but now without using mirror symmetry (and thus using twice as
many cells in \(\theta\), to cover both the upper and lower half of the
object). This should yield (apart from some Monte Carlo noise) the same
results.

\item {} 
\sphinxAtStartPar
Improved the stability of the Modified Random Walk (MRW) method
a bit further.

\item {} 
\sphinxAtStartPar
Bug fix: scattering mode 3 (tabulated phase function, but not full
polarization) had a bug which caused images of scattered light to be
multiplied by some arbitrary number. Reason: as a phase function it
returned \(Z_{11}\) instead of \(4\pi Z_{11}/\kappa_{\mathrm{scat}}\). Most
people use either isotropic scattering (scattering mode 1), or
Henyey\sphinxhyphen{}Greenstein (scattering mode 2) or full polarization (scattering
mode 5), all of which are ok. At any rate: the problem is now fixed,
so scattering mode 3 should now also work.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 0.41}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Implemented a first testing version of the aligned grains:
only polarized thermal emission so far. Still very much a testing
version.

\item {} 
\sphinxAtStartPar
Implemented a method to also allow full Stokes vector polarized
scattering in the 2\sphinxhyphen{}D axisymmetric mode in spherical
coordinates. Until now the full scattering mode (scattering mode 5)
was only possible in full 3\sphinxhyphen{}D. Note however that anisotropic
scattering in 2\sphinxhyphen{}D axisymmetric models requires scattering mode 5,
which is the full scattering mode.  It is still not possible to use
intermediate scattering modes (like henyey\sphinxhyphen{}greenstein or any
scattering mode between 2 and 4) in 2\sphinxhyphen{}D axisymmetry. But those
intermediate modes are anyway more for testing than for real models,
so that should be ok.

\item {} 
\sphinxAtStartPar
Bugfixes to the OpenMP stuff. In particular the OpenMP
parallellization of the scattering MC crashed. This is now fixed.
In general the OpenMP stuff was a bit cleaned up.

\item {} 
\sphinxAtStartPar
Bugfix in thermal Monte Carlo with full polarization mode: needed
to reset the photon package after each thermal absorption/re\sphinxhyphen{}emission
event. Usually the effect is subtle, but had to be fixed.

\item {} 
\sphinxAtStartPar
Bugfix in reading the \sphinxcode{\sphinxupquote{scattering\_angular\_grid.inp}}:
the \sphinxcode{\sphinxupquote{theta}} angles should be converted into radian. But
this file was not officially offered before anyway.

\item {} 
\sphinxAtStartPar
Attila Juhasz has made a large improvement of his python package
for RADMC\sphinxhyphen{}3D. See the \sphinxcode{\sphinxupquote{python/}} directory. This is version
0.29 of his package. This package now also supports reading and
writing AMR grids.

\item {} 
\sphinxAtStartPar
Bugfix in VTK for 3\sphinxhyphen{}D spherical coordinates (thanks Attila Juhasz!).
Now it should work.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Version 2.0}

\sphinxAtStartPar
Version 2.0 is the version after 0.41. We skip version 1.0, because
version 1.0 could be mistaken for the first version of the code. Version
2.0 is mostly the same as 0.41, but with a few differences.
\begin{itemize}
\item {} 
\sphinxAtStartPar
IDL support is removed permanently. From now on, the front\sphinxhyphen{}end
functionality is only in Python. We assume Python 3.

\item {} 
\sphinxAtStartPar
Version 0.30.2 of the \sphinxcode{\sphinxupquote{radmc3dPy}} Python package (written by
Attila Juhasz) has been implemented. It is also being improved, mainly to
make its use easier (i.e. with more automatic default behavior).

\item {} 
\sphinxAtStartPar
A very simple \sphinxcode{\sphinxupquote{simpleread.py}} reading library is provided
as a ‘light version’ of radmc3dPy. It contains only some basic reading
functions, and only for ascii output (no binary files).

\item {} 
\sphinxAtStartPar
Some of the standard\sphinxhyphen{}output is shortened. You can also call a
Monte Carlo run with \sphinxcode{\sphinxupquote{radmc3d}} with the command line
options \sphinxcode{\sphinxupquote{countwrite 100000}} to make RADMC\sphinxhyphen{}3D write a
message only every \(10^5\) photon packages instead of every thousand.

\item {} 
\sphinxAtStartPar
We removed the fortran\sphinxhyphen{}unformatted data format from the manual,
and will remove it from the code in later versions. Use either text
(ascii) format or binary format.

\item {} 
\sphinxAtStartPar
The manual is now converted to Sphinx, from which the LaTeX version
and the HTML version can be automatically created.

\item {} 
\sphinxAtStartPar
{[}as of 11.11.2021{]} BUGFIX: For OpenMP parallel thermal Monte Carlo
computation of the dust temperatures for multiple grain species or
sizes, when \sphinxcode{\sphinxupquote{iranfreqmode=1}} (as opposed to the default value of
\sphinxcode{\sphinxupquote{iranfreqmode=0}}), the dust temperatures could acquire errors
because the \sphinxcode{\sphinxupquote{pick\_randomfreq\_db()}} subroutine uses the array
\sphinxcode{\sphinxupquote{db\_cumul(:)}} as thread private, but without having it declared
as such. This led to interference between threads. This is now
fixed.

\end{itemize}

\end{itemize}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}